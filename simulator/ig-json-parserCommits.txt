commit d87b5a68b6b75e278be2f51e7ead22d74931f3ff
Author: ttung <ttung@fb.com>
Date:   Wed Jun 11 12:01:43 2014 -0700

    Initial commit

diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..3ca18f4
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,23 @@
+Copyright (c) 2014, Instagram
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\ No newline at end of file
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..06cdc2b
--- /dev/null
+++ b/README.md
@@ -0,0 +1,4 @@
+ig-json-parser
+==============
+
+Fast JSON parser for java projects

commit d3d6200a35a9f1264cf8c772af3f2c78b5075aed
Author: Tony Tung <tonytung@merly.org>
Date:   Wed Jun 11 21:21:32 2014 -0700

    initial commit (based on internal commit ec2db63d106)

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..f8b92c3
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+.gradle
+build
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 0000000..94b4bcc
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,16 @@
+buildscript {
+}
+
+apply plugin: 'groovy'
+jar {
+    from files( { project(':javawriter').sourceSets.main.output.classesDir } )
+    from files( { project(':common').sourceSets.main.output.classesDir } )
+    from files( { project(':util').sourceSets.main.output.classesDir } )
+    from files( { project(':processor').sourceSets.main.output.classesDir } )
+}
+
+subprojects {
+  repositories {
+    mavenCentral()
+  }
+}
diff --git a/common/build.gradle b/common/build.gradle
new file mode 100644
index 0000000..0034129
--- /dev/null
+++ b/common/build.gradle
@@ -0,0 +1,6 @@
+apply plugin: 'java'
+
+dependencies {
+  compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.2.3+'
+}
+
diff --git a/common/src/main/java/com/instagram/common/json/JsonAnnotationProcessorConstants.java b/common/src/main/java/com/instagram/common/json/JsonAnnotationProcessorConstants.java
new file mode 100644
index 0000000..dcc6eb1
--- /dev/null
+++ b/common/src/main/java/com/instagram/common/json/JsonAnnotationProcessorConstants.java
@@ -0,0 +1,13 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json;
+
+/**
+ * Constants used by the json annotation processor.
+ */
+public class JsonAnnotationProcessorConstants {
+  /**
+   * This is the suffix used for the generated class.
+   */
+  public static final String HELPER_CLASS_SUFFIX = "__JsonHelper";
+}
diff --git a/common/src/main/java/com/instagram/common/json/JsonFactoryHolder.java b/common/src/main/java/com/instagram/common/json/JsonFactoryHolder.java
new file mode 100644
index 0000000..c15db95
--- /dev/null
+++ b/common/src/main/java/com/instagram/common/json/JsonFactoryHolder.java
@@ -0,0 +1,12 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json;
+
+import com.fasterxml.jackson.core.JsonFactory;
+
+/**
+ * Holds the {@link JsonFactory} singleton.
+ */
+public class JsonFactoryHolder {
+  public static final JsonFactory APP_FACTORY = new JsonFactory();
+}
diff --git a/common/src/main/java/com/instagram/common/json/annotation/JsonField.java b/common/src/main/java/com/instagram/common/json/annotation/JsonField.java
new file mode 100644
index 0000000..2d7e349
--- /dev/null
+++ b/common/src/main/java/com/instagram/common/json/annotation/JsonField.java
@@ -0,0 +1,177 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.CLASS;
+
+/**
+ * Apply this to a field in a class annotated with {@link JsonType}.  This tells the annotation
+ * processor which fields exist, and how they may to/from the json object.
+ */
+@Retention(CLASS) @Target(FIELD)
+public @interface JsonField {
+  /**
+   * This controls how we deal with type mismatches.  If a {@link TypeMapping#EXACT} mapping is
+   * requested, the json data type must exactly match the java data type.  If the destination field
+   * is a java object and there is a data type mismatch, the field will be set to null.   If the
+   * destination field is a primitive, there is no way for us to indicate that a mismatch has
+   * occurred, so we are forced to throw a {@link JsonException}.
+   *
+   * If a {@link TypeMapping#COERCED} mapping is requested, we will do our best to coerce it into
+   * the proper type.
+   */
+  public enum TypeMapping { EXACT, COERCED };
+
+  /**
+   * This is the field name in json.
+   */
+  String fieldName();
+
+  /**
+   * This controls how we deal with type mismatches.  Note that this is ignored if
+   * {@link #valueExtractFormatter()} is specified.
+   * @see TypeMapping
+   * @see #valueExtractFormatter()
+   */
+  TypeMapping mapping() default TypeMapping.COERCED;
+
+  /**
+   * This string allows consumers to override how we extract the value from the {@link JsonParser}
+   * object.  The following formatters will be used to in generating the code:
+   * <table border=1 cellspacing=0>
+   *   <tr>
+   *     <th>parser_object</th>
+   *     <td>the instance of {@link JsonParser} being read from
+   *   </tr>
+   *   <tr>
+   *     <th>subobject_helper_class</th>
+   *     <td>when parsing a subobject, this refers to the class responsible for parsing the
+   *      subobject type.
+   *     </td>
+   *   </tr>
+   * </table>
+   *
+   * Sane defaults are provided except in the case of {@link Enum}.
+   */
+  String valueExtractFormatter() default "";
+
+  /**
+   * This string allows consumers to override how we assign the rvalue to the java field.  The
+   * following formatters will be used to in generating the code:
+   * <table border=1 cellspacing=0>
+   *   <tr>
+   *     <th>object_varname</th>
+   *     <td>the name of the variable referring to the instance of the object being parsed</td>
+   *   </tr>
+   *   <tr>
+   *     <th>field_varname</th>
+   *     <td>the name of the variable referring to the field within the object being parsed</td>
+   *   </tr>
+   *   <tr>
+   *     <th>extracted_value</th>
+   *     <td>the value parsed, after processing by {@link #valueExtractFormatter()}
+   *   </tr>
+   * </table>
+   *
+   * While having both {@link #valueExtractFormatter()} and {@link #fieldAssignmentFormatter()} may
+   * seem redundant, they actually serve radically different purposes when we parse arrays.
+   * {@link #valueExtractFormatter()} will control how we derive each value in the list, while
+   * {@link #fieldAssignmentFormatter()} will control how we assign the list to the java field.
+   * <p/>
+   * For instance, if we wanted to parse an array of integers, increment each element by 1, and
+   * save a sublist:
+   * <pre>
+   *   &#64;JsonField(valueExtractFormatter=&quot;%1$s.getIntValue() + 1&quot;,
+   *              fieldAssignmentFormatter=&quot;${object_varname}.${field_varname} =
+   *                                        ${extracted_value}.subList(2, 5)&quot;)
+   *   List&lt;Integer&gt; incrementedAndReversed;
+   * </pre>
+   */
+  String fieldAssignmentFormatter() default "";
+
+  /**
+   * This string allows consumers to override how we serialize a java field back to json.  The
+   * string is used as a formatter to generate the actual code that serializes the data.  The format
+   * string can contain the following formatting tokens:
+   * <ul>
+   *   <li>
+   *     ${generator_object}: the name of the variable holding the reference to the json generator
+   *     object
+   *   </li>
+   *   <li>
+   *     ${object_varname}: the name of the variable that references the object that encloses the
+   *     current field
+   *   </li>
+   *   <li>
+   *     ${field_varname}: the name of the variable that references the current field
+   *   </li>
+   *   <li>
+   *     ${iterator}: the name of the variable that references the current element of an array field
+   *   </li>
+   *   <li>
+   *     ${json_fieldname}: the json field name
+   *   </li>
+   *   <li>
+   *     ${subobject_helper_class}: the class that is responsible for serializing the current field
+   *   </li>
+   * </ul>
+   * <p/>
+   * The formatting tokens are not always valid, depending on the nature of the field being
+   * serialized.  The following table shows which fields are valid under which situations.
+   * <table border=1 cellspacing=0>
+   *   <tr>
+   *     <th>Field type</th>
+   *     <th>${generator_object}</th>
+   *     <th>${object_varname}</th>
+   *     <th>${field_varname}</th>
+   *     <th>${iterator}</th>
+   *     <th>${json_fieldname}</th>
+   *     <th>${subobject_helper_class}</th>
+   *   </tr>
+   *   <tr>
+   *     <th>Scalars</th>
+   *     <td>&#x2714;</td>
+   *     <td>&#x2714;</td>
+   *     <td>&#x2714;</td>
+   *     <td>&#x2717;</td>
+   *     <td>&#x2714;</td>
+   *     <td>&#x2717;</td>
+   *   </tr>
+   *   <tr>
+   *     <th>Subobject</th>
+   *     <td>&#x2714;</td>
+   *     <td>&#x2714;</td>
+   *     <td>&#x2714;</td>
+   *     <td>&#x2717;</td>
+   *     <td>&#x2717;</td>
+   *     <td>&#x2714;</td>
+   *   </tr>
+   *   <tr>
+   *     <th>List of scalars</th>
+   *     <td>&#x2714;</td>
+   *     <td>&#x2717;</td>
+   *     <td>&#x2717;</td>
+   *     <td>&#x2714;</td>
+   *     <td>&#x2717;</td>
+   *     <td>&#x2717;</td>
+   *   </tr>
+   *   <tr>
+   *     <th>List of subobjects</th>
+   *     <td>&#x2714;</td>
+   *     <td>&#x2717;</td>
+   *     <td>&#x2717;</td>
+   *     <td>&#x2714;</td>
+   *     <td>&#x2717;</td>
+   *     <td>&#x2714;</td>
+   *   </tr>
+   * </table>
+   * <p/>
+   * Sane defaults are provided except in the case of {@link Enum}.  Use of this feature should be
+   * an exception rather than the norm.
+   */
+  String serializeCodeFormatter() default "";
+}
diff --git a/common/src/main/java/com/instagram/common/json/annotation/JsonType.java b/common/src/main/java/com/instagram/common/json/annotation/JsonType.java
new file mode 100644
index 0000000..6694de6
--- /dev/null
+++ b/common/src/main/java/com/instagram/common/json/annotation/JsonType.java
@@ -0,0 +1,25 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.CLASS;
+
+/**
+ * This annotation is applied to any class for which a json parser should be automatically
+ * generated.
+ */
+@Retention(CLASS) @Target(TYPE)
+public @interface JsonType {
+  public static final String POSTPROCESSING_METHOD_NAME = "postprocess";
+
+  /**
+   * This annotation specifies that a method with the name specified by
+   * {@link #POSTPROCESSING_METHOD_NAME} (currently "postprocess") on the class that is being
+   * generated that should be called once parsing is finished.
+   */
+  boolean postprocessingEnabled() default false;
+}
diff --git a/demo/AndroidManifest.xml b/demo/AndroidManifest.xml
new file mode 100644
index 0000000..b466aba
--- /dev/null
+++ b/demo/AndroidManifest.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.instagram.jsonbenchmark.app"
+          android:versionCode="100"
+          android:versionName="1.0.0"
+          android:installLocation="auto"
+    >
+
+  <uses-sdk android:minSdkVersion="9"
+            android:targetSdkVersion="16"
+      />
+
+  <uses-feature android:name="android.hardware.screen.portrait"
+                android:required="false"
+      />
+
+  <supports-screens android:smallScreens="true"
+                    android:normalScreens="true"
+                    android:largeScreens="true"
+                    android:xlargeScreens="true"
+      />
+
+  <application
+      android:label="IgBenchmark"
+      android:hardwareAccelerated="true"
+      android:allowTaskReparenting="true"
+      >
+
+    <activity android:name="com.instagram.common.json.app.BenchmarkActivity"
+              android:screenOrientation="portrait"
+              android:configChanges="keyboardHidden|orientation|screenSize"
+              android:windowSoftInputMode="adjustNothing"
+              android:clearTaskOnLaunch="false"
+              android:launchMode="singleTop"
+              android:alwaysRetainTaskState="true">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+    </activity>
+
+  </application>
+
+</manifest>
diff --git a/demo/build.gradle b/demo/build.gradle
new file mode 100644
index 0000000..ed8cf2b
--- /dev/null
+++ b/demo/build.gradle
@@ -0,0 +1,46 @@
+buildscript {
+  repositories {
+    mavenCentral()
+  }
+
+  dependencies {
+    classpath group: 'com.android.tools.build', name: 'gradle', version: '0.9.0+'
+  }
+}
+
+apply plugin: 'android'
+
+dependencies {
+  compile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.2.3+'
+  compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.2.3+'
+  compile project(':demo:igmodel')
+}
+
+android {
+  compileSdkVersion 19
+  buildToolsVersion "19.1"
+
+  defaultConfig {
+    minSdkVersion 10
+    targetSdkVersion 19
+  }
+
+  sourceSets {
+    main {
+      manifest {
+        srcFile 'AndroidManifest.xml'
+      }
+      java {
+        srcDir 'src/java/main'
+      }
+      res {
+        srcDir 'src/main/res'
+      }
+    }
+  }
+
+  packagingOptions {
+    exclude 'META-INF/LICENSE'
+    exclude 'META-INF/NOTICE'
+  }
+}
diff --git a/demo/igmodel/build.gradle b/demo/igmodel/build.gradle
new file mode 100644
index 0000000..17a0b52
--- /dev/null
+++ b/demo/igmodel/build.gradle
@@ -0,0 +1,12 @@
+apply plugin: 'java'
+
+compileJava {
+  options.compilerArgs += [
+                       '-processor',
+                       'com.instagram.common.json.annotation.processor.JsonAnnotationProcessor'
+  ]
+}
+dependencies {
+  compile project(':common')
+  compile project(':processor')
+}
diff --git a/demo/igmodel/src/main/java/com/instagram/common/json/app/igmodel/IgListOfModels.java b/demo/igmodel/src/main/java/com/instagram/common/json/app/igmodel/IgListOfModels.java
new file mode 100644
index 0000000..de53fea
--- /dev/null
+++ b/demo/igmodel/src/main/java/com/instagram/common/json/app/igmodel/IgListOfModels.java
@@ -0,0 +1,17 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.app.igmodel;
+
+import java.util.List;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+/**
+ * List of models for iterations > 1
+ */
+@JsonType
+public class IgListOfModels {
+  @JsonField(fieldName = "list")
+  List<IgModelRequest> list;
+}
diff --git a/demo/igmodel/src/main/java/com/instagram/common/json/app/igmodel/IgModelRequest.java b/demo/igmodel/src/main/java/com/instagram/common/json/app/igmodel/IgModelRequest.java
new file mode 100644
index 0000000..d1805ec
--- /dev/null
+++ b/demo/igmodel/src/main/java/com/instagram/common/json/app/igmodel/IgModelRequest.java
@@ -0,0 +1,160 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.app.igmodel;
+
+import java.util.List;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+public class IgModelRequest {
+  @JsonField(fieldName = "meta")
+  Meta meta;
+  @JsonField(fieldName = "data")
+  List<Data> data;
+}
+
+@JsonType
+class Meta {
+  @JsonField(fieldName = "code")
+  int code;
+}
+
+@JsonType
+class Data {
+  @JsonField(fieldName = "attribution")
+  String attribution;
+  @JsonField(fieldName = "tags")
+  List<String> tags;
+  @JsonField(fieldName = "type")
+  String type;
+  @JsonField(fieldName = "location")
+  Location location;
+  @JsonField(fieldName = "comments")
+  CommentMeta comments;
+  @JsonField(fieldName = "filter")
+  String filter;
+  @JsonField(fieldName = "created_time")
+  String created_time;
+  @JsonField(fieldName = "link")
+  String link;
+  @JsonField(fieldName = "likes")
+  LikeMeta likes;
+  @JsonField(fieldName = "images")
+  ImageMeta images;
+  @JsonField(fieldName = "users_in_photo")
+  List<TaggedUser> users_in_photo;
+  @JsonField(fieldName = "caption")
+  Caption caption;
+  @JsonField(fieldName = "user_has_liked")
+  boolean user_has_liked;
+  @JsonField(fieldName = "id")
+  String id;
+  @JsonField(fieldName = "user")
+  User user;
+}
+
+@JsonType
+class Location {
+  @JsonField(fieldName = "latitude")
+  float latitude;
+  @JsonField(fieldName = "longitude")
+  float longitude;
+  @JsonField(fieldName = "name")
+  String name;
+  @JsonField(fieldName = "id")
+  long id;
+}
+
+@JsonType
+class CommentMeta {
+  @JsonField(fieldName = "count")
+  int count;
+  @JsonField(fieldName = "data")
+  List<Comment> data;
+}
+
+@JsonType
+class LikeMeta {
+  @JsonField(fieldName = "count")
+  int count;
+  @JsonField(fieldName = "data")
+  List<User> data;
+}
+
+@JsonType
+class ImageMeta {
+  @JsonField(fieldName = "low_resolution")
+  ImageData low_resolution;
+  @JsonField(fieldName = "thumbnail")
+  ImageData thumbnail;
+  @JsonField(fieldName = "standard_resolution")
+  ImageData standard_resolution;
+}
+
+@JsonType
+class TaggedUser {
+  @JsonField(fieldName = "position")
+  Position position;
+  @JsonField(fieldName = "user")
+  User user;
+}
+
+@JsonType
+class Caption {
+  @JsonField(fieldName = "created_time")
+  String created_time;
+  @JsonField(fieldName = "text")
+  String text;
+  @JsonField(fieldName = "from")
+  User from;
+  @JsonField(fieldName = "id")
+  String id;
+}
+
+@JsonType
+class Comment {
+  @JsonField(fieldName = "created_time")
+  String created_time;
+  @JsonField(fieldName = "text")
+  String text;
+  @JsonField(fieldName = "from")
+  User from;
+  @JsonField(fieldName = "id")
+  String id;
+}
+
+@JsonType
+class User {
+  @JsonField(fieldName = "username")
+  String username;
+  @JsonField(fieldName = "website")
+  String website;
+  @JsonField(fieldName = "profile_picture")
+  String profile_picture;
+  @JsonField(fieldName = "full_name")
+  String full_name;
+  @JsonField(fieldName = "bio")
+  String bio;
+  @JsonField(fieldName = "id")
+  String id;
+}
+
+@JsonType
+class ImageData {
+  @JsonField(fieldName = "url")
+  String url;
+  @JsonField(fieldName = "width")
+  int width;
+  @JsonField(fieldName = "height")
+  int height;
+}
+
+@JsonType
+class Position {
+  @JsonField(fieldName = "x")
+  float x;
+  @JsonField(fieldName = "y")
+  float y;
+}
diff --git a/demo/igmodel/src/main/java/com/instagram/common/json/app/igmodel/IgModelWorker.java b/demo/igmodel/src/main/java/com/instagram/common/json/app/igmodel/IgModelWorker.java
new file mode 100644
index 0000000..09e5b9e
--- /dev/null
+++ b/demo/igmodel/src/main/java/com/instagram/common/json/app/igmodel/IgModelWorker.java
@@ -0,0 +1,18 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.app.igmodel;
+
+import java.io.IOException;
+
+/**
+ * Helper class to parse the model.
+ */
+public class IgModelWorker {
+  public IgModelRequest parseFromString(String input) throws IOException {
+    return IgModelRequest__JsonHelper.parseFromJson(input);
+  }
+
+  public IgListOfModels parseListFromString(String input) throws IOException {
+    return IgListOfModels__JsonHelper.parseFromJson(input);
+  }
+}
diff --git a/demo/src/main/java/com/instagram/common/json/app/BenchmarkActivity.java b/demo/src/main/java/com/instagram/common/json/app/BenchmarkActivity.java
new file mode 100644
index 0000000..f9fb4b4
--- /dev/null
+++ b/demo/src/main/java/com/instagram/common/json/app/BenchmarkActivity.java
@@ -0,0 +1,146 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.app;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.util.Base64;
+import android.util.Base64InputStream;
+import android.view.View;
+import android.widget.EditText;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.instagram.jsonbenchmark.app.R;
+import com.instagram.common.json.app.igmodel.IgListOfModels;
+import com.instagram.common.json.app.igmodel.IgModelRequest;
+import com.instagram.common.json.app.igmodel.IgModelWorker;
+import com.instagram.common.json.app.ommodel.OmListOfModels;
+import com.instagram.common.json.app.ommodel.OmModelRequest;
+import com.instagram.common.json.app.ommodel.OmModelWorker;
+
+import com.google.common.io.Closeables;
+
+public class BenchmarkActivity extends Activity {
+  private String mJsonString;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity);
+
+    try {
+      mJsonString = loadFromFile(R.raw.input);
+    } catch (IOException e) {
+      Toast.makeText(this, "yeah, bad things happened", Toast.LENGTH_LONG)
+          .show();
+      return;
+    }
+
+    View.OnClickListener listener = new View.OnClickListener() {
+      @Override
+      public void onClick(View view) {
+        boolean useIgParser = (view == findViewById(R.id.ig_parse_button));
+        boolean useOmParser = (view == findViewById(R.id.om_parse_button));
+
+        BenchmarkStats bs = new BenchmarkStats();
+
+        int iterations = getIterationCount();
+        if (iterations == 1) {
+          IgModelRequest igModel;
+          OmModelRequest omModel;
+          try {
+            bs.before();
+            if (useIgParser) {
+              igModel = new IgModelWorker().parseFromString(mJsonString);
+            } else if (useOmParser) {
+              omModel = new OmModelWorker().parseFromString(mJsonString);
+            }
+            bs.after();
+          } catch (IOException ex) {
+            Toast.makeText(BenchmarkActivity.this, "yeah, bad things happened", Toast.LENGTH_LONG)
+                .show();
+            return;
+          }
+        } else {
+          String multiIterationInputString = generateInputString(iterations);
+          IgListOfModels igListofModels;
+          OmListOfModels omListofModels;
+          try {
+            bs.before();
+            if (useIgParser) {
+              igListofModels = new IgModelWorker().parseListFromString(multiIterationInputString);
+            } else if (useOmParser) {
+              omListofModels = new OmModelWorker().parseListFromString(multiIterationInputString);
+            }
+            bs.after();
+          } catch (IOException ex) {
+            Toast.makeText(BenchmarkActivity.this, "yeah, bad things happened", Toast.LENGTH_LONG)
+                .show();
+            return;
+          }
+        }
+
+        ((TextView) findViewById(R.id.results)).setText(bs.renderResultsToText());
+      }
+    };
+
+    findViewById(R.id.ig_parse_button).setOnClickListener(listener);
+    findViewById(R.id.om_parse_button).setOnClickListener(listener);
+
+    findViewById(R.id.quit).setOnClickListener(new View.OnClickListener() {
+      @Override
+      public void onClick(View view) {
+        System.exit(0);
+      }
+    });
+  }
+
+  private String generateInputString(int iterations) {
+    StringBuilder sb = new StringBuilder();
+
+    sb.append("{\"list\": [");
+
+    for (int ix = 0; ix < iterations; ix ++) {
+      if (ix != 0) {
+        sb.append(",");
+      }
+      sb.append(mJsonString);
+    }
+
+    sb.append("]}");
+
+    return sb.toString();
+  }
+
+  String loadFromFile(int resourceId) throws IOException {
+    InputStreamReader inputStreamReader = null;
+
+    try {
+      // we're doing this absurd thing with encoding the json file in base64 because phabricator
+      // chokes on it otherwise.
+      inputStreamReader =
+          new InputStreamReader(
+              new Base64InputStream(getResources().openRawResource(resourceId), Base64.DEFAULT),
+              "UTF-8");
+      StringBuilder sb = new StringBuilder();
+      char[] buffer = new char[8 * 1024];
+      int bytesRead;
+
+      while ((bytesRead = inputStreamReader.read(buffer)) != -1) {
+        sb.append(buffer, 0, bytesRead);
+      }
+
+      return sb.toString();
+    } finally {
+      Closeables.closeQuietly(inputStreamReader);
+    }
+  }
+
+  int getIterationCount() {
+    return Integer.valueOf(((EditText) findViewById(R.id.iterations)).getText().toString());
+  }
+}
diff --git a/demo/src/main/java/com/instagram/common/json/app/BenchmarkStats.java b/demo/src/main/java/com/instagram/common/json/app/BenchmarkStats.java
new file mode 100644
index 0000000..8b461d9
--- /dev/null
+++ b/demo/src/main/java/com/instagram/common/json/app/BenchmarkStats.java
@@ -0,0 +1,90 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.app;
+
+import android.os.Debug;
+import android.os.SystemClock;
+
+/**
+ * Utility class to gather stats.
+ */
+class BenchmarkStats {
+  enum State {
+    INIT,
+    BEFORE_CALLED,
+    AFTER_CALLED,
+    ;
+  }
+
+  private Debug.MemoryInfo mMemoryInfoBefore;
+  private Debug.MemoryInfo mMemoryInfoAfter;
+  private int mAllocCount;
+  private int mAllocSize;
+  private int mFreeCount;
+  private int mFreeSize;
+  private long mBeforeTimestamp;
+  private long mAfterTimestamp;
+  private State mState;
+
+  BenchmarkStats() {
+    mMemoryInfoBefore = new Debug.MemoryInfo();
+    mMemoryInfoAfter = new Debug.MemoryInfo();
+    mState = State.INIT;
+  }
+
+  /**
+   * Grabs the pre-snapshot.  Forces a {@link System#gc()} before collecting stats.
+   */
+  synchronized void before() {
+    if (mState != State.INIT) {
+      throw new IllegalStateException("unexpected state");
+    }
+
+    mState = State.BEFORE_CALLED;
+    System.gc();
+    Debug.getMemoryInfo(mMemoryInfoBefore);
+    Debug.startAllocCounting();
+    mBeforeTimestamp = SystemClock.elapsedRealtime();
+  }
+
+  /**
+   * Grabs the post-snapshot.
+   */
+  synchronized void after() {
+    mAfterTimestamp = SystemClock.elapsedRealtime();
+    Debug.stopAllocCounting();
+    Debug.getMemoryInfo(mMemoryInfoAfter);
+
+    mAllocCount = Debug.getGlobalAllocCount();
+    mAllocSize = Debug.getGlobalAllocSize();
+    mFreeCount = Debug.getGlobalFreedCount();
+    mFreeSize = Debug.getGlobalFreedSize();
+
+    if (mState != State.BEFORE_CALLED) {
+      throw new IllegalStateException("unexpected state");
+    }
+    mState = State.AFTER_CALLED;
+  }
+
+  String renderResultsToText() {
+    if (mState != State.AFTER_CALLED) {
+      throw new IllegalStateException("attempted to render results before after was called");
+    }
+
+    StringBuilder sb = new StringBuilder();
+
+    sb.append("elapsed time: ")
+        .append(mAfterTimestamp - mBeforeTimestamp)
+        .append("ms\n");
+    sb.append("pss delta: ")
+        .append(mMemoryInfoAfter.dalvikPss - mMemoryInfoBefore.dalvikPss)
+        .append("\n");
+
+    sb.append("alloc count: ").append(mAllocCount).append("\n");
+    sb.append("alloc size: ").append(mAllocSize).append("\n");
+    sb.append("free count: ").append(mFreeCount).append("\n");
+    sb.append("free size: ").append(mFreeSize).append("\n");
+
+    return sb.toString();
+  }
+}
diff --git a/demo/src/main/java/com/instagram/common/json/app/ommodel/OmListOfModels.java b/demo/src/main/java/com/instagram/common/json/app/ommodel/OmListOfModels.java
new file mode 100644
index 0000000..cc8ada3
--- /dev/null
+++ b/demo/src/main/java/com/instagram/common/json/app/ommodel/OmListOfModels.java
@@ -0,0 +1,15 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.app.ommodel;
+
+import java.util.List;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+/**
+ * List of models for iterations > 1
+ */
+public class OmListOfModels {
+  @JsonProperty("list")
+  List<OmModelRequest> list;
+}
diff --git a/demo/src/main/java/com/instagram/common/json/app/ommodel/OmModelRequest.java b/demo/src/main/java/com/instagram/common/json/app/ommodel/OmModelRequest.java
new file mode 100644
index 0000000..247bba2
--- /dev/null
+++ b/demo/src/main/java/com/instagram/common/json/app/ommodel/OmModelRequest.java
@@ -0,0 +1,147 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.app.ommodel;
+
+import java.util.List;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+public class OmModelRequest {
+  @JsonProperty("meta")
+  Meta meta;
+  @JsonProperty("data")
+  List<Data> data;
+}
+
+class Meta {
+  @JsonProperty("code")
+  int code;
+}
+
+class Data {
+  @JsonProperty("attribution")
+  String attribution;
+  @JsonProperty("tags")
+  List<String> tags;
+  @JsonProperty("type")
+  String type;
+  @JsonProperty("location")
+  Location location;
+  @JsonProperty("comments")
+  CommentMeta comments;
+  @JsonProperty("filter")
+  String filter;
+  @JsonProperty("created_time")
+  String created_time;
+  @JsonProperty("link")
+  String link;
+  @JsonProperty("likes")
+  LikeMeta likes;
+  @JsonProperty("images")
+  ImageMeta images;
+  @JsonProperty("users_in_photo")
+  List<TaggedUser> users_in_photo;
+  @JsonProperty("caption")
+  Caption caption;
+  @JsonProperty("user_has_liked")
+  boolean user_has_liked;
+  @JsonProperty("id")
+  String id;
+  @JsonProperty("user")
+  User user;
+}
+
+class Location {
+  @JsonProperty("latitude")
+  float latitude;
+  @JsonProperty("longitude")
+  float longitude;
+  @JsonProperty("name")
+  String name;
+  @JsonProperty("id")
+  long id;
+}
+
+
+class CommentMeta {
+  @JsonProperty("count")
+  int count;
+  @JsonProperty("data")
+  List<Comment> data;
+}
+
+class LikeMeta {
+  @JsonProperty("count")
+  int count;
+  @JsonProperty("data")
+  List<User> data;
+}
+
+class ImageMeta {
+  @JsonProperty("low_resolution")
+  ImageData low_resolution;
+  @JsonProperty("thumbnail")
+  ImageData thumbnail;
+  @JsonProperty("standard_resolution")
+  ImageData standard_resolution;
+}
+
+class TaggedUser {
+  @JsonProperty("position")
+  Position position;
+  @JsonProperty("user")
+  User user;
+}
+
+class Caption {
+  @JsonProperty("created_time")
+  String created_time;
+  @JsonProperty("text")
+  String text;
+  @JsonProperty("from")
+  User from;
+  @JsonProperty("id")
+  String id;
+}
+
+class Comment {
+  @JsonProperty("created_time")
+  String created_time;
+  @JsonProperty("text")
+  String text;
+  @JsonProperty("from")
+  User from;
+  @JsonProperty("id")
+  String id;
+}
+
+class User {
+  @JsonProperty("username")
+  String username;
+  @JsonProperty("website")
+  String website;
+  @JsonProperty("profile_picture")
+  String profile_picture;
+  @JsonProperty("full_name")
+  String full_name;
+  @JsonProperty("bio")
+  String bio;
+  @JsonProperty("id")
+  String id;
+}
+
+class ImageData {
+  @JsonProperty("url")
+  String url;
+  @JsonProperty("width")
+  int width;
+  @JsonProperty("height")
+  int height;
+}
+
+class Position {
+  @JsonProperty("x")
+  float x;
+  @JsonProperty("y")
+  float y;
+}
diff --git a/demo/src/main/java/com/instagram/common/json/app/ommodel/OmModelWorker.java b/demo/src/main/java/com/instagram/common/json/app/ommodel/OmModelWorker.java
new file mode 100644
index 0000000..af69a32
--- /dev/null
+++ b/demo/src/main/java/com/instagram/common/json/app/ommodel/OmModelWorker.java
@@ -0,0 +1,22 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.app.ommodel;
+
+import java.io.IOException;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+/**
+ * Helper class to parse the model.
+ */
+public class OmModelWorker {
+  private static final ObjectMapper sObjectMapper = new ObjectMapper();
+
+  public OmModelRequest parseFromString(String input) throws IOException {
+    return sObjectMapper.readValue(input, OmModelRequest.class);
+  }
+
+  public OmListOfModels parseListFromString(String input) throws IOException {
+    return sObjectMapper.readValue(input, OmListOfModels.class);
+  }
+}
diff --git a/demo/src/main/res/layout/activity.xml b/demo/src/main/res/layout/activity.xml
new file mode 100644
index 0000000..44c169e
--- /dev/null
+++ b/demo/src/main/res/layout/activity.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/main"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    >
+  <LinearLayout
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      >
+    <TextView
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="Iterations:"
+        />
+    <EditText
+        android:id="@+id/iterations"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:text="1"
+        android:hint="Iterations"
+        android:inputType="numberDecimal"
+        />
+  </LinearLayout>
+  <LinearLayout
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      >
+    <Button
+        android:id="@+id/ig_parse_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="IG Parse"
+        />
+    <Button
+        android:id="@+id/om_parse_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="ObjectMapper Parse"
+        />
+    <Button
+        android:id="@+id/quit"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="Quit"
+        />
+  </LinearLayout>
+  <TextView
+      android:id="@+id/results"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      />
+</LinearLayout>
diff --git a/demo/src/main/res/raw/input.base64 b/demo/src/main/res/raw/input.base64
new file mode 100644
index 0000000..69ad64a
--- /dev/null
+++ b/demo/src/main/res/raw/input.base64
@@ -0,0 +1 @@
+eyJtZXRhIjp7ImNvZGUiOjIwMH0sImRhdGEiOlt7ImF0dHJpYnV0aW9uIjpudWxsLCJ0YWdzIjpbInVuaGNyIiwibmF0aW9uYWxnZW9ncmFwaGljIiwidHVya2FuYSIsInJlZnVnZWUiLCJhZnJpY2EiLCJjdWx0dXJlIiwia2FrdW1hIiwia2VueWEiLCJsYXRlcmdyYW0iXSwidHlwZSI6ImltYWdlIiwibG9jYXRpb24iOm51bGwsImNvbW1lbnRzIjp7ImNvdW50IjoyMSwiZGF0YSI6W3siY3JlYXRlZF90aW1lIjoiMTQwMDAyMTkwMCIsInRleHQiOiJAYXlzZWNldmlrIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImNhZ2lsY2VsaWtzYW4iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zMzI4MjE5Nl83NXNxXzEzNzQxOTkxMTUuanBnIiwiaWQiOiIzMzI4MjE5NiIsImZ1bGxfbmFtZSI6IsOHYcSfxLFsIMOHZWxpa8WfYW4ifSwiaWQiOiI3MTk3NTgzMjgwODQ5MTIxMjcifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE5MDEiLCJ0ZXh0IjoiV293ISBGaXJzdCBsaWtlIG9uIGEgI25hdGdlbyA/ISIsImZyb20iOnsidXNlcm5hbWUiOiJzamNlcnVsbG8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xOTQxMDc1MTdfNzVzcV8xMzQ0NDk5Mzk2LmpwZyIsImlkIjoiMTk0MTA3NTE3IiwiZnVsbF9uYW1lIjoiU2FyYWggQ2VydWxsbyJ9LCJpZCI6IjcxOTc1ODMzNTc4NTY1MzI0OCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTkwNSIsInRleHQiOiJOaWNlIDopIiwiZnJvbSI6eyJ1c2VybmFtZSI6Imhhc2Fuc3luIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNjU1MTI1NTIzXzc1c3FfMTM5MTYwNjkwOC5qcGciLCJpZCI6IjY1NTEyNTUyMyIsImZ1bGxfbmFtZSI6Ikhhc2FuIFNhecSxbiJ9LCJpZCI6IjcxOTc1ODM2NjE5NDM1NzI1MCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTkxMyIsInRleHQiOiJJJ20gcXVpY2siLCJmcm9tIjp7InVzZXJuYW1lIjoiZGVuenlfMzUiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV82NTYwMTM5NTBfNzVzcV8xMzk3NzA0NDQxLmpwZyIsImlkIjoiNjU2MDEzOTUwIiwiZnVsbF9uYW1lIjoiZGVudHplbCBhZG9scGhlIn0sImlkIjoiNzE5NzU4NDM4NjM4Mzc1OTQ2In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxOTE1IiwidGV4dCI6IkBrdm9sa21hbiIsImZyb20iOnsidXNlcm5hbWUiOiJpYW1hbGV4YW5kcm9sYXRvcnJlIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTg2NjkxOTJfNzVzcV8xMzk4NzE3MDI2LmpwZyIsImlkIjoiMTg2NjkxOTIiLCJmdWxsX25hbWUiOiJpYW1hbGV4YW5kcm9sYXRvcnJlIn0sImlkIjoiNzE5NzU4NDQ5NDUxMjkxNjYwIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxOTE1IiwidGV4dCI6IkBzdGV2aWVfYjg4IGR1ZGUgd2l0aCB0aGUgUGlnZW9uIGxvb2sgbGlrZSB5b3UgT19vIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImZyZW5jaF9ldXJvczg1IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzEzOTgyMzVfNzVzcV8xMzk5NTgzNjY1LmpwZyIsImlkIjoiMzEzOTgyMzUiLCJmdWxsX25hbWUiOiJGcmFuY29pcyBMYXJtb255In0sImlkIjoiNzE5NzU4NDU1MDgwMDQ3NjMwIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxOTE3IiwidGV4dCI6IkBjeXJ1czcxMiB5b3UncmUgbG9va2luIGdvb2QgaW4gdGhpcyBwaWMgYnJvIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImFoMTA4MiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzIzNDY4NjczXzc1c3FfMTM0NjUwNjg2MC5qcGciLCJpZCI6IjIzNDY4NjczIiwiZnVsbF9uYW1lIjoiYWgxMDgyIn0sImlkIjoiNzE5NzU4NDY3NDAyOTEyNzgzIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxOTIyIiwidGV4dCI6Ikxvb2sgc3R1bm5pbmchISIsImZyb20iOnsidXNlcm5hbWUiOiJpdHN2aXRyYXJpbmFsZGkiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zNDk4MDg4NDhfNzVzcV8xMzk5NjYyMzg3LmpwZyIsImlkIjoiMzQ5ODA4ODQ4IiwiZnVsbF9uYW1lIjoiVml0cmEgUmluYWxkaSBIYWppIFN5YWZyaW5hbCJ9LCJpZCI6IjcxOTc1ODUwNzc2ODg5NDQ4MyJ9XX0sImZpbHRlciI6Ik5vcm1hbCIsImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE4MTciLCJsaW5rIjoiaHR0cDovL2luc3RhZ3JhbS5jb20vcC9uOUY3X3RJVmRELyIsImxpa2VzIjp7ImNvdW50IjoyMTc4LCJkYXRhIjpbeyJ1c2VybmFtZSI6InlvX21pa2VlZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzE3MTM0NjY1Xzc1c3FfMTM4NDkwMDEyNC5qcGciLCJpZCI6IjE3MTM0NjY1IiwiZnVsbF9uYW1lIjoiTWljLUVsIEFsbGkifSx7InVzZXJuYW1lIjoiZW1pbWFydGluZXoxMjMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV82MTAxMzg3MTFfNzVzcV8xMzk3Njg0NDE2LmpwZyIsImlkIjoiNjEwMTM4NzExIiwiZnVsbF9uYW1lIjoiRW1pbGlhbm8gTWFydGluZXoifSx7InVzZXJuYW1lIjoibWV3bHV0XzE5MDMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV82NDkxNzIwMzVfNzVzcV8xMzkzMDA5Nzg4LmpwZyIsImlkIjoiNjQ5MTcyMDM1IiwiZnVsbF9uYW1lIjoiTWV3bHV0XzE5MDMifSx7InVzZXJuYW1lIjoibnlyYWJhcnJldG8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV80MTcxMTI4NTVfNzVzcV8xMzk5ODk3NDUxLmpwZyIsImlkIjoiNDE3MTEyODU1IiwiZnVsbF9uYW1lIjoiTnlyYSBCYXJyZXRvIn1dfSwiaW1hZ2VzIjp7Imxvd19yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1mcmMuZmJjZG4ubmV0LzEwMzU4NDAxXzE0ODk5NjkyMzEyMTgzMjNfMTc4MjI5OTIyX2EuanBnIiwid2lkdGgiOjMwNiwiaGVpZ2h0IjozMDZ9LCJ0aHVtYm5haWwiOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLWZyYy5mYmNkbi5uZXQvMTAzNTg0MDFfMTQ4OTk2OTIzMTIxODMyM18xNzgyMjk5MjJfcy5qcGciLCJ3aWR0aCI6MTUwLCJoZWlnaHQiOjE1MH0sInN0YW5kYXJkX3Jlc29sdXRpb24iOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLWZyYy5mYmNkbi5uZXQvMTAzNTg0MDFfMTQ4OTk2OTIzMTIxODMyM18xNzgyMjk5MjJfbi5qcGciLCJ3aWR0aCI6NjQwLCJoZWlnaHQiOjY0MH19LCJ1c2Vyc19pbl9waG90byI6W10sImNhcHRpb24iOnsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTgxNyIsInRleHQiOiJQaG90bzogQHJhbmR5b2xzb24gfCBNYWluIHN0cmVldCBvZiB0aGUgS2FrdW1hIHJlZnVnZWUgY2FtcC4gVGhpcyBjYW1wIGN1cnJlbnRseSBzZXJ2ZXMgb3ZlciAxMzgsMDAwIG1lbiwgd29tZW4gYW5kIGNoaWxkcmVuIHdobyBoYXZlIGZsZWQgd2FycyBhbmQgdmlvbGVuY2UgaW4gbmVpZ2hib3JpbmcgY291bnRyaWVzLiBXcml0ZXIgQG5laWxzaGVhMTMgYW5kIG15c2VsZiBhcmUgY3VycmVudGx5IG9uIGFzc2lnbm1lbnQgZm9yIEBuYXRnZW8gaW4gdGhlIExha2UgVHVya2FuYSByZWdpb24gb2YgS2VueWEuIEB0aGVwaG90b3NvY2lldHkgQGdlbmV0aWNpc2xhbmRzICNuYXRpb25hbGdlb2dyYXBoaWMgI2FmcmljYSAja2VueWEgI3R1cmthbmEgI1VOSENSICNrYWt1bWEgI2N1bHR1cmUgI3JlZnVnZWUgI2xhdGVyZ3JhbSIsImZyb20iOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV83ODcxMzJfNzVzcV8xMzYzMDUzNDk4LmpwZyIsImlkIjoiNzg3MTMyIiwiZnVsbF9uYW1lIjoiTmF0aW9uYWwgR2VvZ3JhcGhpYyJ9LCJpZCI6IjcxOTc1NzYyODgzNTcxNTAwNSJ9LCJ1c2VyX2hhc19saWtlZCI6ZmFsc2UsImlkIjoiNzE5NzU3NjI4NTMzNzI0OTk1Xzc4NzEzMiIsInVzZXIiOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJ3ZWJzaXRlIjoiIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNzg3MTMyXzc1c3FfMTM2MzA1MzQ5OC5qcGciLCJmdWxsX25hbWUiOiJOYXRpb25hbCBHZW9ncmFwaGljIiwiYmlvIjoiIiwiaWQiOiI3ODcxMzIifX0seyJhdHRyaWJ1dGlvbiI6bnVsbCwidGFncyI6W10sInR5cGUiOiJpbWFnZSIsImxvY2F0aW9uIjpudWxsLCJjb21tZW50cyI6eyJjb3VudCI6NDQ1LCJkYXRhIjpbeyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxODg5IiwidGV4dCI6IkB0cmVlaG91c2VvaG0g4p2k77iPIDopIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImphbmlyaXNjIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNTExNzk4ODI2Xzc1c3FfMTM3Njk1MTIyMi5qcGciLCJpZCI6IjUxMTc5ODgyNiIsImZ1bGxfbmFtZSI6IkphbmlyaXMgQ2FyYWJhbGxvIn0sImlkIjoiNzE5NzU4MjM2ODkxMzY0MzY2In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxODkyIiwidGV4dCI6IldoYXQgYSBiZXV0eSIsImZyb20iOnsidXNlcm5hbWUiOiJzcXVpc2hpMjMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xMTc2MjI3NzU5Xzc1c3FfMTM5OTc2NTEyMy5qcGciLCJpZCI6IjExNzYyMjc3NTkiLCJmdWxsX25hbWUiOiJWYWxlcmlhIFZlcmdhcmEifSwiaWQiOiI3MTk3NTgyNjIyNTAxMjYzNTEifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE4OTQiLCJ0ZXh0IjoiRXhhY3RseSEhISBAc2FtYW50aGF0c2lhZ2FsaXMiLCJmcm9tIjp7InVzZXJuYW1lIjoibGVvX21heHgiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV80NTYzNzQyMV83NXNxXzEzOTg4NzkzMTkuanBnIiwiaWQiOiI0NTYzNzQyMSIsImZ1bGxfbmFtZSI6Imxlb19tYXh4In0sImlkIjoiNzE5NzU4MjgwNjcxNTA5NTIyIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxOTAwIiwidGV4dCI6Ik8uTS5HISIsImZyb20iOnsidXNlcm5hbWUiOiJzcXVpc2hpMjMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xMTc2MjI3NzU5Xzc1c3FfMTM5OTc2NTEyMy5qcGciLCJpZCI6IjExNzYyMjc3NTkiLCJmdWxsX25hbWUiOiJWYWxlcmlhIFZlcmdhcmEifSwiaWQiOiI3MTk3NTgzMjY0NjQ5MjA1OTYifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE5MDMiLCJ0ZXh0IjoiQGFydGh1cm1hY2hhZG9vIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImFsZXJhY2hhdXMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV80MjE1MzkyNzJfNzVzcV8xMzk5MDQ4ODkzLmpwZyIsImlkIjoiNDIxNTM5MjcyIiwiZnVsbF9uYW1lIjoiQWxlc3NhbmRybyBSYWNoYXVzIn0sImlkIjoiNzE5NzU4MzQ5Nzg1MjUwODM3In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxOTEwIiwidGV4dCI6IkBtaWxlcm9zczIxIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImNoZWxldmV0MjciLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV80MDA3MjM1OTlfNzVzcV8xMzk2OTAxNTEzLmpwZyIsImlkIjoiNDAwNzIzNTk5IiwiZnVsbF9uYW1lIjoiQW5kcsOpcyBWaWFuYSJ9LCJpZCI6IjcxOTc1ODQwNjU4NDUxNTYwNyJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTkxMCIsInRleHQiOiLwn5Ka8J+SnPCfkpnwn5Kb8J+SlyIsImZyb20iOnsidXNlcm5hbWUiOiJuanZiZWZzZ21haWxjb20iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV81NDU5NjAyODVfNzVzcV8xMzk5NzMwNjk4LmpwZyIsImlkIjoiNTQ1OTYwMjg1IiwiZnVsbF9uYW1lIjoiTnV0dGhhcGF0IEplYW1hbW9ybnJhdCJ9LCJpZCI6IjcxOTc1ODQwOTg4MTIzODU1MiJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTkxMCIsInRleHQiOiLwn5iN8J+YjfCfmI3wn5iN8J+YjfCfmI0iLCJmcm9tIjp7InVzZXJuYW1lIjoiYnJlbl9fZHVoaGgxMCIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI3NTg5NzU5Xzc1c3FfMTM5NjI4MDEzNi5qcGciLCJpZCI6IjI3NTg5NzU5IiwiZnVsbF9uYW1lIjoiQnJlbmRhIDEwIn0sImlkIjoiNzE5NzU4NDEyNTA2ODcyODU3In1dfSwiZmlsdGVyIjoiTm9ybWFsIiwiY3JlYXRlZF90aW1lIjoiMTQwMDAyMDQ2MiIsImxpbmsiOiJodHRwOi8vaW5zdGFncmFtLmNvbS9wL245RFdwbmtqMVUvIiwibGlrZXMiOnsiY291bnQiOjI0ODc1LCJkYXRhIjpbeyJ1c2VybmFtZSI6ImFkYmxlaHMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yMzk4NTQzXzc1c3FfMTM5ODUyNDM5NC5qcGciLCJpZCI6IjIzOTg1NDMiLCJmdWxsX25hbWUiOiJBIE0gQSBOIEQgQSDwn4y5In0seyJ1c2VybmFtZSI6ImxheWxhX21pbGFuaTcxOTAwIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNjE4MjIwMjQyXzc1c3FfMTM5NzA4OTMzMS5qcGciLCJpZCI6IjYxODIyMDI0MiIsImZ1bGxfbmFtZSI6IsqfYcqPyp9hIM+7xLHKn2HJtMmq8J+SriJ9LHsidXNlcm5hbWUiOiJiYXlrYW5wYW1pciIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI0MzM1Nzc3MV83NXNxXzEzOTY3ODUwMDAuanBnIiwiaWQiOiIyNDMzNTc3NzEiLCJmdWxsX25hbWUiOiJCYXlrYW4gUGFtaXIifSx7InVzZXJuYW1lIjoiajJ0aGVtb250ZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzE5MTg2NDExXzc1c3FfMTM5MDQ1MTgwNS5qcGciLCJpZCI6IjE5MTg2NDExIiwiZnVsbF9uYW1lIjoiajJ0aGVtb250ZSJ9XX0sImltYWdlcyI6eyJsb3dfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtYXNoLmZiY2RuLm5ldC85Mjc2NDhfMTQyNDQ2MTc3NDQ4MDkxMV8yMDAzMDg2NDEwX2EuanBnIiwid2lkdGgiOjMwNiwiaGVpZ2h0IjozMDZ9LCJ0aHVtYm5haWwiOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLWFzaC5mYmNkbi5uZXQvOTI3NjQ4XzE0MjQ0NjE3NzQ0ODA5MTFfMjAwMzA4NjQxMF9zLmpwZyIsIndpZHRoIjoxNTAsImhlaWdodCI6MTUwfSwic3RhbmRhcmRfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtYXNoLmZiY2RuLm5ldC85Mjc2NDhfMTQyNDQ2MTc3NDQ4MDkxMV8yMDAzMDg2NDEwX24uanBnIiwid2lkdGgiOjY0MCwiaGVpZ2h0Ijo2NDB9fSwidXNlcnNfaW5fcGhvdG8iOltdLCJjYXB0aW9uIjp7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjA0NjIiLCJ0ZXh0IjoiRmluZCBNZSB8IFBob3RvZ3Jhb2h5IGJ5IMKpTWF4IFJpbmFsZGkgdmlhIG1heHJpbmFsZGlwaG90b2dyYXBoeS5jb20gQGFuaW1hbHMiLCJmcm9tIjp7InVzZXJuYW1lIjoibmF0dXJlIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjY2NjE2Nl83NXNxXzEzODAxNzA2NzEuanBnIiwiaWQiOiIyNjY2MTY2IiwiZnVsbF9uYW1lIjoibmF0dXJlIn0sImlkIjoiNzE5NzQ2MjY2NDIzMjQ1ODI2In0sInVzZXJfaGFzX2xpa2VkIjp0cnVlLCJpZCI6IjcxOTc0NjI2NjEwNDQ3OTA2MF8yNjY2MTY2IiwidXNlciI6eyJ1c2VybmFtZSI6Im5hdHVyZSIsIndlYnNpdGUiOiIiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yNjY2MTY2Xzc1c3FfMTM4MDE3MDY3MS5qcGciLCJmdWxsX25hbWUiOiJuYXR1cmUiLCJiaW8iOiIiLCJpZCI6IjI2NjYxNjYifX0seyJhdHRyaWJ1dGlvbiI6bnVsbCwidGFncyI6W10sInR5cGUiOiJpbWFnZSIsImxvY2F0aW9uIjp7ImxhdGl0dWRlIjozOS44NzE2MTM3OTcsImxvbmdpdHVkZSI6LTEwNC42ODE0NjU0NTF9LCJjb21tZW50cyI6eyJjb3VudCI6NDU2LCJkYXRhIjpbeyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxODAzIiwidGV4dCI6IkBzbW9raW5naW50aGVib3lzcm9vbSBsb29rLCB0aGVyZSBhcmUgbW9yZSBkaW5vc2F1cnMgb3V0IHRoZXJlIGxpa2UgeW91IGFuZCAjWU9VUk1PTSIsImZyb20iOnsidXNlcm5hbWUiOiJzaW9iaGFuX2JlZWIiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yMjE4MzE0MF83NXNxXzEzOTIxODUyMzEuanBnIiwiaWQiOiIyMjE4MzE0MCIsImZ1bGxfbmFtZSI6IlNpb2Jow6FuIEJyYWRsZXkifSwiaWQiOiI3MTk3NTc1MTY2MjEzMDU3ODIifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE4MTMiLCJ0ZXh0IjoiQGF1c3RpbmRodXNzIHlvdXIgbm90IGFsbG93ZWQgdG8gdm9pY2Ugd2hhdCB5b3UgYmVsaWV2ZSBpZiBpdCBpc24ndCB0aGUgc2FtZSB0aGluZyBJIGJlbGlldmUhIE5vIGZyZWVkb20gb2Ygc3BlZWNoISBXaGF0IHlvdSB0aGluayB0aGlzIGlzPyEgT2xkIEFtZXJpY2E/ISBZb3UncmUgcHJvYmFibHkgYSByYWNpc3QgYW5kIGEgaG9tb3Bob2JlIHRvbyBodWg/IEtlZXAgeW91ciBvcGluaW9uIHRvIHlvdXJzZWxmLCB0aGF0J3MgdGhlIE5ldyBBbWVyaWNhIG5vdy4iLCJmcm9tIjp7InVzZXJuYW1lIjoiZ2FtamFtMzgiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yMjcwNjY0MTNfNzVzcV8xMzc2NjA1NjM0LmpwZyIsImlkIjoiMjI3MDY2NDEzIiwiZnVsbF9uYW1lIjoiQmxha2UgR2FtbWVsIn0sImlkIjoiNzE5NzU3NTk1MTgwNjE5NzA3In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxODU3IiwidGV4dCI6IkBzb2Z3YW5yZWR6dWFuIEBsb3ZlY2hhbnRlbGxlXzMzICEhISEiLCJmcm9tIjp7InVzZXJuYW1lIjoibWFyaWF6dXJhIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfOTUyMzU4NF83NXNxXzEzOTkyMjY5NDIuanBnIiwiaWQiOiI5NTIzNTg0IiwiZnVsbF9uYW1lIjoiTW9uaWNhIFZpdGEgU3V3aXRvIn0sImlkIjoiNzE5NzU3OTY0MzA0NTM3NTYwIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxODU4IiwidGV4dCI6IkBtYWNreXBhZGlsbGFsaXphcmRvIHllcy4gSW4gZmFjdCB3aXRoIHJlbGlnaW9uIGFzIGEgd2hvbGUuIEJ1dCBrZWVwIHN0YXlpbmcgYnJhaW53YXNoZWQgYW5kIGRvIHlvdXIgbWFzdGVycyBiaWRkaW5nLiBTdGF5IFwiZnJlZVwiLiIsImZyb20iOnsidXNlcm5hbWUiOiJzaGVybWxvY2tqb25lcyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzIwNDQyNTMzNl83NXNxXzEzOTcyOTAzMjMuanBnIiwiaWQiOiIyMDQ0MjUzMzYiLCJmdWxsX25hbWUiOiJDcmF3cyJ9LCJpZCI6IjcxOTc1Nzk3NTQxMTA1NDU1NCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTg3NyIsInRleHQiOiJAbm92b2NhaW5lZHJlYW1zIiwiZnJvbSI6eyJ1c2VybmFtZSI6Im5hbGFyb2NpbyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI5NDEyNTIxM183NXNxXzEzOTg5ODkyMTYuanBnIiwiaWQiOiIyOTQxMjUyMTMiLCJmdWxsX25hbWUiOiJNIGkgYyBrIGUgeSBSIG8gcyBlIPCfjLkifSwiaWQiOiI3MTk3NTgxMzExNDU1NjIwODgifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE4OTYiLCJ0ZXh0IjoiQHNhcmFocDMwMDUiLCJmcm9tIjp7InVzZXJuYW1lIjoic2t5ZXJvb3N0ZXIiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV85NDI0MDQ0MzNfNzVzcV8xMzg5MDk3NjIzLmpwZyIsImlkIjoiOTQyNDA0NDMzIiwiZnVsbF9uYW1lIjoiQnJ1Y2UgRWxsaXMifSwiaWQiOiI3MTk3NTgyOTMzMjI1MjA1NzIifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE4OTYiLCJ0ZXh0IjoiTXkgbGlmZSBoYXMgYmVlbiBiZXR0ZXIgc2luY2UgSSd2ZSBiZWxpZXZlZCBpbiBHb2QsIG5vIHdheSB0byBleHBsYWluIGhvdyBtdWNoIG9mIGEgY29tcGxldGUgdHVybiBteSBsaWZlIGhhcyBtYWRlIGZvciB0aGUgYmV0dGVyLiBAc2hlcm1sb2Nram9uZXMiLCJmcm9tIjp7InVzZXJuYW1lIjoiYXVzdGluZGh1c3MiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zMDc2NTEzNjdfNzVzcV8xMzY5NjIzODQ0LmpwZyIsImlkIjoiMzA3NjUxMzY3IiwiZnVsbF9uYW1lIjoiQXVzdGluIEh1c3MifSwiaWQiOiI3MTk3NTgyOTY5NTQ3ODc4MzcifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE5MTMiLCJ0ZXh0IjoiQGp1c3RfamFja19vaCBAY2hlbGxiZWxsYmVycnkiLCJmcm9tIjp7InVzZXJuYW1lIjoicGluYXljaGlja3kiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV80MjIzNzYyMF83NXNxXzEzOTcwMTg1NzcuanBnIiwiaWQiOiI0MjIzNzYyMCIsImZ1bGxfbmFtZSI6IlNhcmFoIEphbmUifSwiaWQiOiI3MTk3NTg0MzU0MzM5Mjc2ODkifV19LCJmaWx0ZXIiOiJOb3JtYWwiLCJjcmVhdGVkX3RpbWUiOiIxNDAwMDE4OTI3IiwibGluayI6Imh0dHA6Ly9pbnN0YWdyYW0uY29tL3AvbjlBYk9Qb1ZWMC8iLCJsaWtlcyI6eyJjb3VudCI6NDA0MjIsImRhdGEiOlt7InVzZXJuYW1lIjoibWFya3RoZWJlYXJkIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjk5Njg4NjI1Xzc1c3FfMTM5NDE2MzYyNi5qcGciLCJpZCI6IjI5OTY4ODYyNSIsImZ1bGxfbmFtZSI6Ik1hcmsifSx7InVzZXJuYW1lIjoiamFkZV9zb21lcnMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xOTUyNjM5NzJfNzVzcV8xMzU0MTU1ODg1LmpwZyIsImlkIjoiMTk1MjYzOTcyIiwiZnVsbF9uYW1lIjoiSmFkZSBTb21lcnMifSx7InVzZXJuYW1lIjoic25laGhrIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjAyNzE4MTgxXzc1c3FfMTM5ODExODgyNi5qcGciLCJpZCI6IjIwMjcxODE4MSIsImZ1bGxfbmFtZSI6IlNuZWhhIEthbWF0LCBCb21iYXktTG9uZG9uLiJ9LHsidXNlcm5hbWUiOiJjaGF5emlmaWNhdGlvbiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzQ3NzA5NDA2Xzc1c3FfMTM2NDk2NTUyMi5qcGciLCJpZCI6IjQ3NzA5NDA2IiwiZnVsbF9uYW1lIjoi4oKpwqXCo+KCrCTilrbimaNXSkPimafil4Ak4oKswqPCpeKCqSJ9XX0sImltYWdlcyI6eyJsb3dfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtYXNoLmZiY2RuLm5ldC8xMDM0OTYwMV81MjE0MDE4NjEzMTg4ODlfMTE5OTk1MDg5NF9hLmpwZyIsIndpZHRoIjozMDYsImhlaWdodCI6MzA2fSwidGh1bWJuYWlsIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1hc2guZmJjZG4ubmV0LzEwMzQ5NjAxXzUyMTQwMTg2MTMxODg4OV8xMTk5OTUwODk0X3MuanBnIiwid2lkdGgiOjE1MCwiaGVpZ2h0IjoxNTB9LCJzdGFuZGFyZF9yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1hc2guZmJjZG4ubmV0LzEwMzQ5NjAxXzUyMTQwMTg2MTMxODg4OV8xMTk5OTUwODk0X24uanBnIiwid2lkdGgiOjY0MCwiaGVpZ2h0Ijo2NDB9fSwidXNlcnNfaW5fcGhvdG8iOltdLCJjYXB0aW9uIjp7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTg5MjciLCJ0ZXh0IjoiUGhvdG8gQGNvcnlyaWNoYXJkcyBBIExhdGUgQ3JldGFjZW91cyAoMTAwLjUgdG8gNjYgbWlsbGlvbiB5ZWFycyBhZ28pIGFydGljdWxhdGVkIHNlY3Rpb24gb2YgSGFkcm9zYXVyIHRhaWwgbGF5cyBpbi1zaXR1IGluIHRoZSBtdWRzdG9uZSBvZiB0aGUgS2FpcGFyb3dpdHMgZm9ybWF0aW9uIG9mIFNvdXRoZXJuIFV0YWguICBIYWRyb3NhdXJzIHdlcmUgc28gY29tbW9uIGluIHRoaXMgYXJlYSB0aGF0IHRoZSBwYWxlb250b2xvZ2lzdHMgY2hvc2Ugbm90IHRvIHJlbW92ZSB2ZXJ0ZWJyYWUuIEV4Y2l0aW5nIG5ldyBwYWxlb250b2xvZ3kgaXMgYmVpbmcgZG9uZSBldmVyeSBzZWFzb24gaW4gdGhlIHJlbW90ZSBkaW5vc2F1ci1yaWNoIEVzY2FsYW50ZSBHcmFuZCBTdGFpcmNhc2UgTmF0aW9uYWwgTW9udW1lbnQsIHB1bGxpbmcgc3BlY2llcyBuZXcgdG8gc2NpZW5jZSBmcm9tIHRoZSBiYWRsYW5kcyBzbyBmcmVxdWVudGx5IGl0IHNlZW1zIHRoYXQgTGFyYW1pZGlhLCB0aGUgbGFuZG1hc3MgdGhhdCBleGlzdGVkIGR1cmluZyB0aGUgbGF0ZSBDcmV0YWNlb3VzLCB3YXMgYSB2ZXJpdGFibGUgZGlub3NhdXIgZmFjdG9yeS4gIFRoZSBhcnRpY2xlIHByb2ZpbGluZyB0aGUgZXhoYXVzdGl2ZSB3b3JrIGJlaW5nIGRvbmUgaXMgaW4gdGhlIE1heSDigJkxNCBAbmF0Z2VvLiBAbmF0Z2VvY3JlYXRpdmUgQDNzdHJpbmdzcHJvZHVjdGlvbnMgQG1hcmtzdG9uZXBob3RvIEBhbmR5X21hbm4gQHRoZW5vcnRoZmFjZSIsImZyb20iOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV83ODcxMzJfNzVzcV8xMzYzMDUzNDk4LmpwZyIsImlkIjoiNzg3MTMyIiwiZnVsbF9uYW1lIjoiTmF0aW9uYWwgR2VvZ3JhcGhpYyJ9LCJpZCI6IjcxOTczMzM4NjU0NzEyMzIzOCJ9LCJ1c2VyX2hhc19saWtlZCI6ZmFsc2UsImlkIjoiNzE5NzMzMzg2MTY5NjM2MjEyXzc4NzEzMiIsInVzZXIiOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJ3ZWJzaXRlIjoiIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNzg3MTMyXzc1c3FfMTM2MzA1MzQ5OC5qcGciLCJmdWxsX25hbWUiOiJOYXRpb25hbCBHZW9ncmFwaGljIiwiYmlvIjoiIiwiaWQiOiI3ODcxMzIifX0seyJhdHRyaWJ1dGlvbiI6bnVsbCwidGFncyI6W10sInR5cGUiOiJpbWFnZSIsImxvY2F0aW9uIjpudWxsLCJjb21tZW50cyI6eyJjb3VudCI6NDQsImRhdGEiOlt7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTk3NjQiLCJ0ZXh0IjoiQGRhbmdyOCIsImZyb20iOnsidXNlcm5hbWUiOiJjb3J5X2hvcHBlIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjQ0NTM4NTkyXzc1c3FfMTM3MzgwODY0NS5qcGciLCJpZCI6IjI0NDUzODU5MiIsImZ1bGxfbmFtZSI6IkNvcnkgSG9wcGUifSwiaWQiOiI3MTk3NDA0MDQ4NTcyMzcyMjQifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTk4NjciLCJ0ZXh0IjoiQGJhbnlkYW5uIHRoZSBiZXN0IGdvdmVybm1lbnQgSW5zdGFncmFtIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImNvbGxlZW5nYXJyaXR5IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTE1MTI3NTNfNzVzcV8xMzc5ODMxNjE3LmpwZyIsImlkIjoiMTE1MTI3NTMiLCJmdWxsX25hbWUiOiJDb2xsZWVuIEdhcnJpdHkifSwiaWQiOiI3MTk3NDEyNzMyNjI3MTQ2MzAifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjAwMTAiLCJ0ZXh0IjoiVGhhbmtzIGZvciBuaWNlIGluZi4gVSBnaXZlIHVuZGVyIGVhY2ggcGlj8J+YiSIsImZyb20iOnsidXNlcm5hbWUiOiJjaG9vb29iaW4iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xMjI3MTAwMjA2Xzc1c3FfMTM5Njk1MzY5Mi5qcGciLCJpZCI6IjEyMjcxMDAyMDYiLCJmdWxsX25hbWUiOiJjeW50aGlhIn0sImlkIjoiNzE5NzQyNDY4NDI5NjM5NDg0In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIwMzMzIiwidGV4dCI6IkBicnJ4bm5hIHRob3VnaHQgdSB3b3VsZCBsaWtlIHRoaXMhISIsImZyb20iOnsidXNlcm5hbWUiOiJhYXllaXRzYXNobGV5IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTg0MjYzNTM0Xzc1c3FfMTM4OTE0NzUwNS5qcGciLCJpZCI6IjE4NDI2MzUzNCIsImZ1bGxfbmFtZSI6IkFzaGxleSBIYXRjaCJ9LCJpZCI6IjcxOTc0NTE4MzM2MDY3NTc4NSJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMDc0NyIsInRleHQiOiJAYXNobGV5cm9zZV9fX19fIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImplZmZyZXliNTE3IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNzg5NzY5MjQyXzc1c3FfMTM5MTYxNzc0Ny5qcGciLCJpZCI6Ijc4OTc2OTI0MiIsImZ1bGxfbmFtZSI6IkplZmYifSwiaWQiOiI3MTk3NDg2NTMxOTA5MzM1OTIifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjA3NjciLCJ0ZXh0IjoiQGdob2xsZXJzIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImRlbGFuZXlvdXJzbGVyIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjc0ODQzMDg3Xzc1c3FfMTM5MzY1MjE3Ni5qcGciLCJpZCI6IjI3NDg0MzA4NyIsImZ1bGxfbmFtZSI6IkRlbGFuZXkgT3Vyc2xlciJ9LCJpZCI6IjcxOTc0ODgyMTYwOTAxNjQxMiJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMDkwNyIsInRleHQiOiJAamFrZWphbXMiLCJmcm9tIjp7InVzZXJuYW1lIjoiYXJvb2Nhc3RybyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzU0NjU2NzIwNF83NXNxXzEzNzk4ODQ4ODcuanBnIiwiaWQiOiI1NDY1NjcyMDQiLCJmdWxsX25hbWUiOiJLaWVybmFuIn0sImlkIjoiNzE5NzQ5OTk1MjMzOTk1OTIzIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxMzIwIiwidGV4dCI6IlRoYXQncyBiZWF1dGlmdWwgQGNoZWZjbWlsbGVyIEBybW9udDcxMSBsb29rIGhvdyBjbGVhciB0aGUgc2t5IGlzIiwiZnJvbSI6eyJ1c2VybmFtZSI6Im1hcmlseW5tb250ZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzQwMDc1ODA2Xzc1c3FfMTMzNDMzMTQyNS5qcGciLCJpZCI6IjQwMDc1ODA2IiwiZnVsbF9uYW1lIjoibWFyaWx5bm1vbnRlIn0sImlkIjoiNzE5NzUzNDYwMTQ4NTMwNDk4In1dfSwiZmlsdGVyIjoiTm9ybWFsIiwiY3JlYXRlZF90aW1lIjoiMTQwMDAxNjQzOCIsImxpbmsiOiJodHRwOi8vaW5zdGFncmFtLmNvbS9wL244N3JkT0F1NHYvIiwibGlrZXMiOnsiY291bnQiOjU0MTEsImRhdGEiOlt7InVzZXJuYW1lIjoia2FheW9yaWNhcmRvIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNTM2MjUxNDA5Xzc1c3FfMTM4MDY4MDk0MC5qcGciLCJpZCI6IjUzNjI1MTQwOSIsImZ1bGxfbmFtZSI6IktheW8ifSx7InVzZXJuYW1lIjoiaXdvb2RwbGFuIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNDg5Nzk4NThfNzVzcV8xMzYyMzgzNzY2LmpwZyIsImlkIjoiNDg5Nzk4NTgiLCJmdWxsX25hbWUiOiJNaWNoYWVsIn0seyJ1c2VybmFtZSI6ImNwZXYxMyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzQ4NTU1OTc0MF83NXNxXzEzODcyMjQzMTQuanBnIiwiaWQiOiI0ODU1NTk3NDAiLCJmdWxsX25hbWUiOiJDaHJpcyBQZXZlcmFkYSJ9LHsidXNlcm5hbWUiOiJ2YW5pbGxhMDkyMTg3IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTc2OTY5NjdfNzVzcV8xMzkzNTgwOTc4LmpwZyIsImlkIjoiMTc2OTY5NjciLCJmdWxsX25hbWUiOiLimIDvuI/wn4y6QW5naWUgWi4gSm9uZXPwn4y64piA77iPIn1dfSwiaW1hZ2VzIjp7Imxvd19yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzEwMzU0NTQ3XzcyMzA2MzI2NDM4MzQ1Nl82ODc5OTA0MjNfYS5qcGciLCJ3aWR0aCI6MzA2LCJoZWlnaHQiOjMwNn0sInRodW1ibmFpbCI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtcHJuLmZiY2RuLm5ldC8xMDM1NDU0N183MjMwNjMyNjQzODM0NTZfNjg3OTkwNDIzX3MuanBnIiwid2lkdGgiOjE1MCwiaGVpZ2h0IjoxNTB9LCJzdGFuZGFyZF9yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzEwMzU0NTQ3XzcyMzA2MzI2NDM4MzQ1Nl82ODc5OTA0MjNfbi5qcGciLCJ3aWR0aCI6NjQwLCJoZWlnaHQiOjY0MH19LCJ1c2Vyc19pbl9waG90byI6W10sImNhcHRpb24iOnsiY3JlYXRlZF90aW1lIjoiMTQwMDAxNjQzOCIsInRleHQiOiJLZWxseXMgU2xvdWdoIE5XUiBpbiBOb3J0aCBEYWtvdGEgd2FzIGVzdGFibGlzaGVkIGluIDE5MzYgYXMgYSByZWZ1Z2UgYW5kIGJyZWVkaW5nIGdyb3VuZCBmb3IgbWlncmF0b3J5IGJpcmRzIGFuZCBvdGhlciB3aWxkbGlmZS4gVGhlIDEyNzAgYWNyZSByZWZ1Z2Ugc2VydmVzIGFzIGFuIGltcG9ydGFudCBtaWdyYXRpb24gY29ycmlkb3IgZm9yIHdhdGVyZm93bCBhbmQgc2hvcmViaXJkcy4gSW4gMjAwMywgdGhlIFdlc3Rlcm4gSGVtaXNwaGVyZSBTaG9yZWJpcmQgUmVzZXJ2ZSBOZXR3b3JrIGRlc2lnbmF0ZWQgdGhlIHJlZnVnZSBhcyBhIFJlZ2lvbmFsIFNob3JlYmlyZCBSZXNlcnZlLiBJdCdzIGFsc28gbm90IGEgYmFkIHBsYWNlIHRvIGNhdGNoIHRoZSBNaWxreSBXYXkgYWZ0ZXIgc3Vuc2V0LiBQaG90bzogSWFuIEphbWllc29uIiwiZnJvbSI6eyJ1c2VybmFtZSI6InVzaW50ZXJpb3IiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xNzQ0MzUxODZfNzVzcV8xMzQwMjg1MjkxLmpwZyIsImlkIjoiMTc0NDM1MTg2IiwiZnVsbF9uYW1lIjoiVS5TLiBEZXBhcnRtZW50IG9mIHRoZSBJbnRlcmlvciJ9LCJpZCI6IjcxOTcxMjUxMTg4ODM4NzIwNyJ9LCJ1c2VyX2hhc19saWtlZCI6ZmFsc2UsImlkIjoiNzE5NzEyNTExNTI3Njc3NDg3XzE3NDQzNTE4NiIsInVzZXIiOnsidXNlcm5hbWUiOiJ1c2ludGVyaW9yIiwid2Vic2l0ZSI6IiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzE3NDQzNTE4Nl83NXNxXzEzNDAyODUyOTEuanBnIiwiZnVsbF9uYW1lIjoiVS5TLiBEZXBhcnRtZW50IG9mIHRoZSBJbnRlcmlvciIsImJpbyI6IiIsImlkIjoiMTc0NDM1MTg2In19LHsiYXR0cmlidXRpb24iOm51bGwsInRhZ3MiOltdLCJ0eXBlIjoiaW1hZ2UiLCJsb2NhdGlvbiI6eyJsYXRpdHVkZSI6MzkuMDgxNiwibG9uZ2l0dWRlIjoxMjUuNzU3ODJ9LCJjb21tZW50cyI6eyJjb3VudCI6MjAsImRhdGEiOlt7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTgwNzkiLCJ0ZXh0IjoiQHRlYW1nYWwgZmFpcnMiLCJmcm9tIjp7InVzZXJuYW1lIjoiZ2VlaW5hcnNzb24iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zMTY2Mzk0MDlfNzVzcV8xMzcyNDgxMzgwLmpwZyIsImlkIjoiMzE2NjM5NDA5IiwiZnVsbF9uYW1lIjoiZ2VlaW5hcnNzb24ifSwiaWQiOiI3MTk3MjYyNzEzODY1NTM4MDQifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTgxMjUiLCJ0ZXh0IjoiQGhhbmFiYW5hbmE0ODYgQG1hbGxvcnltdW5vIG1hbnkgQ2hpbmEsIHNvbWUgb3RoZXIgQXNpYSwgYml0IG9mIEV1cm9wZS4iLCJmcm9tIjp7InVzZXJuYW1lIjoiZGd1dHRlbmZlbGRlciIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI5NDQwMTk0Xzc1c3FfMTM4NjY2ODYwOS5qcGciLCJpZCI6IjI5NDQwMTk0IiwiZnVsbF9uYW1lIjoiRGF2aWQgR3V0dGVuZmVsZGVyIn0sImlkIjoiNzE5NzI2NjU2MjQ3NTAwMjU2In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDE5MTU4IiwidGV4dCI6IkBmYXlyb296X2FidXlvdXNlZiAg15zXmSDXltei15zXkNeg15kg16fXpNeZ16jXldeWID8iLCJmcm9tIjp7InVzZXJuYW1lIjoidGltb3JhcmEiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zNjEyOTUxMTZfNzVzcV8xMzk5MDQ5NTMzLmpwZyIsImlkIjoiMzYxMjk1MTE2IiwiZnVsbF9uYW1lIjoi16rXmdee15XXqCDXoteo15DXmdeT15QifSwiaWQiOiI3MTk3MzUzMjQ2MDcxODg5NTQifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTkyNDAiLCJ0ZXh0IjoiV2hhdCB0eXBlIG9mIGN1cnJlbmN5IGFyZSB0aGV5IHVzaW5nPyIsImZyb20iOnsidXNlcm5hbWUiOiJzYXJhaGRlbHZlY2NoaW8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV81Mjk0NjMwNl83NXNxXzEzMzY0MDM0MzkuanBnIiwiaWQiOiI1Mjk0NjMwNiIsImZ1bGxfbmFtZSI6InNhcmFoZGVsdmVjY2hpbyJ9LCJpZCI6IjcxOTczNjAxNDc3MTUyMzU4MCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAxOTI0NiIsInRleHQiOiLXnteQINeQ15TXmdeZ15nXkdenIEB0aW1vcmFyYSIsImZyb20iOnsidXNlcm5hbWUiOiJmYXlyb296X2FidXlvdXNlZiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzUyNzc5NzI2OF83NXNxXzEzOTg5NDY2MzkuanBnIiwiaWQiOiI1Mjc3OTcyNjgiLCJmdWxsX25hbWUiOiLwn5KrINekINeZINeoINeVINeWICDXkCDXkSDXlSAtINeZINeVINehINej8J+SqyJ9LCJpZCI6IjcxOTczNjA2NDk3NzM0MTQ0MCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAxOTc1MCIsInRleHQiOiJAZGd1dHRlbmZlbGRlciB3aGF0IHlvdSdyZSBkb2luZyBpcyByZWFsbHkgaW5jcmVkaWJsZSwgYWRtaXJhYmxlLCBhbmQgYnJhdmUuIENoZWVycyB0byB5b3Ugc2lyLiIsImZyb20iOnsidXNlcm5hbWUiOiJyZGVsaXNsZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzM4NTU3MTU5Xzc1c3FfMTM2NTQ0MjYxNS5qcGciLCJpZCI6IjM4NTU3MTU5IiwiZnVsbF9uYW1lIjoicmRlbGlzbGUifSwiaWQiOiI3MTk3NDAyOTUyMjY1MjY5MzQifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTk3NzUiLCJ0ZXh0IjoidGhlIGZlYXIgaW4gdGhlIGV5ZXMuLiIsImZyb20iOnsidXNlcm5hbWUiOiJqdWxpb2liZWxsaSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzExMjU3NDQ2MDRfNzVzcV8xMzk0NjAwNjY2LmpwZyIsImlkIjoiMTEyNTc0NDYwNCIsImZ1bGxfbmFtZSI6Ikp1bGlvIEliZWxsaSJ9LCJpZCI6IjcxOTc0MDQ5NzY5Mzk2OTYzMSJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTE1MyIsInRleHQiOiJAamltb2xpdmVyNCBAanBheHdpY2siLCJmcm9tIjp7InVzZXJuYW1lIjoidmljZXJveWNlIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTkwNTI2MF83NXNxXzEzOTE5Njg1MDAuanBnIiwiaWQiOiIxOTA1MjYwIiwiZnVsbF9uYW1lIjoiUm95Y2UgQ2FpdGxpbiBBYnJhbXMifSwiaWQiOiI3MTk3NTIwNTc2MjM2MTMyNTkifV19LCJmaWx0ZXIiOiJOb3JtYWwiLCJjcmVhdGVkX3RpbWUiOiIxNDAwMDE2MzY4IiwibGluayI6Imh0dHA6Ly9pbnN0YWdyYW0uY29tL3Avbjg3aTBxZ3cxYS8iLCJsaWtlcyI6eyJjb3VudCI6MjQzNSwiZGF0YSI6W3sidXNlcm5hbWUiOiJndWllZnJhaW0iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV82MjQ0MjA0MDFfNzVzcV8xMzk4NTY4Nzg4LmpwZyIsImlkIjoiNjI0NDIwNDAxIiwiZnVsbF9uYW1lIjoiR3VpbGhlcm1lIEVmcmFpbSJ9LHsidXNlcm5hbWUiOiJtZWlyZW1hcm1vcml0eiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzYwNDExMTA5MF83NXNxXzEzODQ3NDUzODkuanBnIiwiaWQiOiI2MDQxMTEwOTAiLCJmdWxsX25hbWUiOiJNZWlyZW1hciBNb3JpdHoifSx7InVzZXJuYW1lIjoia2F0cXVpcmFsdGUiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yNDA0NjQ2ODNfNzVzcV8xMzk3MDY1NDkyLmpwZyIsImlkIjoiMjQwNDY0NjgzIiwiZnVsbF9uYW1lIjoiS2F0aHJ5biBRdWlyYWx0ZfCfkqsifSx7InVzZXJuYW1lIjoial9sX2xlYWwiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yMzA4NjkzMDZfNzVzcV8xMzkxNzMxMzQ0LmpwZyIsImlkIjoiMjMwODY5MzA2IiwiZnVsbF9uYW1lIjoiSm9zw6kgTHVpcyBMZWFsIEZvdG9ncmFmw61hLiJ9XX0sImltYWdlcyI6eyJsb3dfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtZnJjLmZiY2RuLm5ldC8xMDM2OTQ5NF84NTI0Mzc3MjgxMTg5MjFfODAxNjMwNTYwX2EuanBnIiwid2lkdGgiOjMwNiwiaGVpZ2h0IjozMDZ9LCJ0aHVtYm5haWwiOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLWZyYy5mYmNkbi5uZXQvMTAzNjk0OTRfODUyNDM3NzI4MTE4OTIxXzgwMTYzMDU2MF9zLmpwZyIsIndpZHRoIjoxNTAsImhlaWdodCI6MTUwfSwic3RhbmRhcmRfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtZnJjLmZiY2RuLm5ldC8xMDM2OTQ5NF84NTI0Mzc3MjgxMTg5MjFfODAxNjMwNTYwX24uanBnIiwid2lkdGgiOjY0MCwiaGVpZ2h0Ijo2NDB9fSwidXNlcnNfaW5fcGhvdG8iOltdLCJjYXB0aW9uIjp7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTYzNjgiLCJ0ZXh0IjoiTm9ydGggS29yZWFuIHdvbWVuIHNlbGwgc2hvZXMgZnJvbSBhIGJvb3RoIGF0IHRoZSBQeW9uZ3lhbmcgSW50ZXJuYXRpb25hbCBUcmFkZSBGYWlyLiIsImZyb20iOnsidXNlcm5hbWUiOiJkZ3V0dGVuZmVsZGVyIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjk0NDAxOTRfNzVzcV8xMzg2NjY4NjA5LmpwZyIsImlkIjoiMjk0NDAxOTQiLCJmdWxsX25hbWUiOiJEYXZpZCBHdXR0ZW5mZWxkZXIifSwiaWQiOiI3MTk3MTE5MTg0OTUwNDMzMDUifSwidXNlcl9oYXNfbGlrZWQiOmZhbHNlLCJpZCI6IjcxOTcxMTkxODIyNjYwNzQ1MF8yOTQ0MDE5NCIsInVzZXIiOnsidXNlcm5hbWUiOiJkZ3V0dGVuZmVsZGVyIiwid2Vic2l0ZSI6IiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI5NDQwMTk0Xzc1c3FfMTM4NjY2ODYwOS5qcGciLCJmdWxsX25hbWUiOiJEYXZpZCBHdXR0ZW5mZWxkZXIiLCJiaW8iOiIiLCJpZCI6IjI5NDQwMTk0In19LHsiYXR0cmlidXRpb24iOm51bGwsInRhZ3MiOlsic2tpaW5nIl0sInR5cGUiOiJpbWFnZSIsImxvY2F0aW9uIjpudWxsLCJjb21tZW50cyI6eyJjb3VudCI6MjUzLCJkYXRhIjpbeyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxMTM4IiwidGV4dCI6IlNvIG11Y2ggaGF0ZS4gV2hvIGNhcmVzIGFib3V0IGhpcyBvcmllbnRhdGlvbi4iLCJmcm9tIjp7InVzZXJuYW1lIjoibl93YXR0cyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzE4NDI1NzY3Nl83NXNxXzEzOTYxNTc5NTYuanBnIiwiaWQiOiIxODQyNTc2NzYiLCJmdWxsX25hbWUiOiJOYXRoYW4gV2F0dHMifSwiaWQiOiI3MTk3NTE5Mzc5ODcyNzAxNzIifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjEyNjAiLCJ0ZXh0IjoiQGZveHJpZGVyOTI4IiwiZnJvbSI6eyJ1c2VybmFtZSI6ImxlYWhtaW5hbXllciIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzE3NjEyNTk1MV83NXNxXzEzNjQ4MjgxNzMuanBnIiwiaWQiOiIxNzYxMjU5NTEiLCJmdWxsX25hbWUiOiJsZWFobWluYW15ZXIifSwiaWQiOiI3MTk3NTI5NTQyMzM1NzUwMTYifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjEzMzUiLCJ0ZXh0Ijoi7Iqk7YKk7YOA6rOgIOyLtuuLueOFiyIsImZyb20iOnsidXNlcm5hbWUiOiJsZWVtaW4wMzE3IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTI5MzkwNzc3MF83NXNxXzEzOTg2NjQxODUuanBnIiwiaWQiOiIxMjkzOTA3NzcwIiwiZnVsbF9uYW1lIjoibGVlbWluIn0sImlkIjoiNzE5NzUzNTg3Nzc0ODA1NjYwIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxNDgxIiwidGV4dCI6Itin2YjZhNmK2YYg2LPYp9mK2Kog2K7YqNix2Yog2YHYp9ix2LPZiiDYr9ixINin2YrZhtiz2KrYpyIsImZyb20iOnsidXNlcm5hbWUiOiI1NW9ubGluZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzExMTg2Nzg4NTFfNzVzcV8xMzkzMTc5MDkzLmpwZyIsImlkIjoiMTExODY3ODg1MSIsImZ1bGxfbmFtZSI6IjU1b25saW5lIn0sImlkIjoiNzE5NzU0ODExNjY0MzI0MzMxIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxNTgwIiwidGV4dCI6IkBsZWVraXJieTg3IiwiZnJvbSI6eyJ1c2VybmFtZSI6Iml0c2x1a2V5aiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzQzNjE2NjA4Xzc1c3FfMTM5NzAxMzU5MC5qcGciLCJpZCI6IjQzNjE2NjA4IiwiZnVsbF9uYW1lIjoiaXRzbHVrZXlqIn0sImlkIjoiNzE5NzU1NjQyNzgyNDM5MTk1In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxNTkzIiwidGV4dCI6IkBraG1vcmcgdGhpcyB3YXMgdXMgaW4gVXRhaCIsImZyb20iOnsidXNlcm5hbWUiOiJwZXRlZHVuYXkxNSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzUxMDk3MTAzMV83NXNxXzEzOTA4NzEyMjIuanBnIiwiaWQiOiI1MTA5NzEwMzEiLCJmdWxsX25hbWUiOiJQZXRlciBEdW5heSJ9LCJpZCI6IjcxOTc1NTc1MzkyMzEwNjU5NiJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTY0NSIsInRleHQiOiJAbWF0dHNvZ3JlZW5lIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImJlbnNpbnN0YWdyYW0iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xNzUyMzIyMzJfNzVzcV8xMzgxNTU1OTUzLmpwZyIsImlkIjoiMTc1MjMyMjMyIiwiZnVsbF9uYW1lIjoiYmVuIn0sImlkIjoiNzE5NzU2MTg2MjcxOTYyOTU2In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxNzYyIiwidGV4dCI6Ik5pY2UhISEhISEhISEiLCJmcm9tIjp7InVzZXJuYW1lIjoiYXJpem9uYTQ4NDgiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xMTkxMjE3NzI1Xzc1c3FfMTM5ODYyMzA3OS5qcGciLCJpZCI6IjExOTEyMTc3MjUiLCJmdWxsX25hbWUiOiJKYWNrc29uIEJlYXNsZXkgOCkifSwiaWQiOiI3MTk3NTcxNzA3ODQxNjM3MzkifV19LCJmaWx0ZXIiOiJOb3JtYWwiLCJjcmVhdGVkX3RpbWUiOiIxNDAwMDE0MDUxIiwibGluayI6Imh0dHA6Ly9pbnN0YWdyYW0uY29tL3AvbjgzSC1Kb1ZaTS8iLCJsaWtlcyI6eyJjb3VudCI6NTY0NDIsImRhdGEiOlt7InVzZXJuYW1lIjoic2xnZiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzEyNjE1NzkyXzc1c3FfMTMyMDU4NTEwOS5qcGciLCJpZCI6IjEyNjE1NzkyIiwiZnVsbF9uYW1lIjoic2xnZiJ9LHsidXNlcm5hbWUiOiJkdWRhemZ0IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTAzNzUwMzYxM183NXNxXzEzOTcwNzU3ODEuanBnIiwiaWQiOiIxMDM3NTAzNjEzIiwiZnVsbF9uYW1lIjoiTWFyaWEgRWR1YXJkYSBaYW5lbGxvIFRvcnJlcyJ9LHsidXNlcm5hbWUiOiJsZWVsb3phZGExIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzI3OTYwMzQyXzc1c3FfMTM2ODQ5ODY4MS5qcGciLCJpZCI6IjMyNzk2MDM0MiIsImZ1bGxfbmFtZSI6IkxlZSBNYW51ZWwgTG96YWRhIn0seyJ1c2VybmFtZSI6ImttaHVyZCIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzE2Nzg2ODkzXzc1c3FfMTM3NjQ4NDg3NS5qcGciLCJpZCI6IjE2Nzg2ODkzIiwiZnVsbF9uYW1lIjoia21odXJkIn1dfSwiaW1hZ2VzIjp7Imxvd19yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzEwMjk5NjQwXzY0OTM3NTIxMTgwMzg0MV8yMTAzMDUyNTcyX2EuanBnIiwid2lkdGgiOjMwNiwiaGVpZ2h0IjozMDZ9LCJ0aHVtYm5haWwiOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLXBybi5mYmNkbi5uZXQvMTAyOTk2NDBfNjQ5Mzc1MjExODAzODQxXzIxMDMwNTI1NzJfcy5qcGciLCJ3aWR0aCI6MTUwLCJoZWlnaHQiOjE1MH0sInN0YW5kYXJkX3Jlc29sdXRpb24iOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLXBybi5mYmNkbi5uZXQvMTAyOTk2NDBfNjQ5Mzc1MjExODAzODQxXzIxMDMwNTI1NzJfbi5qcGciLCJ3aWR0aCI6NjQwLCJoZWlnaHQiOjY0MH19LCJ1c2Vyc19pbl9waG90byI6W10sImNhcHRpb24iOnsiY3JlYXRlZF90aW1lIjoiMTQwMDAxNDA1MSIsInRleHQiOiJQaG90byBieSBAVGltTGFtYW4gb2YgQFJ1c3NMYW1hbiBibGFzdGluZyB0aHJvdWdoIHBvd2RlciBzbm93IGluIGEgZnVsbC1vbiBzbm93c3Rvcm0uICBTdXJwcmlzZSBzcHJpbmcgYmxpenphcmQgYXQgTWFtbW90aCBNb3VudGFpbiwgQ0Egb24gQXByaWwgMjUgZm91bmQgbXkgc29uIFJ1c3NlbGwgYW5kIG1lIGluIHRoZSByaWdodCBwbGFjZSBhdCB0aGUgcmlnaHQgdGltZSBmb3IgYW4gYXdlc29tZSBwb3dkZXIgc2tpaW5nIGRheSBhbmQgcGhvdG8gc2hvb3QuICBMb3ZlIGV4cGxvcmluZyB0aGUgb3V0ZG9vcnMgd2l0aCBteSBraWRzIGJldHdlZW4gZXhwZWRpdGlvbnMgZm9yIEBOYXRHZW8uICA2MCsgY20gb2Ygc25vdyByZWNvcmRlZCB0aGF0IGRheSAtIHF1aXRlIHRoZSBjb250cmFzdCB0byB0aGUgcmFpbiBmb3Jlc3RzIG9mIEluZG9uZXNpYSwgd2hpY2ggSSdtIGhlYWRlZCBiYWNrIHRvIHNvb24hICBAVGltTGFtYW4sICNza2lpbmcsIEB0aGVwaG90b3NvY2lldHksIEBuYXRnZW9jcmVhdGl2ZSwgQHBhdGFnb25pYS4iLCJmcm9tIjp7InVzZXJuYW1lIjoibmF0Z2VvIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNzg3MTMyXzc1c3FfMTM2MzA1MzQ5OC5qcGciLCJpZCI6Ijc4NzEzMiIsImZ1bGxfbmFtZSI6Ik5hdGlvbmFsIEdlb2dyYXBoaWMifSwiaWQiOiI3MTk2OTI0ODE4NDA2MzI4MzkifSwidXNlcl9oYXNfbGlrZWQiOmZhbHNlLCJpZCI6IjcxOTY5MjQ4MDgwMDQ0NjAyOF83ODcxMzIiLCJ1c2VyIjp7InVzZXJuYW1lIjoibmF0Z2VvIiwid2Vic2l0ZSI6IiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzc4NzEzMl83NXNxXzEzNjMwNTM0OTguanBnIiwiZnVsbF9uYW1lIjoiTmF0aW9uYWwgR2VvZ3JhcGhpYyIsImJpbyI6IiIsImlkIjoiNzg3MTMyIn19LHsiYXR0cmlidXRpb24iOm51bGwsInRhZ3MiOlsic3VtbWVyIiwiZmFjZWJvb2siLCJtcGsiXSwidHlwZSI6ImltYWdlIiwibG9jYXRpb24iOm51bGwsImNvbW1lbnRzIjp7ImNvdW50IjowLCJkYXRhIjpbXX0sImZpbHRlciI6Ik5vcm1hbCIsImNyZWF0ZWRfdGltZSI6IjE0MDAwMTEzOTQiLCJsaW5rIjoiaHR0cDovL2luc3RhZ3JhbS5jb20vcC9uOHlEdXZvWVROLyIsImxpa2VzIjp7ImNvdW50Ijo1LCJkYXRhIjpbeyJ1c2VybmFtZSI6ImRsb3BlemxpcmFuem8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yNDQxMDQ5OTRfNzVzcV8xMzcwNjU3MjgyLmpwZyIsImlkIjoiMjQ0MTA0OTk0IiwiZnVsbF9uYW1lIjoiRGllZ28gTG9wZXotTGlyYW56byJ9LHsidXNlcm5hbWUiOiJ0cmlzaHl0cCIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzEyMTEzODkxXzc1c3FfMTM5OTU1NDkzNy5qcGciLCJpZCI6IjEyMTEzODkxIiwiZnVsbF9uYW1lIjoiVHJpc2gg8J+SliJ9LHsidXNlcm5hbWUiOiJncmVlbnl0aWdlciIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzIwMTcxOTA0NV83NXNxXzEzOTA0MDMzODQuanBnIiwiaWQiOiIyMDE3MTkwNDUiLCJmdWxsX25hbWUiOiJncmVlbnl0aWdlciJ9LHsidXNlcm5hbWUiOiJwYXRib3plbWFuIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzIyNDc3MDg1Xzc1c3FfMTM2Mjc2MDQ4MS5qcGciLCJpZCI6IjMyMjQ3NzA4NSIsImZ1bGxfbmFtZSI6IlBhdHJpY2sgQm96ZW1hbiJ9XX0sImltYWdlcyI6eyJsb3dfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtcHJuLmZiY2RuLm5ldC8xMDI5Njc5MV8xNDQ3NDE0MTA4ODMwNTc3XzcxMjk3NjUxNF9hLmpwZyIsIndpZHRoIjozMDYsImhlaWdodCI6MzA2fSwidGh1bWJuYWlsIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzEwMjk2NzkxXzE0NDc0MTQxMDg4MzA1NzdfNzEyOTc2NTE0X3MuanBnIiwid2lkdGgiOjE1MCwiaGVpZ2h0IjoxNTB9LCJzdGFuZGFyZF9yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzEwMjk2NzkxXzE0NDc0MTQxMDg4MzA1NzdfNzEyOTc2NTE0X24uanBnIiwid2lkdGgiOjY0MCwiaGVpZ2h0Ijo2NDB9fSwidXNlcnNfaW5fcGhvdG8iOltdLCJjYXB0aW9uIjp7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTEzOTQiLCJ0ZXh0IjoiSXQncyBhIGJlYXV0aWZ1bCBkYXkgaW4gdGhlIG5laWdoYm9yaG9vZC4gI3N1bW1lciAjbXBrICNmYWNlYm9vayIsImZyb20iOnsidXNlcm5hbWUiOiJnYzNzdGFncmFtIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzM0MDcyMTQ0Xzc1c3FfMTM5NDk5NjQ4Ni5qcGciLCJpZCI6IjMzNDA3MjE0NCIsImZ1bGxfbmFtZSI6Ikdlb3JnZSBDYWJyZXJhIn0sImlkIjoiNzE5NjcwMTk5NDgzMjA0NzMxIn0sInVzZXJfaGFzX2xpa2VkIjpmYWxzZSwiaWQiOiI3MTk2NzAxOTkxNDc2NjA0OTNfMzM0MDcyMTQ0IiwidXNlciI6eyJ1c2VybmFtZSI6ImdjM3N0YWdyYW0iLCJ3ZWJzaXRlIjoiIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzM0MDcyMTQ0Xzc1c3FfMTM5NDk5NjQ4Ni5qcGciLCJmdWxsX25hbWUiOiJHZW9yZ2UgQ2FicmVyYSIsImJpbyI6IiIsImlkIjoiMzM0MDcyMTQ0In19LHsiYXR0cmlidXRpb24iOm51bGwsInRhZ3MiOlsiZG9scGhpbnMiLCJwYXRhZ29uaWEiXSwidHlwZSI6ImltYWdlIiwibG9jYXRpb24iOm51bGwsImNvbW1lbnRzIjp7ImNvdW50IjoxMjE0LCJkYXRhIjpbeyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxNjQ1IiwidGV4dCI6IldoYXQgYSBkYWNrISBAam9lc2NoZWZmIiwiZnJvbSI6eyJ1c2VybmFtZSI6Implc3NpZWpvYmxhbG9jayIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzIyNTM5NzkxXzc1c3FfMTM5MTgxMjQyNy5qcGciLCJpZCI6IjIyNTM5NzkxIiwiZnVsbF9uYW1lIjoiamVzc2llIGpvIn0sImlkIjoiNzE5NzU2MTkwNjg0MzcwNzY1In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxNjkyIiwidGV4dCI6IiNzbmFweW91cnN0YXkgQGZsb3NzcG90IiwiZnJvbSI6eyJ1c2VybmFtZSI6ImVjdzI4MCIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzIwODM0MDA4NV83NXNxXzEzOTQ1MTgwMDYuanBnIiwiaWQiOiIyMDgzNDAwODUiLCJmdWxsX25hbWUiOiJMaXogVy4ifSwiaWQiOiI3MTk3NTY1Nzk5NDA5NDc4MTgifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE3MzciLCJ0ZXh0IjoiV2938J+YsyIsImZyb20iOnsidXNlcm5hbWUiOiJwc3ljaGVkZWxpY2RqIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNDIzNzE0NTQ3Xzc1c3FfMTM4MDcxMjk0NS5qcGciLCJpZCI6IjQyMzcxNDU0NyIsImZ1bGxfbmFtZSI6IuKcqEp1c3RpbuKcqCJ9LCJpZCI6IjcxOTc1Njk2MDg5MjgwMjk1NCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTc3MyIsInRleHQiOiJDb29sISEhISIsImZyb20iOnsidXNlcm5hbWUiOiJhcml6b25hNDg0OCIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzExOTEyMTc3MjVfNzVzcV8xMzk4NjIzMDc5LmpwZyIsImlkIjoiMTE5MTIxNzcyNSIsImZ1bGxfbmFtZSI6IkphY2tzb24gQmVhc2xleSA4KSJ9LCJpZCI6IjcxOTc1NzI2Mjg4MjY5MDk3OCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTc4MiIsInRleHQiOiJPcmNhIGdpdmVzIHNlYSBsaW9uIGJsb3dpZS4uLiIsImZyb20iOnsidXNlcm5hbWUiOiJtYXJjdXNwZWFjZWNveCIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzU0ODU0ODMxXzc1c3FfMTM3NjUzMjcyOC5qcGciLCJpZCI6IjU0ODU0ODMxIiwiZnVsbF9uYW1lIjoibWFyY3VzcGVhY2Vjb3gifSwiaWQiOiI3MTk3NTczMzkyNzc3NDQwNDIifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE4NDgiLCJ0ZXh0IjoiTG9sIG9tZyB0aGF0IHRvdGFsbHkgaXMuIE5lbyBpcyBzdWNoIGEgbGl0dGxlIHNlYWwgbG9sIEBsaXNpX2FubjY4IiwiZnJvbSI6eyJ1c2VybmFtZSI6InNhYmFkYXNzIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjY3OTg5Mzg3Xzc1c3FfMTM5NjQ4NTQxNS5qcGciLCJpZCI6IjI2Nzk4OTM4NyIsImZ1bGxfbmFtZSI6IlNhYmF0dHVzIE8nQ29ubmVsbCJ9LCJpZCI6IjcxOTc1Nzg4NjY4NDc0NzczMSJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTg3NyIsInRleHQiOiJAbmFkYW1zMiIsImZyb20iOnsidXNlcm5hbWUiOiJrYXRpZV9rZXN0bmVyIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTcwMDY4ODJfNzVzcV8xMzk5NTg5OTA2LmpwZyIsImlkIjoiMTcwMDY4ODIiLCJmdWxsX25hbWUiOiJrYXRpZSBrZXN0bmVyIn0sImlkIjoiNzE5NzU4MTMxMTg3NTA1MTI5In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxOTA2IiwidGV4dCI6IkBjbGFybzYiLCJmcm9tIjp7InVzZXJuYW1lIjoicF9vX2xlYmxhbmMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xOTQ0OTI5NjZfNzVzcV8xMzg3MDY0ODkwLmpwZyIsImlkIjoiMTk0NDkyOTY2IiwiZnVsbF9uYW1lIjoiUC5PLiBMZWJsYW5jIn0sImlkIjoiNzE5NzU4MzczNjUxODI5NzY1In1dfSwiZmlsdGVyIjoiTm9ybWFsIiwiY3JlYXRlZF90aW1lIjoiMTQwMDAxMDM1NiIsImxpbmsiOiJodHRwOi8vaW5zdGFncmFtLmNvbS9wL244d0VfVW9WZkgvIiwibGlrZXMiOnsiY291bnQiOjk3Njc2LCJkYXRhIjpbeyJ1c2VybmFtZSI6ImNoYWltYWFuaXlhIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTE5MDMxNDBfNzVzcV8xMzk5ODg1MzQzLmpwZyIsImlkIjoiMTE5MDMxNDAiLCJmdWxsX25hbWUiOiJjaGFpbWFhbml5YSJ9LHsidXNlcm5hbWUiOiJzYWZpcmFub3ZhZXNfIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjA1OTYyNDQzXzc1c3FfMTM5NDA1MDk1NC5qcGciLCJpZCI6IjIwNTk2MjQ0MyIsImZ1bGxfbmFtZSI6IlNhZmlyYSBOb3ZhZXMifSx7InVzZXJuYW1lIjoianVhbWl0aW9uZ3NvbiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzEyNTQ0ODUyXzc1c3FfMTM5OTcwNTk1OC5qcGciLCJpZCI6IjEyNTQ0ODUyIiwiZnVsbF9uYW1lIjoiSnVhbWkgVGlvbmdzb24ifSx7InVzZXJuYW1lIjoiYXJtaWxkYWEiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yMjI1NDgxNDNfNzVzcV8xMzg4NTk1OTMxLmpwZyIsImlkIjoiMjIyNTQ4MTQzIiwiZnVsbF9uYW1lIjoiRGVsYSBBcm1pbGRhIn1dfSwiaW1hZ2VzIjp7Imxvd19yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzEwMzU0MzI1XzE0NTM4NzgyNTE1MjA1OTlfMTk0OTQwMzU0N19hLmpwZyIsIndpZHRoIjozMDYsImhlaWdodCI6MzA2fSwidGh1bWJuYWlsIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzEwMzU0MzI1XzE0NTM4NzgyNTE1MjA1OTlfMTk0OTQwMzU0N19zLmpwZyIsIndpZHRoIjoxNTAsImhlaWdodCI6MTUwfSwic3RhbmRhcmRfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtcHJuLmZiY2RuLm5ldC8xMDM1NDMyNV8xNDUzODc4MjUxNTIwNTk5XzE5NDk0MDM1NDdfbi5qcGciLCJ3aWR0aCI6NjQwLCJoZWlnaHQiOjY0MH19LCJ1c2Vyc19pbl9waG90byI6W10sImNhcHRpb24iOnsiY3JlYXRlZF90aW1lIjoiMTQwMDAxMDM1NiIsInRleHQiOiJQaG90byBieSBAQnJpYW5Ta2VycnlcbkFuIE9yY2EgYXR0YWNrcyBhIFNvdXRoZXJuIFNlYSBMaW9uIHB1cCBvbiB0aGUgYmVhY2ggaW4gUHVudGEgTm9ydGUsIEFyZ2VudGluYSBhdCBzdW5zZXQuIE9yY2FzIGhlcmUgaGF2ZSBkZXZlbG9wZWQgdGhpcyB1bmlxdWUgZmVlZGluZyBzdHJhdGVneS5cbkNvdmVyYWdlIGZyb20gYW4gdXBjb21pbmcgc3RvcnkgYWJvdXQgZG9scGhpbnMgaW4gQG5hdGdlby5cbkB0aGVwaG90b3NvY2lldHkgQG5hdGdlb2NyZWF0aXZlXG4jcGF0YWdvbmlhICNkb2xwaGlucyIsImZyb20iOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV83ODcxMzJfNzVzcV8xMzYzMDUzNDk4LmpwZyIsImlkIjoiNzg3MTMyIiwiZnVsbF9uYW1lIjoiTmF0aW9uYWwgR2VvZ3JhcGhpYyJ9LCJpZCI6IjcxOTY2MTQ5MDA3ODA0NTQ5NSJ9LCJ1c2VyX2hhc19saWtlZCI6ZmFsc2UsImlkIjoiNzE5NjYxNDg5NTc0NzI5NjcxXzc4NzEzMiIsInVzZXIiOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJ3ZWJzaXRlIjoiIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNzg3MTMyXzc1c3FfMTM2MzA1MzQ5OC5qcGciLCJmdWxsX25hbWUiOiJOYXRpb25hbCBHZW9ncmFwaGljIiwiYmlvIjoiIiwiaWQiOiI3ODcxMzIifX0seyJhdHRyaWJ1dGlvbiI6bnVsbCwidGFncyI6WyJzdGFyIiwibmV1dHJvbnN0YXIiLCJ1bml2ZXJzZSIsInN1cGVybm92YSIsImJsYWNraG9sZSIsIm5hc2EiLCJzY2llbmNlIiwiYXN0cm9waHlzaWNzIl0sInR5cGUiOiJpbWFnZSIsImxvY2F0aW9uIjpudWxsLCJjb21tZW50cyI6eyJjb3VudCI6NTc4LCJkYXRhIjpbeyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxNTQ3IiwidGV4dCI6IkBuYXNhIEkgd291bGRuJ3QgaW1hZ2luZSEhISIsImZyb20iOnsidXNlcm5hbWUiOiJnaWxkZW50ZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzMwMjUyOTY5Nl83NXNxXzEzOTMxNzEzNDguanBnIiwiaWQiOiIzMDI1Mjk2OTYiLCJmdWxsX25hbWUiOiJHaWxiZXJ0byBELiBNZW5kZXMifSwiaWQiOiI3MTk3NTUzNjUzMjkyNDkwMjgifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE2MDEiLCJ0ZXh0IjoiUmVsaWdpb24ganVzdCBkb2Vzbid0IHBlcnRhaW4gdG8gc2NpZW5jZSBhdCBhbGwsIHNvIHRoYXQgc2hvdWxkIGJlIGEgc2lnbi4gRG9uJ3Qgc3RhcnQgd2l0aCB0aGF0IGJ1bGwgc2hpdC4gWW91ciBnb2QgZGlkIG5vdCBjcmVhdGUgbWUgb3IgYW55b25lIGVsc2UuIEkgYW0gYW4gb2Zmc3ByaW5nIGRpcmVjdGx5IGZyb20gbXkgcGFyZW50cy4gWW91ciBnb2QgaXNuJ3QgY2FwYWJsZSBvZiBhbnl0aGluZyBiZWNhdXNlIGhlIGRvZXNuJ3QgZXhpc3QuIEknbSBvbmx5IHNheWluZyB0aGlzIGJlY2F1c2UgeW91J3JlIHB1dHRpbmcgbWUgaW4gYSBib3gsIHNvIGRvbid0IHRyeSBhbmQgc2F5IEkgYW0gc2hvdmluZyBteSBiZWxpZWZzIGRvd24geW91ciB0aHJvYXQgYmVjYXVzZSB5b3Ugd291bGQgYmUgY29udHJhZGljdGluZyB5b3Vyc2VsZi4gWW91J3JlIHRyeWluZyB0byBzaG92ZSB5b3VyIHJlbGlnaW9uIGRvd24gbXkgdGhyb2F0LiBZb3VyIGdvZCBpcyBqdXN0IGEgZmlnbWVudCBvZiB5b3VyIGltYWdpbmF0aW9uIGFuZCB0aGVyZSdzIG5ldmVyIGJlZW4gYW55IHByb29mIHdoYXRzb2V2ZXIgdGhhdCBoZSBkb2VzIGV4aXN0LiBCdXQsIEkgcmVhbGx5IGRvbid0IHdhbnQgdG8gZ28gYW55IGZ1cnRoZXIgd2l0aCB0aGlzIGJlY2F1c2UgZWl0aGVyOiBhKSBJJ2xsIGh1cnQgeW91ciBmZWVsaW5ncyBvciBiKSB5b3UncmUgZ29pbmcgdG8ga2VlcCBnb2luZyB3aXRoIHlvdXIgcmVsaWdpb3VzIGJ1bGxzaGl0LiBAaXRzZG9yaXNkaWF6IiwiZnJvbSI6eyJ1c2VybmFtZSI6ImRvbWNoZWVrcyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzE4Mjg1MDk1MF83NXNxXzEzNjU0NzQ4OTUuanBnIiwiaWQiOiIxODI4NTA5NTAiLCJmdWxsX25hbWUiOiJEb21pbmljYSBTYW5kZXJzIn0sImlkIjoiNzE5NzU1ODE2OTI5OTYwNzQwIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxNjY3IiwidGV4dCI6IkFtYXppbmchISEiLCJmcm9tIjp7InVzZXJuYW1lIjoia2NmMjUwOSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzEyMjcyNjczODBfNzVzcV8xMzk5NDAxNDI3LmpwZyIsImlkIjoiMTIyNzI2NzM4MCIsImZ1bGxfbmFtZSI6ImtjZjI1MDkifSwiaWQiOiI3MTk3NTYzNzM3NDg5ODI1OTAifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE3MDQiLCJ0ZXh0IjoiUmlnaHQgYnV0IG15IFwiYmVsaWVmc1wiIGFyZW4ndCBiZWxpZWZzIGF0IGFsbC4gVGhleSdyZSBmYWN0cyBhbmQgdW50aWwgdGhvc2UgZmFjdHMgYXJlIHByb3ZlbiB0byBiZSBmYWxzZSwgSSB3aWxsIHN0aWNrIGJ5IHRoZW0uIEBzaGFtbWFraGk5NiIsImZyb20iOnsidXNlcm5hbWUiOiJkb21jaGVla3MiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xODI4NTA5NTBfNzVzcV8xMzY1NDc0ODk1LmpwZyIsImlkIjoiMTgyODUwOTUwIiwiZnVsbF9uYW1lIjoiRG9taW5pY2EgU2FuZGVycyJ9LCJpZCI6IjcxOTc1NjY4MjU5MjM2MzM0MCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTc1NiIsInRleHQiOiJBd2Vzb21lbmVzcyEhISEhISEiLCJmcm9tIjp7InVzZXJuYW1lIjoiYW5hX2thcnJlbiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzM0NDIxMTcxOF83NXNxXzEzOTk5NTkxNDAuanBnIiwiaWQiOiIzNDQyMTE3MTgiLCJmdWxsX25hbWUiOiJBbmEga2FyZW4gRMOtYXoifSwiaWQiOiI3MTk3NTcxMTk4NTY5NDM5NjgifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE4MTciLCJ0ZXh0IjoiQGJyb29rZWVob3dlbGwgYW4gaW50ZW5zZSByZWFkIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImFkYWFtYm94IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjM2MzU3NjNfNzVzcV8xMzk5NTUxNDA1LmpwZyIsImlkIjoiMjM2MzU3NjMiLCJmdWxsX25hbWUiOiJBZGFtIEJveCJ9LCJpZCI6IjcxOTc1NzYyNjk0ODI5NzU5MyJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTg4NCIsInRleHQiOiJAZG9tY2hlZWtzIHdlbGwgdGhhdHMgYSBoZWFsdGh5IHZpZXcgcG9pbnQsIGp1c3QgZG9udCBtaXggeW91ciBvcGluaW9ucyB3aXRoIHlvdXIgaWRlbnRpdHksIHRoZXkgc2hvdWxkIGJlIHRoaW5ncyB0aGF0IGFyZSBlYXNpbHkgY2hhbmdlZCwgc28gdGhhdCBvbmNlIHlvdSBjb21lIGFjcm9zcyBhIGJldHRlciBvcGluaW9uIHlvdSBjYW4gcmVwbGFjZSBpdC4gQWxzbyBHb2RzIG5vbi1leGlzdGVuY2UgaXNuJ3QgYSBmYWN0LCBHb2QgbWF5IGhhdmUgY2F1c2VkIHRoZSBiaWcgYmFuZy4gOlAiLCJmcm9tIjp7InVzZXJuYW1lIjoic2hhbW1ha2hpOTYiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV81NzI4Njc0ODFfNzVzcV8xMzk4NjIwNDc0LmpwZyIsImlkIjoiNTcyODY3NDgxIiwiZnVsbF9uYW1lIjoiWWFoeWEifSwiaWQiOiI3MTk3NTgxOTU0Njk0Mjc2MTAifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE5MTgiLCJ0ZXh0IjoiIzNwb2ludHM0c2NpZW5jZSIsImZyb20iOnsidXNlcm5hbWUiOiJmcmFua2hhbGFjIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjY5NjgwODA1Xzc1c3FfMTM3MjgwNTA3Mi5qcGciLCJpZCI6IjI2OTY4MDgwNSIsImZ1bGxfbmFtZSI6IkZyYW5rIEhhbGFzZXkifSwiaWQiOiI3MTk3NTg0Nzc5MzA2MzYyMDcifV19LCJmaWx0ZXIiOiJOb3JtYWwiLCJjcmVhdGVkX3RpbWUiOiIxNDAwMDA3MTM3IiwibGluayI6Imh0dHA6Ly9pbnN0YWdyYW0uY29tL3AvbjhwOEFfb2FLeC8iLCJsaWtlcyI6eyJjb3VudCI6NDkzNTgsImRhdGEiOlt7InVzZXJuYW1lIjoiYnVnZWciLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zMDA0NDYyNV83NXNxXzEzNDcyNjUxNTMuanBnIiwiaWQiOiIzMDA0NDYyNSIsImZ1bGxfbmFtZSI6IkNhaXRsaW4ifSx7InVzZXJuYW1lIjoia2pzZGltZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI2OTcyNzM0OF83NXNxXzEzOTU1ODk3MzguanBnIiwiaWQiOiIyNjk3MjczNDgiLCJmdWxsX25hbWUiOiJLZXZpbiJ9LHsidXNlcm5hbWUiOiJjc3dzamF5IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjExOTc1NTI2Xzc1c3FfMTM5MTM3MTIxMS5qcGciLCJpZCI6IjIxMTk3NTUyNiIsImZ1bGxfbmFtZSI6IkpheSBQZXJleiJ9LHsidXNlcm5hbWUiOiJzaGFsYXRoZWh1dHQiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV81MTM0MjQwN183NXNxXzEzOTk0MjEyMjAuanBnIiwiaWQiOiI1MTM0MjQwNyIsImZ1bGxfbmFtZSI6InNoYWxhdGhlaHV0dCJ9XX0sImltYWdlcyI6eyJsb3dfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtZnJjLmZiY2RuLm5ldC8xMDMxMTIwOF81NTg5MDQzOTc1NTU0ODhfNzgyMzM0NzMwX2EuanBnIiwid2lkdGgiOjMwNiwiaGVpZ2h0IjozMDZ9LCJ0aHVtYm5haWwiOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLWZyYy5mYmNkbi5uZXQvMTAzMTEyMDhfNTU4OTA0Mzk3NTU1NDg4Xzc4MjMzNDczMF9zLmpwZyIsIndpZHRoIjoxNTAsImhlaWdodCI6MTUwfSwic3RhbmRhcmRfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtZnJjLmZiY2RuLm5ldC8xMDMxMTIwOF81NTg5MDQzOTc1NTU0ODhfNzgyMzM0NzMwX24uanBnIiwid2lkdGgiOjY0MCwiaGVpZ2h0Ijo2NDB9fSwidXNlcnNfaW5fcGhvdG8iOltdLCJjYXB0aW9uIjp7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMDcxMzciLCJ0ZXh0IjoiT25lIG9mIHRoZSBtb3N0IHZpb2xlbnQgZXZlbnRzIGluIHRoZSB1bml2ZXJzZTogYSBwYWlyIG9mIG5ldXRyb24gc3RhcnMgY29sbGlkaW5nLCBtZXJnaW5nIGFuZCBmb3JtaW5nIGEgYmxhY2sgaG9sZS4gQSBuZXV0cm9uIHN0YXIgaXMgdGhlIGNvbXByZXNzZWQgY29yZSBsZWZ0IGJlaGluZCB3aGVuIGEgc3RhciBib3JuIHdpdGggYmV0d2VlbiBlaWdodCBhbmQgMzAgdGltZXMgdGhlIHN1bidzIG1hc3MgZXhwbG9kZXMgYXMgYSBzdXBlcm5vdmEuIE5ldXRyb24gc3RhcnMgcGFjayBhYm91dCAxLjUgdGltZXMgdGhlIG1hc3Mgb2YgdGhlIHN1biAtIGVxdWl2YWxlbnQgdG8gYWJvdXQgaGFsZiBhIG1pbGxpb24gRWFydGhzIC0gaW50byBhIGJhbGwganVzdCAxMiBtaWxlcyAoMjAga20pIGFjcm9zcy5cblxuQXMgdGhlIHN0YXJzIHNwaXJhbCB0b3dhcmQgZWFjaCBvdGhlciwgaW50ZW5zZSB0aWRlcyBiZWdpbiB0byBkZWZvcm0gdGhlbSwgcG9zc2libHkgY3JhY2tpbmcgdGhlaXIgY3J1c3RzLiBOZXV0cm9uIHN0YXJzIHBvc3Nlc3MgaW5jcmVkaWJsZSBkZW5zaXR5LCBidXQgdGhlaXIgc3VyZmFjZXMgYXJlIGNvbXBhcmF0aXZlbHkgdGhpbiwgd2l0aCBkZW5zaXRpZXMgYWJvdXQgYSBtaWxsaW9uIHRpbWVzIGdyZWF0ZXIgdGhhbiBnb2xkLiBUaGVpciBpbnRlcmlvcnMgY3J1c2ggbWF0dGVyIHRvIGEgbXVjaCBncmVhdGVyIGRlZ3JlZSBkZW5zaXRpZXMgcmlzZSBieSAxMDAgbWlsbGlvbiB0aW1lcyBpbiB0aGVpciBjZW50ZXJzLiBUbyBiZWdpbiB0byBpbWFnaW5lIHN1Y2ggbWluZC1ib2dnbGluZyBkZW5zaXRpZXMsIGNvbnNpZGVyIHRoYXQgYSBjdWJpYyBjZW50aW1ldGVyIG9mIG5ldXRyb24gc3RhciBtYXR0ZXIgb3V0d2VpZ2hzIE1vdW50IEV2ZXJlc3QuXG5cbkNyZWRpdDogTkFTQSdzIEdvZGRhcmQgU3BhY2UgRmxpZ2h0IENlbnRlclxuXG4jbmFzYSAjc3RhciAjYmxhY2tob2xlICNuZXV0cm9uc3RhciAjdW5pdmVyc2UgI2FzdHJvcGh5c2ljcyAjc3VwZXJub3ZhICNzY2llbmNlIiwiZnJvbSI6eyJ1c2VybmFtZSI6Im5hc2EiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV81Mjg4MTcxNTFfNzVzcV8xMzc3NzkyNjU5LmpwZyIsImlkIjoiNTI4ODE3MTUxIiwiZnVsbF9uYW1lIjoiTkFTQSJ9LCJpZCI6IjcxOTYzNDQ4NDg5MjM3Nzc0MCJ9LCJ1c2VyX2hhc19saWtlZCI6ZmFsc2UsImlkIjoiNzE5NjM0NDg0NjE1NTUzNzEzXzUyODgxNzE1MSIsInVzZXIiOnsidXNlcm5hbWUiOiJuYXNhIiwid2Vic2l0ZSI6IiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzUyODgxNzE1MV83NXNxXzEzNzc3OTI2NTkuanBnIiwiZnVsbF9uYW1lIjoiTkFTQSIsImJpbyI6IiIsImlkIjoiNTI4ODE3MTUxIn19LHsiYXR0cmlidXRpb24iOm51bGwsInRhZ3MiOlsiMyJdLCJ0eXBlIjoiaW1hZ2UiLCJsb2NhdGlvbiI6eyJpZCI6MjYzMDY4MTE2fSwiY29tbWVudHMiOnsiY291bnQiOjYwMSwiZGF0YSI6W3siY3JlYXRlZF90aW1lIjoiMTQwMDAyMDc4MiIsInRleHQiOiJXb3cgQHNvY2lhbGlzdGljMSBAc2V0aG9zODMwIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImxldHNwYXJrc2ZseTM4IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNTM3Mjc2NDAyXzc1c3FfMTM3ODY4NzE4NC5qcGciLCJpZCI6IjUzNzI3NjQwMiIsImZ1bGxfbmFtZSI6IkpheSJ9LCJpZCI6IjcxOTc0ODk1MDE0OTY0OTcyMCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMDgxMyIsInRleHQiOiJAc2l4YWVybyBjaGVjayBvdXQgdGhpcyBwb3N04oCmIiwiZnJvbSI6eyJ1c2VybmFtZSI6Im5qc2VpeGVpcm8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zNDAwNTQ5Xzc1c3FfMTM3ODE2MTg3Ni5qcGciLCJpZCI6IjM0MDA1NDkiLCJmdWxsX25hbWUiOiJOaWNvbGUifSwiaWQiOiI3MTk3NDkyMDk1MzM3OTc3MDcifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjA5NTkiLCJ0ZXh0IjoiQHNleGluaXp6IEBiZWdfNF9tZXJjeSBAbWlrZXJ1ZWNhIEBiZWNhdXNldmVnYXMgIFNoYXJlIHRoaXMgd2l0aCBwZW9wbGUgeW91IGtub3cgZnJvbSBWZWdhcy4iLCJmcm9tIjp7InVzZXJuYW1lIjoicm9kbmV5dGhld3JlY2tlciIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzc5NTI2Njg2Ml83NXNxXzEzOTQ0NjQ0NjMuanBnIiwiaWQiOiI3OTUyNjY4NjIiLCJmdWxsX25hbWUiOiJSb2RuZXkgUm9iZXJ0c29uIn0sImlkIjoiNzE5NzUwNDM1ODk3OTU1NzU3In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIwOTkzIiwidGV4dCI6IkBjZmlzaG1hbiIsImZyb20iOnsidXNlcm5hbWUiOiJqc2xhdmV0IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzUxNzY2MjM3Xzc1c3FfMTM2NTg5OTU2NC5qcGciLCJpZCI6IjM1MTc2NjIzNyIsImZ1bGxfbmFtZSI6Ikp1bGllIn0sImlkIjoiNzE5NzUwNzE4MDQwMzk3MjQzIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxMTk1IiwidGV4dCI6IkBtcl9tYXloZW1fXyBjcmF6eSIsImZyb20iOnsidXNlcm5hbWUiOiJzb2NpYWxpc3RpYzEiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV80MzkyMzA3NTNfNzVzcV8xMzcyMzg2MjM4LmpwZyIsImlkIjoiNDM5MjMwNzUzIiwiZnVsbF9uYW1lIjoiVm9uIn0sImlkIjoiNzE5NzUyNDEwMDcyOTYyNjI1In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxMzEyIiwidGV4dCI6IkBtYW1ha2MgaG9wZWZ1bGx5IHlvdXIgd2F0ZXIgYmlsbCBpc24ndCB0b28gYmFkISIsImZyb20iOnsidXNlcm5hbWUiOiJzbm93X2Zvcl9sb3MiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV81NTc1NTQ1Ml83NXNxXzEzOTk5MjEwMDEuanBnIiwiaWQiOiI1NTc1NTQ1MiIsImZ1bGxfbmFtZSI6InNub3dfZm9yX2xvcyJ9LCJpZCI6IjcxOTc1MzM5MTg4NDAzMTYzMCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTU4NiIsInRleHQiOiJAbGl6ei5hcmQgbGFrZSBtZWFkIHdhcyBjcmVhdGVkIGFmdGVyIHRoZXkgYnVpbHQgdGhlIEhvb3ZlciBEYW0g8J+YjCIsImZyb20iOnsidXNlcm5hbWUiOiJiZXR0aWVzMzIzIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTgwMzM2NDQzXzc1c3FfMTM4NDY0MjYxMy5qcGciLCJpZCI6IjE4MDMzNjQ0MyIsImZ1bGxfbmFtZSI6IkVsaXphYmV0aCBBcnJveW8ifSwiaWQiOiI3MTk3NTU2ODk1OTA4NzE4MzcifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE1OTciLCJ0ZXh0IjoiQGphbm5ldF9yb2RkZCAuLi5ncmVhdCDwn5iRIiwiZnJvbSI6eyJ1c2VybmFtZSI6Imd1aWNobzAwIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjcxMzIyNjY1Xzc1c3FfMTM5Mzc4NTE1Ny5qcGciLCJpZCI6IjI3MTMyMjY2NSIsImZ1bGxfbmFtZSI6Ikd1aWNobyJ9LCJpZCI6IjcxOTc1NTc4Njg4MTk0NzQzMCJ9XX0sImZpbHRlciI6Ik5vcm1hbCIsImNyZWF0ZWRfdGltZSI6IjEzOTk5OTc4NzYiLCJsaW5rIjoiaHR0cDovL2luc3RhZ3JhbS5jb20vcC9uOFlSaVpJVmNOLyIsImxpa2VzIjp7ImNvdW50Ijo4MDk4MiwiZGF0YSI6W3sidXNlcm5hbWUiOiJwYW5lbGE0ODgiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xMzIyNzI1ODM3Xzc1c3FfMTM5OTkyMzYwOC5qcGciLCJpZCI6IjEzMjI3MjU4MzciLCJmdWxsX25hbWUiOiJiYXJieSJ9LHsidXNlcm5hbWUiOiJnZW1pbmlsejA2MTMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xMjIyODAyMTU2Xzc1c3FfMTM5OTU5NjYyMS5qcGciLCJpZCI6IjEyMjI4MDIxNTYiLCJmdWxsX25hbWUiOiLmiJHlsLHmmK/miJEifSx7InVzZXJuYW1lIjoiZG1pdHJpaV8xMyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzQ0Njc0MDUzXzc1c3FfMTM4ODc1NzM5Mi5qcGciLCJpZCI6IjQ0Njc0MDUzIiwiZnVsbF9uYW1lIjoi0JTQvNC40YLRgNC40LkifSx7InVzZXJuYW1lIjoiYXpvb296Nzg2IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNTA2ODY1MDIxXzc1c3FfMTM5NTc0OTUwMy5qcGciLCJpZCI6IjUwNjg2NTAyMSIsImZ1bGxfbmFtZSI6ImF6b29vejc4NiJ9XX0sImltYWdlcyI6eyJsb3dfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtZnJjLmZiY2RuLm5ldC8xMDM2MjIyNV82NTU3MjA2Mjc4MzE3ODlfNjE3OTM4ODU5X2EuanBnIiwid2lkdGgiOjMwNiwiaGVpZ2h0IjozMDZ9LCJ0aHVtYm5haWwiOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLWZyYy5mYmNkbi5uZXQvMTAzNjIyMjVfNjU1NzIwNjI3ODMxNzg5XzYxNzkzODg1OV9zLmpwZyIsIndpZHRoIjoxNTAsImhlaWdodCI6MTUwfSwic3RhbmRhcmRfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtZnJjLmZiY2RuLm5ldC8xMDM2MjIyNV82NTU3MjA2Mjc4MzE3ODlfNjE3OTM4ODU5X24uanBnIiwid2lkdGgiOjY0MCwiaGVpZ2h0Ijo2NDB9fSwidXNlcnNfaW5fcGhvdG8iOltdLCJjYXB0aW9uIjp7ImNyZWF0ZWRfdGltZSI6IjEzOTk5OTc4NzYiLCJ0ZXh0IjoiQ29uc3RydWN0aW9uIHdvcmtlciwgSW50YWtlIFR1bm5lbCAjMywgdW5kZXIgTGFrZSBNZWFkLCBOZXZhZGEuIFBob3RvIGJ5IEBwZXRlcmVzc2ljay4gV2l0aCB0aGUgb25nb2luZyBkcm91Z2h0LCB3YXRlciBsZXZlbHMgaGF2ZSBnb3R0ZW4gc28gbG93IGluIExha2UgTWVhZCB0aGF0IG9uZSBvZiB0aGUgdHdvIHdvcmtpbmcgaW50YWtlIHBpcGVzIGRyYXdpbmcgd2F0ZXIgZm9yIExhcyBWZWdhcyB3YXMgaW4gZGFuZ2VyIG9mIGJlaW5nIGFib3ZlIHRoZSBsYWtlLiBBdCBhIGNvc3Qgb2YgJDg2MCBtaWxsaW9uLCB0aGUgd2F0ZXIgYXV0aG9yaXR5IGlzIGJ1aWxkaW5nIGEgdGhpcmQgaW50YWtlIHBpcGUgMjAgZmVldCBpbiBkaWFtZXRlciB0byBpbnN1cmUgd2F0ZXIgaXMgYXZhaWxhYmxlIHdoZW4gdGhlIGxha2UgaXMgbG93LiBUaGUgY29zdCBpcyBiZWluZyBwYWlkIGJ5IHJlc2lkZW50cyBvZiBMYXMgVmVnYXMgaW4gdGhlIGZvcm0gb2YgaGlnaGVyIHdhdGVyIGJpbGxzLiIsImZyb20iOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV83ODcxMzJfNzVzcV8xMzYzMDUzNDk4LmpwZyIsImlkIjoiNzg3MTMyIiwiZnVsbF9uYW1lIjoiTmF0aW9uYWwgR2VvZ3JhcGhpYyJ9LCJpZCI6IjcxOTU1Njc5OTE2ODA3NTE2NyJ9LCJ1c2VyX2hhc19saWtlZCI6ZmFsc2UsImlkIjoiNzE5NTU2Nzk4NzQ4NjQ1MTMzXzc4NzEzMiIsInVzZXIiOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJ3ZWJzaXRlIjoiIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNzg3MTMyXzc1c3FfMTM2MzA1MzQ5OC5qcGciLCJmdWxsX25hbWUiOiJOYXRpb25hbCBHZW9ncmFwaGljIiwiYmlvIjoiIiwiaWQiOiI3ODcxMzIifX0seyJhdHRyaWJ1dGlvbiI6bnVsbCwidGFncyI6W10sInR5cGUiOiJpbWFnZSIsImxvY2F0aW9uIjpudWxsLCJjb21tZW50cyI6eyJjb3VudCI6MTE1LCJkYXRhIjpbeyJjcmVhdGVkX3RpbWUiOiIxNDAwMDE0MzU1IiwidGV4dCI6IkBmcmFua3lfYm9uZXogeWVwIHdlIGhhdmUgc29tZSBhZHZlbnR1cmluZyB0byBkbyIsImZyb20iOnsidXNlcm5hbWUiOiJjaHJpc3RpbmV5c3RlZW4iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zNjUzNjg4MjJfNzVzcV8xMzc5Mjg0MDAwLmpwZyIsImlkIjoiMzY1MzY4ODIyIiwiZnVsbF9uYW1lIjoiQ2hyaXN0aW5lIn0sImlkIjoiNzE5Njk1MDMzODU0NTIwNDA0In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDE0ODUyIiwidGV4dCI6IkBhbGxpX2FjIEtpbnRsYT8iLCJmcm9tIjp7InVzZXJuYW1lIjoicGV0ZV9uX2RvdWciLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xODE3NzY1ODRfNzVzcV8xMzYxNTUxNjE3LmpwZyIsImlkIjoiMTgxNzc2NTg0IiwiZnVsbF9uYW1lIjoiUGV0ZXIgTHluY2gifSwiaWQiOiI3MTk2OTkyMDQyNDI1OTkyNTcifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTY2OTIiLCJ0ZXh0IjoiQW1hemluZyIsImZyb20iOnsidXNlcm5hbWUiOiJlc3JhX3kzIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjU0MDI3ODcwXzc1c3FfMTM3NzE0MzQ5OS5qcGciLCJpZCI6IjI1NDAyNzg3MCIsImZ1bGxfbmFtZSI6ImVzcmEifSwiaWQiOiI3MTk3MTQ2MzgyMzI3NDMxOTIifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTc0MzUiLCJ0ZXh0Ijoi8J+RjfCfkY0iLCJmcm9tIjp7InVzZXJuYW1lIjoiZGltdXRyaSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzIwMTg1MDc1NF83NXNxXzEzOTgyNjE1OTUuanBnIiwiaWQiOiIyMDE4NTA3NTQiLCJmdWxsX25hbWUiOiJkaW11dHJpIn0sImlkIjoiNzE5NzIwODc1ODA4NzE0NDE3In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDE3NDgxIiwidGV4dCI6IkxvdmUgaXQiLCJmcm9tIjp7InVzZXJuYW1lIjoibW9yZ2FubWNraW5uZXkyMDAwIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL2Fub255bW91c1VzZXIuanBnIiwiaWQiOiIxMzI5MTMzOTI5IiwiZnVsbF9uYW1lIjoiTW9yZ2FuIFNtYW50aGEgTWNraW5uZXkifSwiaWQiOiI3MTk3MjEyNTc1MTU1NDQyNzIifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTc3NzYiLCJ0ZXh0IjoiTXkgaGFwcHkgcGxhY2UuIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImVoX21lIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNDcyMjU5OV83NXNxXzEzNzUwNTc5NDUuanBnIiwiaWQiOiI0NzIyNTk5IiwiZnVsbF9uYW1lIjoiZWhfbWUifSwiaWQiOiI3MTk3MjM3MzYwNDcyMTg1MDAifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTk5MDAiLCJ0ZXh0IjoiQGN1cmlvdXNjYXJvbHluIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImthdGVseW5ubl9yYWUiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xNzgwNzA5MzNfNzVzcV8xMzY2NjUwMzU3LmpwZyIsImlkIjoiMTc4MDcwOTMzIiwiZnVsbF9uYW1lIjoiS2F0ZWx5biBIYXJtb24ifSwiaWQiOiI3MTk3NDE1NDg3NjEzNzg1NzkifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjE4NTgiLCJ0ZXh0IjoiQHRoZV9oaWdoX3BlYWtzIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImJyaXRhaW5fcmV5bm9sZHMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zMzcyMzMxNDJfNzVzcV8xMzg3MDgxMTcxLmpwZyIsImlkIjoiMzM3MjMzMTQyIiwiZnVsbF9uYW1lIjoiQnJpdGFpbiBSZXlub2xkcyJ9LCJpZCI6IjcxOTc1Nzk3ODY4OTAwNzE0NyJ9XX0sImZpbHRlciI6Ik5vcm1hbCIsImNyZWF0ZWRfdGltZSI6IjEzOTk5OTQxNDkiLCJsaW5rIjoiaHR0cDovL2luc3RhZ3JhbS5jb20vcC9uOFJLb1FBdV9nLyIsImxpa2VzIjp7ImNvdW50IjoxMDE4NiwiZGF0YSI6W3sidXNlcm5hbWUiOiJicml0YWluX3JleW5vbGRzIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzM3MjMzMTQyXzc1c3FfMTM4NzA4MTE3MS5qcGciLCJpZCI6IjMzNzIzMzE0MiIsImZ1bGxfbmFtZSI6IkJyaXRhaW4gUmV5bm9sZHMifSx7InVzZXJuYW1lIjoibWFsbG9yaWVjb29rIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjg0Njc3OTA5Xzc1c3FfMTM3ODY2OTIxNS5qcGciLCJpZCI6IjI4NDY3NzkwOSIsImZ1bGxfbmFtZSI6Ik1hbGxvcmllIENvb2sifSx7InVzZXJuYW1lIjoiY2xhcmF2ZWxlenRvYmlhcyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI2NDU5NjYxNF83NXNxXzEzNzU3NDUwOTkuanBnIiwiaWQiOiIyNjQ1OTY2MTQiLCJmdWxsX25hbWUiOiJDbGFyYSBUb2JpYXMifSx7InVzZXJuYW1lIjoidF9yb3ZlcyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9hbm9ueW1vdXNVc2VyLmpwZyIsImlkIjoiNDE2MTkwODQ1IiwiZnVsbF9uYW1lIjoidF9yb3ZlcyJ9XX0sImltYWdlcyI6eyJsb3dfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtZnJjLmZiY2RuLm5ldC8xMDMxMTA0Ml80NTAyOTYyMzE3NDA2NzhfOTA2MTIyMDE2X2EuanBnIiwid2lkdGgiOjMwNiwiaGVpZ2h0IjozMDZ9LCJ0aHVtYm5haWwiOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLWZyYy5mYmNkbi5uZXQvMTAzMTEwNDJfNDUwMjk2MjMxNzQwNjc4XzkwNjEyMjAxNl9zLmpwZyIsIndpZHRoIjoxNTAsImhlaWdodCI6MTUwfSwic3RhbmRhcmRfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtZnJjLmZiY2RuLm5ldC8xMDMxMTA0Ml80NTAyOTYyMzE3NDA2NzhfOTA2MTIyMDE2X24uanBnIiwid2lkdGgiOjY0MCwiaGVpZ2h0Ijo2NDB9fSwidXNlcnNfaW5fcGhvdG8iOltdLCJjYXB0aW9uIjp7ImNyZWF0ZWRfdGltZSI6IjEzOTk5OTQxNDkiLCJ0ZXh0IjoiVGhpcyB3ZWVrLCBAR2xhY2llck5QUyB0dXJucyAxMDQuIFBsZWFzZSBqb2luIHVzIGluIHdpc2hpbmcgdGhlbSBhIHZlcnkgaGFwcHkgYmlydGhkYXkhXG5cblBob3RvOiBBZGFtIEpld2VsbCAod3d3LnNoYXJldGhlZXhwZXJpZW5jZS5vcmcpIiwiZnJvbSI6eyJ1c2VybmFtZSI6InVzaW50ZXJpb3IiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xNzQ0MzUxODZfNzVzcV8xMzQwMjg1MjkxLmpwZyIsImlkIjoiMTc0NDM1MTg2IiwiZnVsbF9uYW1lIjoiVS5TLiBEZXBhcnRtZW50IG9mIHRoZSBJbnRlcmlvciJ9LCJpZCI6IjcxOTUyNTUzNzk0NDYyODM5MiJ9LCJ1c2VyX2hhc19saWtlZCI6ZmFsc2UsImlkIjoiNzE5NTI1NTM3Njc2MTkzNzYwXzE3NDQzNTE4NiIsInVzZXIiOnsidXNlcm5hbWUiOiJ1c2ludGVyaW9yIiwid2Vic2l0ZSI6IiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzE3NDQzNTE4Nl83NXNxXzEzNDAyODUyOTEuanBnIiwiZnVsbF9uYW1lIjoiVS5TLiBEZXBhcnRtZW50IG9mIHRoZSBJbnRlcmlvciIsImJpbyI6IiIsImlkIjoiMTc0NDM1MTg2In19LHsiYXR0cmlidXRpb24iOm51bGwsInRhZ3MiOltdLCJ0eXBlIjoiaW1hZ2UiLCJsb2NhdGlvbiI6bnVsbCwiY29tbWVudHMiOnsiY291bnQiOjEwNTgsImRhdGEiOlt7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjAxNDEiLCJ0ZXh0IjoiQG1rcDE2NjQiLCJmcm9tIjp7InVzZXJuYW1lIjoiamFja3NvbnRpZ3dlbGwiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV80NTY5NDI0OTdfNzVzcV8xMzk5ODQ2NDgxLmpwZyIsImlkIjoiNDU2OTQyNDk3IiwiZnVsbF9uYW1lIjoiamFja3NvbnRpZ3dlbGwifSwiaWQiOiI3MTk3NDM1NjkwNzQ3MzI5MDMifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjAzNDkiLCJ0ZXh0IjoiQXdlc29tZSBAOWFmcml0eiIsImZyb20iOnsidXNlcm5hbWUiOiJqZG1hcnRtYWMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yODc1NzY3MTJfNzVzcV8xMzc3MjYyNTcwLmpwZyIsImlkIjoiMjg3NTc2NzEyIiwiZnVsbF9uYW1lIjoiSm9zZXBoIE1hcnRpbmV6In0sImlkIjoiNzE5NzQ1MzIwMDYyNDM1MjgxIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIwNzY3IiwidGV4dCI6Ikl0IHNlZW1zIHVuZGVyIHdhdGVyLCBtYWduaWZpY2VudCIsImZyb20iOnsidXNlcm5hbWUiOiJlZG9tdXJhejIyIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjUyMzUzOTIyXzc1c3FfMTM1NDQ1NTUwOC5qcGciLCJpZCI6IjI1MjM1MzkyMiIsImZ1bGxfbmFtZSI6IkVkb2FyZG8gTXVyYXp6aSJ9LCJpZCI6IjcxOTc0ODgyMjY3NTM3MzM1NSJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMDg2OCIsInRleHQiOiJNw7xrZW1tZWwiLCJmcm9tIjp7InVzZXJuYW1lIjoiZXNyYWtjb3NrdW4iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvYW5vbnltb3VzVXNlci5qcGciLCJpZCI6IjEzMjI1MzYwNjQiLCJmdWxsX25hbWUiOiJlc2tlYyJ9LCJpZCI6IjcxOTc0OTY2NjQ2ODY3NDkzNCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMDk5OSIsInRleHQiOiJUaGlzIGlzIGJlYXV0aWZ1dXV1bGxsbCAhISIsImZyb20iOnsidXNlcm5hbWUiOiJtaXNoYWxtdWJhc2hpciIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzM3MDIyMjk0MV83NXNxXzEzOTk5NzY4OTYuanBnIiwiaWQiOiIzNzAyMjI5NDEiLCJmdWxsX25hbWUiOiJNaXNoYWwgTXViYXNoaXIifSwiaWQiOiI3MTk3NTA3NjUxMzMwNTM0MDMifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjEwMTAiLCJ0ZXh0IjoibG9va3MgbGlrZSBhbiB1bmRlcndhdGVyIHBob3RvISIsImZyb20iOnsidXNlcm5hbWUiOiJtYXRrYXRtdXNpYyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzIyMjAyNDE3Nl83NXNxXzEzNTE3OTQ2NzQuanBnIiwiaWQiOiIyMjIwMjQxNzYiLCJmdWxsX25hbWUiOiJtYXRrYXRtdXNpYyJ9LCJpZCI6IjcxOTc1MDg1ODIwNDY1OTE3NSJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTIwNiIsInRleHQiOiJAY2FpdG1jY2F5IEkgdGhvdWdodCBpdCB3YXMgdW5kZXIgd2F0ZXIgYXQgZmlyc3QiLCJmcm9tIjp7InVzZXJuYW1lIjoic2NodWNoYXJ0YiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzE1MzcyNDYyXzc1c3FfMTM1NjgyNTU4My5qcGciLCJpZCI6IjE1MzcyNDYyIiwiZnVsbF9uYW1lIjoic2NodWNoYXJ0YiJ9LCJpZCI6IjcxOTc1MjUwMzE1MTk2Nzg1MCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTY4NSIsInRleHQiOiJXb3cgcmVhbGx5IGJlYXV0aWZ1bPCfkY/wn5GP8J+SkPCfkpAiLCJmcm9tIjp7InVzZXJuYW1lIjoibmFybWFyaW4iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yNTM0ODgwMTBfNzVzcV8xMzk5ODA2NzIxLmpwZyIsImlkIjoiMjUzNDg4MDEwIiwiZnVsbF9uYW1lIjoiTmF0In0sImlkIjoiNzE5NzU2NTI0NzQyOTE4MDM5In1dfSwiZmlsdGVyIjoiTm9ybWFsIiwiY3JlYXRlZF90aW1lIjoiMTM5OTk5Mjg1MCIsImxpbmsiOiJodHRwOi8vaW5zdGFncmFtLmNvbS9wL244T3NFUkVqOUQvIiwibGlrZXMiOnsiY291bnQiOjExNDkxMiwiZGF0YSI6W3sidXNlcm5hbWUiOiJhbm5hYW5kZWxha2FsIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzEzMjc5MDI2Xzc1c3FfMTM2MjIyMzUyNC5qcGciLCJpZCI6IjMxMzI3OTAyNiIsImZ1bGxfbmFtZSI6IkFubmEgQW5kZWxhIEthbG91c292YSJ9LHsidXNlcm5hbWUiOiJuYXRoYW5qZXNrZTEiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zMDY0NTUxMjZfNzVzcV8xMzc2MjAxOTQyLmpwZyIsImlkIjoiMzA2NDU1MTI2IiwiZnVsbF9uYW1lIjoiTmF0aGFuIEplc2tlIn0seyJ1c2VybmFtZSI6ImFyb21hX2luc3QiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvYW5vbnltb3VzVXNlci5qcGciLCJpZCI6IjQ5NDkxMjEzMyIsImZ1bGxfbmFtZSI6IkFyb21hIn0seyJ1c2VybmFtZSI6ImhlbmRyaXNoZW5uIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzQzNjYyMjg2Xzc1c3FfMTM3NDQ1NDQyNi5qcGciLCJpZCI6IjM0MzY2MjI4NiIsImZ1bGxfbmFtZSI6ImhlbmRyaSBzaGVuIn1dfSwiaW1hZ2VzIjp7Imxvd19yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzEwMjk5NjA0XzI4Nzc3NDYyODA1ODM0MV8xODUzODYxMzc0X2EuanBnIiwid2lkdGgiOjMwNiwiaGVpZ2h0IjozMDZ9LCJ0aHVtYm5haWwiOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLXBybi5mYmNkbi5uZXQvMTAyOTk2MDRfMjg3Nzc0NjI4MDU4MzQxXzE4NTM4NjEzNzRfcy5qcGciLCJ3aWR0aCI6MTUwLCJoZWlnaHQiOjE1MH0sInN0YW5kYXJkX3Jlc29sdXRpb24iOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLXBybi5mYmNkbi5uZXQvMTAyOTk2MDRfMjg3Nzc0NjI4MDU4MzQxXzE4NTM4NjEzNzRfbi5qcGciLCJ3aWR0aCI6NjQwLCJoZWlnaHQiOjY0MH19LCJ1c2Vyc19pbl9waG90byI6W10sImNhcHRpb24iOnsiY3JlYXRlZF90aW1lIjoiMTM5OTk5Mjg1MCIsInRleHQiOiJNb3VudGFpbiBHb2RyYXkgfCBQaG90b2dyYXBoeSBieSDCqVJhbGYgU2NocmVpYmVyIiwiZnJvbSI6eyJ1c2VybmFtZSI6Im5hdHVyZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI2NjYxNjZfNzVzcV8xMzgwMTcwNjcxLmpwZyIsImlkIjoiMjY2NjE2NiIsImZ1bGxfbmFtZSI6Im5hdHVyZSJ9LCJpZCI6IjcxOTUxNDY0MTY4MDcxMTY3NSJ9LCJ1c2VyX2hhc19saWtlZCI6ZmFsc2UsImlkIjoiNzE5NTE0NjQxMzYxOTQ0Mzg3XzI2NjYxNjYiLCJ1c2VyIjp7InVzZXJuYW1lIjoibmF0dXJlIiwid2Vic2l0ZSI6IiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI2NjYxNjZfNzVzcV8xMzgwMTcwNjcxLmpwZyIsImZ1bGxfbmFtZSI6Im5hdHVyZSIsImJpbyI6IiIsImlkIjoiMjY2NjE2NiJ9fSx7ImF0dHJpYnV0aW9uIjpudWxsLCJ0YWdzIjpbImZha2VtZW1vcnkiXSwidHlwZSI6ImltYWdlIiwibG9jYXRpb24iOm51bGwsImNvbW1lbnRzIjp7ImNvdW50Ijo0MywiZGF0YSI6W3siY3JlYXRlZF90aW1lIjoiMTQwMDAwNjI3NyIsInRleHQiOiJAa2JydTE2IiwiZnJvbSI6eyJ1c2VybmFtZSI6Im9yYW5nZW9saW5lIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNTEzODE5NjhfNzVzcV8xMzkyNjg3NzY2LmpwZyIsImlkIjoiNTEzODE5NjgiLCJmdWxsX25hbWUiOiJvcmFuZ2VvbGluZSJ9LCJpZCI6IjcxOTYyNzI2OTQ1Nzg3NDI0NyJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAwNjc5MyIsInRleHQiOiJJIGhhZCB0aGlzIGV4YWN0IG91dGZpdC4gSSBkbyByZW1lbWJlciBpdCB0aG91Z2guIEkgd291bGQgcmVxdWVzdCB0byB3ZWFyIGl0IHRvIG15IEdyYW5kbW90aGVyJ3MuIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImRlc2ltY2tpbm5vbiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzM4MTEzOThfNzVzcV8xMzY2NDA0NDk4LmpwZyIsImlkIjoiMzgxMTM5OCIsImZ1bGxfbmFtZSI6IkRlc2kgTWNLaW5ub24ifSwiaWQiOiI3MTk2MzE1OTk4NTg2NTA2OTMifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTE1MjQiLCJ0ZXh0IjoiQGNlY2lsaWFwYV8gdGUgcGFyZWNlcyIsImZyb20iOnsidXNlcm5hbWUiOiJqYXZpZXJqb19fIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTc1Mjk0MThfNzVzcV8xMzk0ODU3NzQwLmpwZyIsImlkIjoiMTc1Mjk0MTgiLCJmdWxsX25hbWUiOiJKYXZpZXIifSwiaWQiOiI3MTk2NzEyODc2Mjk3Nzg2NjAifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTMxNDIiLCJ0ZXh0IjoiSSB3b24gXCJiZXN0ZHJlc3NlZGNvd2dpcmxcIiBpbiBraW5kZXJnYXJ0ZW4gYW5kIGdvdCB0byByaWRlIGluIGEgcGFyYWRlIC0gSSBzd2VhciBJIHRoaW5rIGl0IHdhcyB0aGlzIHZlcnkgc2FtZSBvdXRmaXQhIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImNyZWF0aXZlb2FzaXNjb2FjaCIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzIwNDQzMTM5Xzc1c3FfMTM1Mjg2NDcyOS5qcGciLCJpZCI6IjIwNDQzMTM5IiwiZnVsbF9uYW1lIjoiSmlsbCBBbGxpc29uIEJyeWFuIn0sImlkIjoiNzE5Njg0ODU1ODY3Njc0MTU1In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDEzNDUwIiwidGV4dCI6IkkgaGFkIHRoaXMgb3V0Zml0IHRvbyEgQW5uaWUgT2FrbGV5OykiLCJmcm9tIjp7InVzZXJuYW1lIjoidHdvdGhpcmRzc2t5IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjkyMzQ4MjFfNzVzcV8xMzUwNjc2MDgxLmpwZyIsImlkIjoiMjkyMzQ4MjEiLCJmdWxsX25hbWUiOiJOZXNzYSJ9LCJpZCI6IjcxOTY4NzQ0MTg0OTAyODI3MyJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAxNjU3OSIsInRleHQiOiJAbWVsYW5kYXZlcnkgQHBoZWxhbjQ3ODAiLCJmcm9tIjp7InVzZXJuYW1lIjoia3JlZGhhbSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzMxNTU4Mzc2Xzc1c3FfMTM3MDk5OTg0NS5qcGciLCJpZCI6IjMxNTU4Mzc2IiwiZnVsbF9uYW1lIjoia3JlZGhhbSJ9LCJpZCI6IjcxOTcxMzY5NDk2MjQ1MzY3NiJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMDgyOCIsInRleHQiOiJAZ2FicmllbGFfYm9zcXVlbmVncm8gdGhvdWdodCBvZiB5b3UhIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImZsZW1pbmdhbWFuZGEiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xOTk5MzEyMTBfNzVzcV8xMzYzMTIxMTU3LmpwZyIsImlkIjoiMTk5OTMxMjEwIiwiZnVsbF9uYW1lIjoiQW1hbmRhIE1hcnRpbiJ9LCJpZCI6IjcxOTc0OTMzMzYxMTIyMDEzNiJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTEwMyIsInRleHQiOiJAZmxlbWluZ2FtYW5kYSA7KSDimaUiLCJmcm9tIjp7InVzZXJuYW1lIjoiZ2FicmllbGFfYm9zcXVlbmVncm8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zMzUzNTg4Nl83NXNxXzEzNTc1MDM2OTguanBnIiwiaWQiOiIzMzUzNTg4NiIsImZ1bGxfbmFtZSI6ImdhYnJpZWxhIGQuIHJ1dmFsY2FiYSJ9LCJpZCI6IjcxOTc1MTY0NDg2NTY2MjI1OCJ9XX0sImZpbHRlciI6Ik5vcm1hbCIsImNyZWF0ZWRfdGltZSI6IjEzOTk5OTE3MzkiLCJsaW5rIjoiaHR0cDovL2luc3RhZ3JhbS5jb20vcC9uOE1rWHp1STlELyIsImxpa2VzIjp7ImNvdW50IjoxNjI5LCJkYXRhIjpbeyJ1c2VybmFtZSI6ImN5bmN5bjc5MSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzMxMzUxMTQ2Xzc1c3FfMTM5NTAyNTM0Mi5qcGciLCJpZCI6IjMxMzUxMTQ2IiwiZnVsbF9uYW1lIjoiQ3ludGhpYSBLIn0seyJ1c2VybmFtZSI6ImhhZjgxMSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzgyNjA1MTdfNzVzcV8xMzczNDYyMDk5LmpwZyIsImlkIjoiODI2MDUxNyIsImZ1bGxfbmFtZSI6IkhlYXRoZXIifSx7InVzZXJuYW1lIjoibmVtYW5qZV91ZGluIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTkzOTgzMDE0Xzc1c3FfMTM5NDU3MDU3NS5qcGciLCJpZCI6IjE5Mzk4MzAxNCIsImZ1bGxfbmFtZSI6Im5lbWFuamVfdWRpbiJ9LHsidXNlcm5hbWUiOiJiZW5lYXRob2NlYW5zb2ZzdGFycyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzk0Nzc2MjYxNF83NXNxXzEzOTg4MzI3MDAuanBnIiwiaWQiOiI5NDc3NjI2MTQiLCJmdWxsX25hbWUiOiJiZW5lYXRob2NlYW5zb2ZzdGFycyJ9XX0sImltYWdlcyI6eyJsb3dfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtZnJjLmZiY2RuLm5ldC8xMDMyNjQ1OF82MjgwMzkwOTA2MTUyMzBfMjEyODg5MDcwMF9hLmpwZyIsIndpZHRoIjozMDYsImhlaWdodCI6MzA2fSwidGh1bWJuYWlsIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1mcmMuZmJjZG4ubmV0LzEwMzI2NDU4XzYyODAzOTA5MDYxNTIzMF8yMTI4ODkwNzAwX3MuanBnIiwid2lkdGgiOjE1MCwiaGVpZ2h0IjoxNTB9LCJzdGFuZGFyZF9yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1mcmMuZmJjZG4ubmV0LzEwMzI2NDU4XzYyODAzOTA5MDYxNTIzMF8yMTI4ODkwNzAwX24uanBnIiwid2lkdGgiOjY0MCwiaGVpZ2h0Ijo2NDB9fSwidXNlcnNfaW5fcGhvdG8iOltdLCJjYXB0aW9uIjp7ImNyZWF0ZWRfdGltZSI6IjEzOTk5OTE3MzkiLCJ0ZXh0IjoiQVNTSUdOTUVOVCEgUGhvdG9ncmFwaHkgKyBNZW1vcnkgPSBXSEE/IT8gU28gbWFueSBvZiBvdXIgbWVtb3JpZXMgYXJlIGluZm9ybWVkIGJ5IGltYWdlcyBvZiBtb21lbnRzIHdlIGRvbuKAmXQgYWN0dWFsbHkgcmVtZW1iZXIuIEJ1dCB0aGV5IGhhcHBlbmVkLCByaWdodD8gQE5QUiB3YW50cyB0byBrbm93OiBEbyB5b3UgaGF2ZSBhICNmYWtlbWVtb3J5IGJhc2VkIGVudGlyZWx5IG9uIG9sZCBwaG90b3MgeW91J3ZlIHNlZW4gb2YgeW91cnNlbGY/IE1vbWVudHMgeW91IHRoaW5rIHlvdSByZW1lbWJlciBvbmx5IGJlY2F1c2UgeW914oCZdmUgc2VlbiBhIHBpY3R1cmU/XG5cblRoaXMgb25lIGlzIGZyb20gQGFzX2V2ZXJfcGhvdG9ncmFwaHkuIFNvbWV0aW1lcyBJIHRoaW5rIEkgcmVtZW1iZXIgc3RhbmRpbmcgb24gQ2FtZWxiYWNrIE1vdW50YWluIGluIFBob2VuaXgsIHdlYXJpbmcgbXkgQ29va2llIE1vbnN0ZXIgdC1zaGlydCBhbmQgbXkgcmVkIGNvd2dpcmwgb3V0Zml0IHdpdGggd2hpdGUgZnJpbmdlLCBidXQgSSBhY3R1YWxseSBvbmx5IGhhdmUgdGhpcyBtZW1vcnkgYmVjYXVzZSBvZiB0aGlzIHBob3RvIChhIGZhbWlseSBmYXZvcml0ZSkuIEkgbGlrZSB0byBpbWFnaW5lIG15IGNoaWxkaG9vZCBmYXZvcml0ZSBzb25nLCBcIlJoaW5lc3RvbmVDb3dib3lcIiwgYXMgdGhlIHNvdW5kdHJhY2sgZm9yIHRoaXMgcGljdHVyZS4gXG5UYWcgb25lIHBob3RvICNmYWtlbWVtb3J5IGFuZCB0ZWxsIHVzIHRoZSBzdG9yeSBpbiB0aGUgY2FwdGlvbjogV2hlcmUgYXJlIHlvdSwgd2h5LCBhbmQgd2hhdCdzIHNwZWNpYWwgYWJvdXQgaXQ/IChBbnkgcGhvdG9zIHRhZ2dlZCBpbiB0aGUgbmV4dCAxMCBkYXlzIGFyZSBlbGlnaWJsZSB0byBmZWF0dXJlZCBoZXJlIG9uIEluc3RhZ3JhbSBvciBvbiBATlBSJ3Mgd2Vic2l0ZS4pIiwiZnJvbSI6eyJ1c2VybmFtZSI6Im5wciIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzEyNTg2MThfNzVzcV8xMjkzODIxODczLmpwZyIsImlkIjoiMTI1ODYxOCIsImZ1bGxfbmFtZSI6Ik5QUiJ9LCJpZCI6IjcxOTUwNTMxNjc4OTEyODMwNSJ9LCJ1c2VyX2hhc19saWtlZCI6ZmFsc2UsImlkIjoiNzE5NTA1MzE2NDk1NTI3NzQ3XzEyNTg2MTgiLCJ1c2VyIjp7InVzZXJuYW1lIjoibnByIiwid2Vic2l0ZSI6IiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzEyNTg2MThfNzVzcV8xMjkzODIxODczLmpwZyIsImZ1bGxfbmFtZSI6Ik5QUiIsImJpbyI6IiIsImlkIjoiMTI1ODYxOCJ9fSx7ImF0dHJpYnV0aW9uIjpudWxsLCJ0YWdzIjpbInNvbGl0dWRlIiwibm9yd2F5IiwibHluZ2VuYWxwcyJdLCJ0eXBlIjoiaW1hZ2UiLCJsb2NhdGlvbiI6bnVsbCwiY29tbWVudHMiOnsiY291bnQiOjczNywiZGF0YSI6W3siY3JlYXRlZF90aW1lIjoiMTQwMDAyMDExMyIsInRleHQiOiJAaG9sbHlvaG5laWwgaXQganVzdCByZW1pbmRzIG1lIHNvIG11Y2ggb2YgeW91ciBpbGx1c3RyYXRpb25zISIsImZyb20iOnsidXNlcm5hbWUiOiJjZWxpYWRlbGFuZXlfIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjk5MDU0OTYxXzc1c3FfMTM4ODYwMTMwOC5qcGciLCJpZCI6IjI5OTA1NDk2MSIsImZ1bGxfbmFtZSI6ImNlbGlhIn0sImlkIjoiNzE5NzQzMzQwMjM0NDk1OTE3In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIwMjc2IiwidGV4dCI6IkBlcmlraHBhdWxzZW4iLCJmcm9tIjp7InVzZXJuYW1lIjoibHVrZXZhbiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzQxMjgzMzcwXzc1c3FfMTM5NzUwMDEyMy5qcGciLCJpZCI6IjQxMjgzMzcwIiwiZnVsbF9uYW1lIjoiTHVrZSJ9LCJpZCI6IjcxOTc0NDcwNTU0NzU1NTg2NiJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMDMzMyIsInRleHQiOiJAbWFkZGllXzEwMjUiLCJmcm9tIjp7InVzZXJuYW1lIjoianVzdGplbmplbiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzUwNDQ4MDg1N183NXNxXzEzNzcwMTExOTAuanBnIiwiaWQiOiI1MDQ0ODA4NTciLCJmdWxsX25hbWUiOiJKZW4gU2F1bmRlcnMifSwiaWQiOiI3MTk3NDUxNzg2MzE0OTI2NzMifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjAzNjMiLCJ0ZXh0IjoiaW1wcmVzc2l2ZSIsImZyb20iOnsidXNlcm5hbWUiOiJuYWdvcmVjYSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzM3NDY3MDUyXzc1c3FfMTM0NDkzMzEzNC5qcGciLCJpZCI6IjM3NDY3MDUyIiwiZnVsbF9uYW1lIjoibmFnb3JlY2EifSwiaWQiOiI3MTk3NDU0MzY5MDgzNDQzOTcifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjAzNzYiLCJ0ZXh0Ijoi8J+Ov2JlYXV0aWZ1bCBzaWxlbmNlIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImdyYW5nZWxpZW4iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xMDA2Mjc4NzQwXzc1c3FfMTM5OTQxNTgxNi5qcGciLCJpZCI6IjEwMDYyNzg3NDAiLCJmdWxsX25hbWUiOiJBbmdpZSZQaGlseEd4In0sImlkIjoiNzE5NzQ1NTQwMzIzMTAzODI4In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIwOTAzIiwidGV4dCI6IkBob3R0bHlrZWZ5ciBAZmxlbWJlYXUgSSdtIGp1c3QgZ29uIHdhdGNoIGZyb20gdGhlIGJhc2Ug8J+TlvCflK0iLCJmcm9tIjp7InVzZXJuYW1lIjoiZ250bGJyd24iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xMzA2ODYxODc5Xzc1c3FfMTM5OTE4MzM5Mi5qcGciLCJpZCI6IjEzMDY4NjE4NzkiLCJmdWxsX25hbWUiOiJKb0pvIn0sImlkIjoiNzE5NzQ5OTYwMTg4Mzg0NjUxIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIwOTIwIiwidGV4dCI6IkBldGVybmFsZnJpc3NvbiIsImZyb20iOnsidXNlcm5hbWUiOiJtYXJrcmFkbWVsaWMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yNDU3NzQ1MzFfNzVzcV8xMzk1ODc2OTc2LmpwZyIsImlkIjoiMjQ1Nzc0NTMxIiwiZnVsbF9uYW1lIjoibWFya3JhZG1lbGljIn0sImlkIjoiNzE5NzUwMTA1NzEzOTU2MjQ3In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxMTg3IiwidGV4dCI6IldvdywgdHJ1bHkgYW4gYW1hemluZyBzaG90ISIsImZyb20iOnsidXNlcm5hbWUiOiJkcmlua2luZ3doaXNreSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI5NzMxMzIxOF83NXNxXzEzNjEzNTkwMDIuanBnIiwiaWQiOiIyOTczMTMyMTgiLCJmdWxsX25hbWUiOiJJIGxpa2Ugd2hpc2t5LiJ9LCJpZCI6IjcxOTc1MjM0Njc4MDkxNTI2MCJ9XX0sImZpbHRlciI6Ik5vcm1hbCIsImNyZWF0ZWRfdGltZSI6IjEzOTk5ODM5NTIiLCJsaW5rIjoiaHR0cDovL2luc3RhZ3JhbS5jb20vcC9uNzl0NGVJVlliLyIsImxpa2VzIjp7ImNvdW50IjoxNjg5NzEsImRhdGEiOlt7InVzZXJuYW1lIjoianVsaWFnb29saWFob29saWEiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yNzc4Mzg3MDVfNzVzcV8xMzk2MTYwMzgwLmpwZyIsImlkIjoiMjc3ODM4NzA1IiwiZnVsbF9uYW1lIjoiSnVsaWEgV2lsbGlhbXPwn4y7In0seyJ1c2VybmFtZSI6ImplbmRhbGxrb25lcyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzM3MDU2NzMwMF83NXNxXzEzOTg5OTg1MDEuanBnIiwiaWQiOiIzNzA1NjczMDAiLCJmdWxsX25hbWUiOiJLZW5kYWxsIEpvbmVzIn0seyJ1c2VybmFtZSI6InBhb2ZyYW5jb2EiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zMDM1OTM4MTdfNzVzcV8xMzYzODI5OTk2LmpwZyIsImlkIjoiMzAzNTkzODE3IiwiZnVsbF9uYW1lIjoiUGFvbGEgQW5kcmVhIEZyYW5jbyBBbWF5YSJ9LHsidXNlcm5hbWUiOiJyeWxhbl9kb2VyaW5nIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjUyODQwNTAzXzc1c3FfMTM4NjkxNDcwNS5qcGciLCJpZCI6IjI1Mjg0MDUwMyIsImZ1bGxfbmFtZSI6IlJ5bGFuIERvZXJpbmcifV19LCJpbWFnZXMiOnsibG93X3Jlc29sdXRpb24iOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLXBybi5mYmNkbi5uZXQvOTI3Mjg3XzE0NzgwMjgxNzU3NjU2MzVfMTQ0MzYxMTkyOV9hLmpwZyIsIndpZHRoIjozMDYsImhlaWdodCI6MzA2fSwidGh1bWJuYWlsIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzkyNzI4N18xNDc4MDI4MTc1NzY1NjM1XzE0NDM2MTE5Mjlfcy5qcGciLCJ3aWR0aCI6MTUwLCJoZWlnaHQiOjE1MH0sInN0YW5kYXJkX3Jlc29sdXRpb24iOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLXBybi5mYmNkbi5uZXQvOTI3Mjg3XzE0NzgwMjgxNzU3NjU2MzVfMTQ0MzYxMTkyOV9uLmpwZyIsIndpZHRoIjo2NDAsImhlaWdodCI6NjQwfX0sInVzZXJzX2luX3Bob3RvIjpbXSwiY2FwdGlvbiI6eyJjcmVhdGVkX3RpbWUiOiIxMzk5OTgzOTUyIiwidGV4dCI6IlBob3RvOiBAamltbXlfY2hpbiBcbiNzb2xpdHVkZSAjbHluZ2VuYWxwcyAjbm9yd2F5IEBuYXRnZW8gQHRoZXBob3Rvc29jaWV0eSIsImZyb20iOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV83ODcxMzJfNzVzcV8xMzYzMDUzNDk4LmpwZyIsImlkIjoiNzg3MTMyIiwiZnVsbF9uYW1lIjoiTmF0aW9uYWwgR2VvZ3JhcGhpYyJ9LCJpZCI6IjcxOTQzOTk5OTYzODAwMTM1MSJ9LCJ1c2VyX2hhc19saWtlZCI6ZmFsc2UsImlkIjoiNzE5NDM5OTk5MzQ0Mzk5ODk5Xzc4NzEzMiIsInVzZXIiOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJ3ZWJzaXRlIjoiIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNzg3MTMyXzc1c3FfMTM2MzA1MzQ5OC5qcGciLCJmdWxsX25hbWUiOiJOYXRpb25hbCBHZW9ncmFwaGljIiwiYmlvIjoiIiwiaWQiOiI3ODcxMzIifX0seyJhdHRyaWJ1dGlvbiI6bnVsbCwidGFncyI6W10sInR5cGUiOiJpbWFnZSIsImxvY2F0aW9uIjp7ImxhdGl0dWRlIjo1Mi4zNzY4MDM1ODIsIm5hbWUiOiJBbXN0ZXJkYW0tQ2VudHJ1bSIsImxvbmdpdHVkZSI6NC44OTc4Mzc3NDksImlkIjoyMTMxNDAwOTV9LCJjb21tZW50cyI6eyJjb3VudCI6MCwiZGF0YSI6W119LCJmaWx0ZXIiOiJFYXJseWJpcmQiLCJjcmVhdGVkX3RpbWUiOiIxMzk5OTczMTc1IiwibGluayI6Imh0dHA6Ly9pbnN0YWdyYW0uY29tL3AvbjdwS1FrUGJzTy8iLCJsaWtlcyI6eyJjb3VudCI6MjgsImRhdGEiOlt7InVzZXJuYW1lIjoibGF2aWVlbmZpbHRlcnMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xOTY5NTg0OF83NXNxXzEzNjM4MzQ3MTIuanBnIiwiaWQiOiIxOTY5NTg0OCIsImZ1bGxfbmFtZSI6ImRhbmkgcnVpeiJ9LHsidXNlcm5hbWUiOiJsaW5hZWxoYXNzYW4iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xODI4NDIzMDRfNzVzcV8xMzkxNTc5Mjk2LmpwZyIsImlkIjoiMTgyODQyMzA0IiwiZnVsbF9uYW1lIjoiTGluYSBFbGhhc3NhbiJ9LHsidXNlcm5hbWUiOiJsaW5kc2V5bWVlIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzY4MzY3Nl83NXNxXzEzNzg5OTQ1MDMuanBnIiwiaWQiOiIzNjgzNjc2IiwiZnVsbF9uYW1lIjoiTGluZHNleSBNZWUifSx7InVzZXJuYW1lIjoiYXBhY2hlcm9zZXBlYWNvY2siLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yMDE5NjU3NV83NXNxXzEzNDU1MzE1MjMuanBnIiwiaWQiOiIyMDE5NjU3NSIsImZ1bGxfbmFtZSI6IlJpbWJvIn1dfSwiaW1hZ2VzIjp7Imxvd19yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzkyNjc3MF83NTM5Mjc1ODEyOTQ2ODlfMjA0MTEwNzE4N19hLmpwZyIsIndpZHRoIjozMDYsImhlaWdodCI6MzA2fSwidGh1bWJuYWlsIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzkyNjc3MF83NTM5Mjc1ODEyOTQ2ODlfMjA0MTEwNzE4N19zLmpwZyIsIndpZHRoIjoxNTAsImhlaWdodCI6MTUwfSwic3RhbmRhcmRfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtcHJuLmZiY2RuLm5ldC85MjY3NzBfNzUzOTI3NTgxMjk0Njg5XzIwNDExMDcxODdfbi5qcGciLCJ3aWR0aCI6NjQwLCJoZWlnaHQiOjY0MH19LCJ1c2Vyc19pbl9waG90byI6W10sImNhcHRpb24iOnsiY3JlYXRlZF90aW1lIjoiMTM5OTk3MzE3NSIsInRleHQiOiJHb29kIG1vcm5pbmcgQW1zdGVyZGFtIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImV3aWxsaWdlcyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzEzNTI4OTQ5Xzc1c3FfMTM5ODQ0MjE0My5qcGciLCJpZCI6IjEzNTI4OTQ5IiwiZnVsbF9uYW1lIjoiRWxpemFiZXRoIFdpbGxpZ2VzIn0sImlkIjoiNzE5MzQ5NTkwNzI5Mjc2NDEzIn0sInVzZXJfaGFzX2xpa2VkIjpmYWxzZSwiaWQiOiI3MTkzNDk1OTAzODUzNDMyNDZfMTM1Mjg5NDkiLCJ1c2VyIjp7InVzZXJuYW1lIjoiZXdpbGxpZ2VzIiwid2Vic2l0ZSI6IiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzEzNTI4OTQ5Xzc1c3FfMTM5ODQ0MjE0My5qcGciLCJmdWxsX25hbWUiOiJFbGl6YWJldGggV2lsbGlnZXMiLCJiaW8iOiIiLCJpZCI6IjEzNTI4OTQ5In19LHsiYXR0cmlidXRpb24iOm51bGwsInRhZ3MiOltdLCJ0eXBlIjoiaW1hZ2UiLCJsb2NhdGlvbiI6bnVsbCwiY29tbWVudHMiOnsiY291bnQiOjM1LCJkYXRhIjpbeyJjcmVhdGVkX3RpbWUiOiIxMzk5OTg2NzYyIiwidGV4dCI6IkFoISBBIEJlcm5lc2UhIFRoZXkncmUgZ3JlYXQgOykiLCJmcm9tIjp7InVzZXJuYW1lIjoidW5jbGVzZXJiIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTk5ODcxXzc1c3FfMTM5ODMzMTEwMi5qcGciLCJpZCI6IjE5OTg3MSIsImZ1bGxfbmFtZSI6IlBhdWwgTmV2aW4ifSwiaWQiOiI3MTk0NjM1NjkxNjY0Mzk5ODAifSx7ImNyZWF0ZWRfdGltZSI6IjEzOTk5ODg1MjIiLCJ0ZXh0Ijoi8J+YmPCfkLYiLCJmcm9tIjp7InVzZXJuYW1lIjoiamF6bWluZV9jaGF2ZXoxMjMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xMzI3NjU4NTgzXzc1c3FfMTM5OTk5MDI5Ni5qcGciLCJpZCI6IjEzMjc2NTg1ODMiLCJmdWxsX25hbWUiOiJKYXptaW5lX0NoYXZleiJ9LCJpZCI6IjcxOTQ3ODMzMzYyODIyNDY5NyJ9LHsiY3JlYXRlZF90aW1lIjoiMTM5OTk5NjIzMCIsInRleHQiOiJJIGhhdmUgb25lIHRvby4gIEJlc3QgZG9ncyBFVkVSIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImJlcmx5a2ltNTUiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zMzQxNzkwNl83NXNxXzEzMzQ4NDczOTcuanBnIiwiaWQiOiIzMzQxNzkwNiIsImZ1bGxfbmFtZSI6IktpbSBSZW5uaW5nZXIifSwiaWQiOiI3MTk1NDI5OTM0NTQ4OTY1NDQifSx7ImNyZWF0ZWRfdGltZSI6IjEzOTk5OTc0NTgiLCJ0ZXh0IjoiU2hlIGxvb2tzIGh1Z2UhICBIb3BlIHlvdSBhcmUgaGF2aW5nIGZ1biB3aXRoIGhlciIsImZyb20iOnsidXNlcm5hbWUiOiJkaWFuZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzM3Xzc1c3FfMTM5NjkxNzI5OC5qcGciLCJpZCI6IjM3IiwiZnVsbF9uYW1lIjoiRGlhbmUgU3lzdHJvbSJ9LCJpZCI6IjcxOTU1MzI5NjIwOTAyNDk3NyJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAwMDQxOSIsInRleHQiOiJEb250Y2hhIGp1c3QgbG92ZSBoZXI/PyIsImZyb20iOnsidXNlcm5hbWUiOiJ0bWFjcSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzk1ODYyNzJfNzVzcV8xMzU3OTkyNTE3LmpwZyIsImlkIjoiOTU4NjI3MiIsImZ1bGxfbmFtZSI6IlRyYWNleSBNY0h1Z2gifSwiaWQiOiI3MTk1NzgxMzA3MzMzMzk4NTAifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMDUzODgiLCJ0ZXh0IjoiQHNoZWxiaXBsZWFzZSBoZWFydCBpcyBtZWx0ZWQuIENvbXBsZXRlbHkuIiwiZnJvbSI6eyJ1c2VybmFtZSI6Im1pcmlhbWVvdyIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzQwMjg0NDRfNzVzcV8xMzk5MDY4Njg4LmpwZyIsImlkIjoiNDAyODQ0NCIsImZ1bGxfbmFtZSI6Im1pcmlhbWVvdyJ9LCJpZCI6IjcxOTYxOTgxMzA3MjE4MDkwMyJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAxNDQxMiIsInRleHQiOiJXaGF0IGEgZ3JlYXQgZmFjZS4iLCJmcm9tIjp7InVzZXJuYW1lIjoiYW5jaG9ydG9tIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTI0MzU3MjFfNzVzcV8xMzg2ODc4OTc2LmpwZyIsImlkIjoiMTI0MzU3MjEiLCJmdWxsX25hbWUiOiJUb20gRW5nbGVoYXJ0In0sImlkIjoiNzE5Njk1NTA4OTI2MzcwOTU2In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDE1NzU1IiwidGV4dCI6IlNvIGN1dGUhIiwiZnJvbSI6eyJ1c2VybmFtZSI6ImpjaGVsYTc4IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTIyMzQ5ODA0NF83NXNxXzEzOTkxODUxODUuanBnIiwiaWQiOiIxMjIzNDk4MDQ0IiwiZnVsbF9uYW1lIjoiQ2hlbGEifSwiaWQiOiI3MTk3MDY3NzYwMTgwOTc5OTcifV19LCJmaWx0ZXIiOiJOb3JtYWwiLCJjcmVhdGVkX3RpbWUiOiIxMzk5OTYyNzcwIiwibGluayI6Imh0dHA6Ly9pbnN0YWdyYW0uY29tL3AvbjdWVUxUZ0JkdC8iLCJsaWtlcyI6eyJjb3VudCI6MjEwNywiZGF0YSI6W3sidXNlcm5hbWUiOiJrYXlsbnlvdW5nIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjAwMTA2NjE5Xzc1c3FfMTM4MzI3ODcyNy5qcGciLCJpZCI6IjIwMDEwNjYxOSIsImZ1bGxfbmFtZSI6IktheWxuIFlvdW5nIn0seyJ1c2VybmFtZSI6Im1vaGRfYXRleWEiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yODgzNTg4ODJfNzVzcV8xMzk4MjAwNTMzLmpwZyIsImlkIjoiMjg4MzU4ODgyIiwiZnVsbF9uYW1lIjoiTU9IQU1FRCBBVEVZQSJ9LHsidXNlcm5hbWUiOiJraGluaGE3IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjU5MTQ5NTk1Xzc1c3FfMTM1NDQ3NTQ1Ny5qcGciLCJpZCI6IjI1OTE0OTU5NSIsImZ1bGxfbmFtZSI6IkVyaWNhIEJyYWdhIn0seyJ1c2VybmFtZSI6ImZpZ25hIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNDA5ODEyNDRfNzVzcV8xMzQwNDUwMjYxLmpwZyIsImlkIjoiNDA5ODEyNDQiLCJmdWxsX25hbWUiOiJWaWNlbnRlIEZpZ25hIn1dfSwiaW1hZ2VzIjp7Imxvd19yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1wcm4uZmJjZG4ubmV0LzExNzA0NjRfNDcyMTM2MDQ2MjUxMTYwXzkxMDI1OTIwX2EuanBnIiwid2lkdGgiOjMwNiwiaGVpZ2h0IjozMDZ9LCJ0aHVtYm5haWwiOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLXBybi5mYmNkbi5uZXQvMTE3MDQ2NF80NzIxMzYwNDYyNTExNjBfOTEwMjU5MjBfcy5qcGciLCJ3aWR0aCI6MTUwLCJoZWlnaHQiOjE1MH0sInN0YW5kYXJkX3Jlc29sdXRpb24iOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLXBybi5mYmNkbi5uZXQvMTE3MDQ2NF80NzIxMzYwNDYyNTExNjBfOTEwMjU5MjBfbi5qcGciLCJ3aWR0aCI6NjQwLCJoZWlnaHQiOjY0MH19LCJ1c2Vyc19pbl9waG90byI6W3sicG9zaXRpb24iOnsieSI6MC42NzY1NjI1LCJ4IjowLjI0Mzc1fSwidXNlciI6eyJ1c2VybmFtZSI6Imp1bm9wdXAiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xMTkzODU2Njg4Xzc1c3FfMTM5NTYwMzM2Ni5qcGciLCJpZCI6IjExOTM4NTY2ODgiLCJmdWxsX25hbWUiOiJKdW5vIn19XSwiY2FwdGlvbiI6eyJjcmVhdGVkX3RpbWUiOiIxMzk5OTYyNzcwIiwidGV4dCI6IlNoZSdzIGdyb3dpbmcgdXAgc28gZmFzdCEiLCJmcm9tIjp7InVzZXJuYW1lIjoibWlrZXlrIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNF83NXNxXzEzNzQxMTA4NjkuanBnIiwiaWQiOiI0IiwiZnVsbF9uYW1lIjoiTWlrZSBLcmllZ2VyIn0sImlkIjoiNzE5MjYyMzExMzYxMDI2MDE3In0sInVzZXJfaGFzX2xpa2VkIjpmYWxzZSwiaWQiOiI3MTkyNjIzMTEwMDAzMTU3NTdfNCIsInVzZXIiOnsidXNlcm5hbWUiOiJtaWtleWsiLCJ3ZWJzaXRlIjoiIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNF83NXNxXzEzNzQxMTA4NjkuanBnIiwiZnVsbF9uYW1lIjoiTWlrZSBLcmllZ2VyIiwiYmlvIjoiIiwiaWQiOiI0In19LHsiYXR0cmlidXRpb24iOm51bGwsInRhZ3MiOlsidmVyZG9uZ29yZ2UiLCJncmlmZmludnVsdHVyZSJdLCJ0eXBlIjoiaW1hZ2UiLCJsb2NhdGlvbiI6eyJsYXRpdHVkZSI6NDMuNzc2MzU5ODE5LCJsb25naXR1ZGUiOjYuMjQzMDg2NDAxfSwiY29tbWVudHMiOnsiY291bnQiOjEyNjcsImRhdGEiOlt7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMTk5ODAiLCJ0ZXh0IjoiZ29kIiwiZnJvbSI6eyJ1c2VybmFtZSI6InNhbG1hbl8wMjEiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zNDY4MTY0NjlfNzVzcV8xMzk1MDU0NjYwLmpwZyIsImlkIjoiMzQ2ODE2NDY5IiwiZnVsbF9uYW1lIjoiXn5TQUxNQU4gQklOIFNBQUR+XiJ9LCJpZCI6IjcxOTc0MjIxNjU5NzIzMTQyMCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMDQzNCIsInRleHQiOiJANDE1X3BlYWNoZXMiLCJmcm9tIjp7InVzZXJuYW1lIjoic21hZGFuYXQiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yMDgzMjkxNTFfNzVzcV8xMzkyMTg1NTAwLmpwZyIsImlkIjoiMjA4MzI5MTUxIiwiZnVsbF9uYW1lIjoic21hZGFuYXQifSwiaWQiOiI3MTk3NDYwMjc2Njc2NzQyMzQifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMjA1MDMiLCJ0ZXh0IjoiQHRoZWhvcGVmdWxlYWdsZXQiLCJmcm9tIjp7InVzZXJuYW1lIjoicmFlZmdlb3JnZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzMyMjA0NjY2MV83NXNxXzEzODMyMjgyMjAuanBnIiwiaWQiOiIzMjIwNDY2NjEiLCJmdWxsX25hbWUiOiJyYWVmZ2VvcmdlIn0sImlkIjoiNzE5NzQ2NjA0NDA5NjQwMDk5In0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIwOTE2IiwidGV4dCI6IkBhbmRyZXdreWxlbGFyc29uIHRoZXJlIGl0IGlzIGFnYWluIDopIiwiZnJvbSI6eyJ1c2VybmFtZSI6InBhY253Z3JsIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTY1NTk5MzhfNzVzcV8xMzY3Njg1NDQzLmpwZyIsImlkIjoiMTY1NTk5MzgiLCJmdWxsX25hbWUiOiJwYWNud2dybCJ9LCJpZCI6IjcxOTc1MDA3MzE3NDU0NTgxMyJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTA0NSIsInRleHQiOiJAbGl6em9hdyIsImZyb20iOnsidXNlcm5hbWUiOiJqc2xhdmV0IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzUxNzY2MjM3Xzc1c3FfMTM2NTg5OTU2NC5qcGciLCJpZCI6IjM1MTc2NjIzNyIsImZ1bGxfbmFtZSI6Ikp1bGllIn0sImlkIjoiNzE5NzUxMTU1MjEyNzAzMTkzIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxNDE3IiwidGV4dCI6IkBtZWx2aW5iaXJkIiwiZnJvbSI6eyJ1c2VybmFtZSI6InRvcmljaGlzaG9sbSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI3ODA5ODc4Xzc1c3FfMTM4MjQ0MTgwMy5qcGciLCJpZCI6IjI3ODA5ODc4IiwiZnVsbF9uYW1lIjoi8J+MvCJ9LCJpZCI6IjcxOTc1NDI3NzQzNTgyMzgxOCJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAyMTU3NCIsInRleHQiOiJAdGhvbWFzcmliIGxlbWJyZWkgZG8gZGlhIHF1ZSB0dSBtZSBlbnNpbm91IGEgdm9hci4gSGFoYSIsImZyb20iOnsidXNlcm5hbWUiOiJsYXVyYWhvbGl2ZWlyYWgiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV80NDM5MTgzN183NXNxXzEzOTQ3Njk4ODcuanBnIiwiaWQiOiI0NDM5MTgzNyIsImZ1bGxfbmFtZSI6IkxhdXJhIE9saXZlaXJhIn0sImlkIjoiNzE5NzU1NTk2MjU5MjE5MjIxIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDIxOTIyIiwidGV4dCI6Ikdvb2QiLCJmcm9tIjp7InVzZXJuYW1lIjoic2ViYXN0aWFucmFuZ2VsbW9ucm95IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNTc2OTUyMTM1Xzc1c3FfMTM5ODQ5NTAyMy5qcGciLCJpZCI6IjU3Njk1MjEzNSIsImZ1bGxfbmFtZSI6IlNlYmFzdGlhbiJ9LCJpZCI6IjcxOTc1ODUwOTcxNTA1MTU0MCJ9XX0sImZpbHRlciI6Ik5vcm1hbCIsImNyZWF0ZWRfdGltZSI6IjEzOTk5NjIzNzkiLCJsaW5rIjoiaHR0cDovL2luc3RhZ3JhbS5jb20vcC9uN1VrYVVvVlh6LyIsImxpa2VzIjp7ImNvdW50IjoyNDgwNjQsImRhdGEiOlt7InVzZXJuYW1lIjoiZ2g5NDIiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zNDUwODk2NTZfNzVzcV8xMzk5NzAyOTExLmpwZyIsImlkIjoiMzQ1MDg5NjU2IiwiZnVsbF9uYW1lIjoiZ2g5NDIifSx7InVzZXJuYW1lIjoiaGlpbW11c2giLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zOTQxMzQ3NjVfNzVzcV8xMzk3MzgwMjUzLmpwZyIsImlkIjoiMzk0MTM0NzY1IiwiZnVsbF9uYW1lIjoiTXVzaCJ9LHsidXNlcm5hbWUiOiJnbG9yaWZpZWRmaXNoZXJtYW4iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yMzk5NzEwMjFfNzVzcV8xMzUwNzE3ODk4LmpwZyIsImlkIjoiMjM5OTcxMDIxIiwiZnVsbF9uYW1lIjoiU2ltb24gUGF1bCBEaXhvbiJ9LHsidXNlcm5hbWUiOiJyeWxhbl9kb2VyaW5nIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjUyODQwNTAzXzc1c3FfMTM4NjkxNDcwNS5qcGciLCJpZCI6IjI1Mjg0MDUwMyIsImZ1bGxfbmFtZSI6IlJ5bGFuIERvZXJpbmcifV19LCJpbWFnZXMiOnsibG93X3Jlc29sdXRpb24iOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLXBybi5mYmNkbi5uZXQvMTAzNDk3NTNfODQ1OTI1MjU1NDM1MTA2XzE1NTE5MzIwMjdfYS5qcGciLCJ3aWR0aCI6MzA2LCJoZWlnaHQiOjMwNn0sInRodW1ibmFpbCI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtcHJuLmZiY2RuLm5ldC8xMDM0OTc1M184NDU5MjUyNTU0MzUxMDZfMTU1MTkzMjAyN19zLmpwZyIsIndpZHRoIjoxNTAsImhlaWdodCI6MTUwfSwic3RhbmRhcmRfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtcHJuLmZiY2RuLm5ldC8xMDM0OTc1M184NDU5MjUyNTU0MzUxMDZfMTU1MTkzMjAyN19uLmpwZyIsIndpZHRoIjo2NDAsImhlaWdodCI6NjQwfX0sInVzZXJzX2luX3Bob3RvIjpbXSwiY2FwdGlvbiI6eyJjcmVhdGVkX3RpbWUiOiIxMzk5OTYyMzc5IiwidGV4dCI6IlBob3RvIEBsYWR6aW5za2kgLyBBICNHcmlmZmluVnVsdHVyZSByaWRpbmcgdGhlcm1hbHMgYW5kIGdyYWNlZnVsbHkgZ2xpZGluZyBvdmVyIHRoZSB2YWxsZXkgb2YgdGhlICNWZXJkb25Hb3JnZSwgRnJhbmNlIGluIHNlYXJjaCBvZiBmb29kLiBUaGVzZSBiaXJkcyBjYW4gZ2V0IGFzIGxhcmdlIGFzIDQgZmVldCB0YWxsIHdpdGggYSB3aW5nIHNwYW4gb2YganVzdCBvdmVyIDkgZmVldCBsb25nLiBUaGV5J3JlIGFuIG9taW5vdXMgeWV0IGJlYXV0aWZ1bCBzaWdodCB0byBzZWUsIGVzcGVjaWFsbHkgd2hlbiB5b3UncmUgaGFuZ2luZyBvbiB0aGUgc2lkZSBvZiB0aGUgY2xpZmYgd2FsbHMuIFNob3Qgb24gYXNzaWdubWVudCB3aXRoIHRlYW0gQGFuZHJld2Jpc2hhcmF0IEBtYXR0c2VnYWwgQGVtaWx5YWhhcnJpbmd0b24gQHRoZW5vcnRoZmFjZSBAZXR0ZWxvYyBAM3N0cmluZ3Nwcm9kdWN0aW9ucyIsImZyb20iOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV83ODcxMzJfNzVzcV8xMzYzMDUzNDk4LmpwZyIsImlkIjoiNzg3MTMyIiwiZnVsbF9uYW1lIjoiTmF0aW9uYWwgR2VvZ3JhcGhpYyJ9LCJpZCI6IjcxOTI1OTAyODgzMzc4NTY0OSJ9LCJ1c2VyX2hhc19saWtlZCI6ZmFsc2UsImlkIjoiNzE5MjU5MDI4NTkwNTE1Njk5Xzc4NzEzMiIsInVzZXIiOnsidXNlcm5hbWUiOiJuYXRnZW8iLCJ3ZWJzaXRlIjoiIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNzg3MTMyXzc1c3FfMTM2MzA1MzQ5OC5qcGciLCJmdWxsX25hbWUiOiJOYXRpb25hbCBHZW9ncmFwaGljIiwiYmlvIjoiIiwiaWQiOiI3ODcxMzIifX0seyJhdHRyaWJ1dGlvbiI6bnVsbCwidGFncyI6WyJua29yZWEiXSwidHlwZSI6ImltYWdlIiwibG9jYXRpb24iOnsibGF0aXR1ZGUiOjM5LjAwNzMzMzMzMywibG9uZ2l0dWRlIjoxMjUuNzM3fSwiY29tbWVudHMiOnsiY291bnQiOjY2LCJkYXRhIjpbeyJjcmVhdGVkX3RpbWUiOiIxMzk5OTkzNjE1IiwidGV4dCI6IkB5b3VuZ3Bpb25lZXIgRHVkZSwgdGhlIHRydXRoIHVzdWFsbHkgaXMuIEl0J3Mgbm90IGEgc3dpcGUgYXQgdGhlIHBlb3BsZSBvZiBOLiBLb3JlYS4gVGhhdCBwbGFjZSBpcyByZXBsZXRlIHdpdGggZXhhbXBsZXMgb2Ygc291bGxlc3MgYXJ0aWZpY2UuIEp1c3QgY3VyaW91cyBpZiB0aGV5IHNlZSB0aGF0IG9yIGl0J3Mgb25seSBvYnNlcnZlZCBieSB0aGUgb3V0c2lkZSB3b3JsZC4iLCJmcm9tIjp7InVzZXJuYW1lIjoidGhlcXVhIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNTQwNDE5MDlfNzVzcV8xMzkzOTkxNjIxLmpwZyIsImlkIjoiNTQwNDE5MDkiLCJmdWxsX25hbWUiOiJUaGUgUXVhIn0sImlkIjoiNzE5NTIxMDU3NjU2MjEyNTc1In0seyJjcmVhdGVkX3RpbWUiOiIxMzk5OTk0MDc0IiwidGV4dCI6IlJhaW5ib3cgPSAjZ2F5cHJpZGUiLCJmcm9tIjp7InVzZXJuYW1lIjoia3Jpc3Rvd2ZmZXIiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xODEzNjk0Ml83NXNxXzEzOTk5Mjk3MDQuanBnIiwiaWQiOiIxODEzNjk0MiIsImZ1bGxfbmFtZSI6IktyaXMgQmF5bG9uIn0sImlkIjoiNzE5NTI0OTAyOTc3MzQyNzM1In0seyJjcmVhdGVkX3RpbWUiOiIxMzk5OTk0MjE3IiwidGV4dCI6IldvdyIsImZyb20iOnsidXNlcm5hbWUiOiJ0aGVzaW5naW5nZmxvd2VyIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTI1OTk0NzRfNzVzcV8xMzc1ODgwMzY1LmpwZyIsImlkIjoiMTI1OTk0NzQiLCJmdWxsX25hbWUiOiJKYWNseW4gTWNDbHVyZSJ9LCJpZCI6IjcxOTUyNjEwNTgxOTg0MzkwMyJ9LHsiY3JlYXRlZF90aW1lIjoiMTM5OTk5NjY1MCIsInRleHQiOiJAY2Fkb2ZhZ2FuZWxsbyA/Pz8/Pz8/IFF1ZSBpc3NvIHZlbGhvPyIsImZyb20iOnsidXNlcm5hbWUiOiJndXN0YXZvYmVybmFyZGVzcmV5IiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTA5MDcwMjJfNzVzcV8xMzc4ODk5MTI2LmpwZyIsImlkIjoiMTA5MDcwMjIiLCJmdWxsX25hbWUiOiJSZXkifSwiaWQiOiI3MTk1NDY1MTcyNjYwNDIwNzYifSx7ImNyZWF0ZWRfdGltZSI6IjE0MDAwMDI3MzEiLCJ0ZXh0IjoiQHNsZWt5YW5nODcgIGxvbCBuIGtvcmVhIiwiZnJvbSI6eyJ1c2VybmFtZSI6Im9uZWdsaWFfYjMyMSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI0MzU5NTI0Xzc1c3FfMTM5OTA1OTUwMy5qcGciLCJpZCI6IjI0MzU5NTI0IiwiZnVsbF9uYW1lIjoiQnJpYSBPbmVnbGlhIn0sImlkIjoiNzE5NTk3NTIxNzM5MTI0MzUwIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDE1NTgwIiwidGV4dCI6IklzIHRoYXQgcmFpbmJvdyBtYWRlIG9mIHBpcGUgY2xlYW5lcnM/PyIsImZyb20iOnsidXNlcm5hbWUiOiJtaXJhc3NpIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzAyMDQ3NV83NXNxXzEzOTU1NTQzNTAuanBnIiwiaWQiOiIzMDIwNDc1IiwiZnVsbF9uYW1lIjoibWlyYXNzaSJ9LCJpZCI6IjcxOTcwNTMxNTAxNjM3OTc0OSJ9LHsiY3JlYXRlZF90aW1lIjoiMTQwMDAxODU3NyIsInRleHQiOiJNYWtlcyBtZSBmZWVsIHNvIHNhZC4uLiIsImZyb20iOnsidXNlcm5hbWUiOiJoZWxlbmFjbGVlIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfNDM4NDEwMDVfNzVzcV8xMzYwNTU2MjQ4LmpwZyIsImlkIjoiNDM4NDEwMDUiLCJmdWxsX25hbWUiOiJIZWxlbmEgTGVlIn0sImlkIjoiNzE5NzMwNDUwNzkyMzg2MjQxIn0seyJjcmVhdGVkX3RpbWUiOiIxNDAwMDE4NzQ5IiwidGV4dCI6IkB0aGVxdWEgSSdkIHNheSBjb21lIHRvIE5vcnRoIEtvcmVhIGFuZCBjaGVjayBpdCBvdXQgZm9yIHlvdXJzZWxmLiBNeSB0b3VyaXN0cyBhcmUgYWx3YXlzIHF1aXRlIHN1cnByaXNlZCBhdCBob3cgdGhlIGNvdW50cnkgaXMgYW5kIHRoZSBkaWZmZXJlbmNlIG9uIGhvdyB0aGUgbWVkaWEgcG9ydHJheXMgaXQuIiwiZnJvbSI6eyJ1c2VybmFtZSI6InlvdW5ncGlvbmVlciIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzMyODc5MTQ1NF83NXNxXzEzOTU1MDI4MDAuanBnIiwiaWQiOiIzMjg3OTE0NTQiLCJmdWxsX25hbWUiOiJZb3VuZ1Bpb25lZXJUb3VycyJ9LCJpZCI6IjcxOTczMTg5Nzg0NDA0MzU1MSJ9XX0sImZpbHRlciI6Ik5vcm1hbCIsImNyZWF0ZWRfdGltZSI6IjEzOTk5NTc5MjIiLCJsaW5rIjoiaHR0cDovL2luc3RhZ3JhbS5jb20vcC9uN01FVDdBd194LyIsImxpa2VzIjp7ImNvdW50Ijo0ODg3LCJkYXRhIjpbeyJ1c2VybmFtZSI6Iml0c3ZhbmVzc2FsdmVzIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMzI0NzE3NjAxXzc1c3FfMTM5NTUwMTg5My5qcGciLCJpZCI6IjMyNDcxNzYwMSIsImZ1bGxfbmFtZSI6IlZhbmVzc2EifSx7InVzZXJuYW1lIjoibWF4aW1heGltYXhpbSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzk3ODg0Xzc1c3FfMTMzMjQ4NzM0NS5qcGciLCJpZCI6Ijk3ODg0IiwiZnVsbF9uYW1lIjoibWF4aW1heGltYXhpbSJ9LHsidXNlcm5hbWUiOiJ0aHNldmxpZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzE3NjU2NDc2NF83NXNxXzEzNzUzMTEzNDguanBnIiwiaWQiOiIxNzY1NjQ3NjQiLCJmdWxsX25hbWUiOiJ0aHNldmxpZSJ9LHsidXNlcm5hbWUiOiJja2pvc3ZvbGQiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8yMDI4NTgwNTVfNzVzcV8xMzk4MDA5ODY4LmpwZyIsImlkIjoiMjAyODU4MDU1IiwiZnVsbF9uYW1lIjoiY2tqb3N2b2xkIn1dfSwiaW1hZ2VzIjp7Imxvd19yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1hc2guZmJjZG4ubmV0LzEwMzI2NTk0XzE0MDQ4NTI5NzMxMjk5NTlfMTc1ODUzODEyNV9hLmpwZyIsIndpZHRoIjozMDYsImhlaWdodCI6MzA2fSwidGh1bWJuYWlsIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1hc2guZmJjZG4ubmV0LzEwMzI2NTk0XzE0MDQ4NTI5NzMxMjk5NTlfMTc1ODUzODEyNV9zLmpwZyIsIndpZHRoIjoxNTAsImhlaWdodCI6MTUwfSwic3RhbmRhcmRfcmVzb2x1dGlvbiI6eyJ1cmwiOiJodHRwOi8vb3JpZ2luY2FjaGUtYXNoLmZiY2RuLm5ldC8xMDMyNjU5NF8xNDA0ODUyOTczMTI5OTU5XzE3NTg1MzgxMjVfbi5qcGciLCJ3aWR0aCI6NjQwLCJoZWlnaHQiOjY0MH19LCJ1c2Vyc19pbl9waG90byI6W10sImNhcHRpb24iOnsiY3JlYXRlZF90aW1lIjoiMTM5OTk1NzkyMiIsInRleHQiOiJJbiB0aGUgS29yeW8gSG90ZWwgdGhlcmUgaXMgYSBzdHlyb2ZvYW0gbW9kZWwgb2YgdGhlIEtvcnlvIEhvdGVsLiBXaXRoIGEgcmFpbmJvdy4gI25rb3JlYSIsImZyb20iOnsidXNlcm5hbWUiOiJkZ3V0dGVuZmVsZGVyIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMjk0NDAxOTRfNzVzcV8xMzg2NjY4NjA5LmpwZyIsImlkIjoiMjk0NDAxOTQiLCJmdWxsX25hbWUiOiJEYXZpZCBHdXR0ZW5mZWxkZXIifSwiaWQiOiI3MTkyMjE2Mzg2MzMyOTU4MzgifSwidXNlcl9oYXNfbGlrZWQiOmZhbHNlLCJpZCI6IjcxOTIyMTYzODMyMjkxNzM2MV8yOTQ0MDE5NCIsInVzZXIiOnsidXNlcm5hbWUiOiJkZ3V0dGVuZmVsZGVyIiwid2Vic2l0ZSI6IiIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzI5NDQwMTk0Xzc1c3FfMTM4NjY2ODYwOS5qcGciLCJmdWxsX25hbWUiOiJEYXZpZCBHdXR0ZW5mZWxkZXIiLCJiaW8iOiIiLCJpZCI6IjI5NDQwMTk0In19LHsiYXR0cmlidXRpb24iOm51bGwsInRhZ3MiOltdLCJ0eXBlIjoiaW1hZ2UiLCJsb2NhdGlvbiI6bnVsbCwiY29tbWVudHMiOnsiY291bnQiOjEsImRhdGEiOlt7ImNyZWF0ZWRfdGltZSI6IjEzOTk5NzY3NDkiLCJ0ZXh0IjoiSGVsbyIsImZyb20iOnsidXNlcm5hbWUiOiJzYWVlZHN6bSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9hbm9ueW1vdXNVc2VyLmpwZyIsImlkIjoiMTMyODA3NzE3NCIsImZ1bGxfbmFtZSI6InNhZWVkIn0sImlkIjoiNzE5Mzc5NTcwMTg1MzY1OTA3In1dfSwiZmlsdGVyIjoiTm9ybWFsIiwiY3JlYXRlZF90aW1lIjoiMTM5OTk1Mzg1NSIsImxpbmsiOiJodHRwOi8vaW5zdGFncmFtLmNvbS9wL243RVQza0VtbGovIiwibGlrZXMiOnsiY291bnQiOjEyLCJkYXRhIjpbeyJ1c2VybmFtZSI6InBoaWxpcGFuZGVyc29uZWRzZWwiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8zNzA1ODYxNTJfNzVzcV8xMzk5NTAzOTYyLmpwZyIsImlkIjoiMzcwNTg2MTUyIiwiZnVsbF9uYW1lIjoiUGhpbGlwIEFuZGVyc29uIEVkc2VsIn0seyJ1c2VybmFtZSI6InNjaHdhMjMiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV82NDQ5MjJfNzVzcV8xMzk4NzExMzI0LmpwZyIsImlkIjoiNjQ0OTIyIiwiZnVsbF9uYW1lIjoiSm9zaCBEIn0seyJ1c2VybmFtZSI6InRpbWVfb3ZvIiwicHJvZmlsZV9waWN0dXJlIjoiaHR0cDovL2ltYWdlcy5hay5pbnN0YWdyYW0uY29tL3Byb2ZpbGVzL3Byb2ZpbGVfMTMyMzQ2NzA1Ml83NXNxXzEzOTk3OTY5MzAuanBnIiwiaWQiOiIxMzIzNDY3MDUyIiwiZnVsbF9uYW1lIjoi6Zuq55eVIn0seyJ1c2VybmFtZSI6InNhaGlsdXJrdW5kZSIsInByb2ZpbGVfcGljdHVyZSI6Imh0dHA6Ly9pbWFnZXMuYWsuaW5zdGFncmFtLmNvbS9wcm9maWxlcy9wcm9maWxlXzcxODkyMzIzN183NXNxXzEzOTc3NTgyMTYuanBnIiwiaWQiOiI3MTg5MjMyMzciLCJmdWxsX25hbWUiOiJTYWhpbCB1cmt1bmRlIn1dfSwiaW1hZ2VzIjp7Imxvd19yZXNvbHV0aW9uIjp7InVybCI6Imh0dHA6Ly9vcmlnaW5jYWNoZS1hc2guZmJjZG4ubmV0LzEwMzQ5NjgyXzI0NDQwMzc0OTA5ODg0Nl8xMTgwOTkwNTA3X2EuanBnIiwid2lkdGgiOjMwNiwiaGVpZ2h0IjozMDZ9LCJ0aHVtYm5haWwiOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLWFzaC5mYmNkbi5uZXQvMTAzNDk2ODJfMjQ0NDAzNzQ5MDk4ODQ2XzExODA5OTA1MDdfcy5qcGciLCJ3aWR0aCI6MTUwLCJoZWlnaHQiOjE1MH0sInN0YW5kYXJkX3Jlc29sdXRpb24iOnsidXJsIjoiaHR0cDovL29yaWdpbmNhY2hlLWFzaC5mYmNkbi5uZXQvMTAzNDk2ODJfMjQ0NDAzNzQ5MDk4ODQ2XzExODA5OTA1MDdfbi5qcGciLCJ3aWR0aCI6NjQwLCJoZWlnaHQiOjY0MH19LCJ1c2Vyc19pbl9waG90byI6W10sImNhcHRpb24iOnsiY3JlYXRlZF90aW1lIjoiMTM5OTk1Mzg1NSIsInRleHQiOiJNb25kYXkgbmlnaHQgYmFsbCBnYW1lIOKavu+4j+Kavu+4j+Kavu+4jyIsImZyb20iOnsidXNlcm5hbWUiOiJqYW5leW1hcnkiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xNzcyODYxNzdfNzVzcV8xMzcxNzU4MTA2LmpwZyIsImlkIjoiMTc3Mjg2MTc3IiwiZnVsbF9uYW1lIjoiamFuZXltYXJ5In0sImlkIjoiNzE5MTg3NTIzMjg5NjM5MDcwIn0sInVzZXJfaGFzX2xpa2VkIjpmYWxzZSwiaWQiOiI3MTkxODc1MjMwMTI4MTUyMDNfMTc3Mjg2MTc3IiwidXNlciI6eyJ1c2VybmFtZSI6ImphbmV5bWFyeSIsIndlYnNpdGUiOiIiLCJwcm9maWxlX3BpY3R1cmUiOiJodHRwOi8vaW1hZ2VzLmFrLmluc3RhZ3JhbS5jb20vcHJvZmlsZXMvcHJvZmlsZV8xNzcyODYxNzdfNzVzcV8xMzcxNzU4MTA2LmpwZyIsImZ1bGxfbmFtZSI6ImphbmV5bWFyeSIsImJpbyI6IiIsImlkIjoiMTc3Mjg2MTc3In19XX0K
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000..3c7abdf
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000..7bdc062
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Fri May 30 12:56:54 PDT 2014
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=http\://services.gradle.org/distributions/gradle-1.11-bin.zip
diff --git a/gradlew b/gradlew
new file mode 100644
index 0000000..91a7e26
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 0000000..aec9973
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/javawriter/build.gradle b/javawriter/build.gradle
new file mode 100644
index 0000000..544652f
--- /dev/null
+++ b/javawriter/build.gradle
@@ -0,0 +1,5 @@
+apply plugin: 'java'
+
+repositories {
+  mavenCentral()
+}
diff --git a/javawriter/src/main/java/com/squareup/javawriter/JavaWriter.java b/javawriter/src/main/java/com/squareup/javawriter/JavaWriter.java
new file mode 100644
index 0000000..1b2dc5b
--- /dev/null
+++ b/javawriter/src/main/java/com/squareup/javawriter/JavaWriter.java
@@ -0,0 +1,856 @@
+// Copyright 2013 Square, Inc.
+package com.squareup.javawriter;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.Writer;
+import java.lang.annotation.Annotation;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.EnumSet;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.lang.model.element.Modifier;
+
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+/** A utility class which aids in generating Java source files. */
+public class JavaWriter implements Closeable {
+  public interface JavaGenerator {
+    public void emitJava(JavaWriter writer) throws IOException;
+  }
+
+  private static final Pattern TYPE_PATTERN = Pattern.compile("(?:[\\w$]+\\.)*([\\w\\.*$]+)");
+  private static final int MAX_SINGLE_LINE_ATTRIBUTES = 3;
+  private static final String INDENT = "  ";
+
+  /** Map fully qualified type names to their short names. */
+  private final Map<String, String> importedTypes = new LinkedHashMap<String, String>();
+
+  private String packagePrefix;
+  private final Deque<Scope> scopes = new ArrayDeque<Scope>();
+  private final Deque<String> types = new ArrayDeque<String>();
+  private final Writer out;
+  private boolean isCompressingTypes = true;
+  private String indent = INDENT;
+
+  /**
+   * @param out the stream to which Java source will be written. This should be a buffered stream.
+   */
+  public JavaWriter(Writer out) {
+    this.out = out;
+  }
+
+  public void setCompressingTypes(boolean isCompressingTypes) {
+    this.isCompressingTypes = isCompressingTypes;
+  }
+
+  public boolean isCompressingTypes() {
+    return isCompressingTypes;
+  }
+
+  public void setIndent(String indent) {
+    this.indent = indent;
+  }
+
+  public String getIndent() {
+    return indent;
+  }
+
+  public JavaWriter emitWithGenerator(JavaGenerator generator) throws IOException {
+    generator.emitJava(this);
+    return this;
+  }
+
+  /** Emit a package declaration and empty line. */
+  public JavaWriter emitPackage(String packageName) throws IOException {
+    if (this.packagePrefix != null) {
+      throw new IllegalStateException();
+    }
+    if (packageName.isEmpty()) {
+      this.packagePrefix = "";
+    } else {
+      out.write("package ");
+      out.write(packageName);
+      out.write(";\n\n");
+      this.packagePrefix = packageName + ".";
+    }
+    return this;
+  }
+
+  /**
+   * Emit an import for each {@code type} provided. For the duration of the file, all references to
+   * these classes will be automatically shortened.
+   */
+  public JavaWriter emitImports(String... types) throws IOException {
+    return emitImports(Arrays.asList(types));
+  }
+
+  /**
+   * Emit an import for each {@code type} provided. For the duration of the file, all references to
+   * these classes will be automatically shortened.
+   */
+  public JavaWriter emitImports(Class<?>... types) throws IOException {
+    List<String> classNames = new ArrayList<String>(types.length);
+    for (Class<?> classToImport : types) {
+      classNames.add(classToImport.getName());
+    }
+    return emitImports(classNames);
+  }
+
+  /**
+   * Emit an import for each {@code type} in the provided {@code Collection}. For the duration of
+   * the file, all references to these classes will be automatically shortened.
+   */
+  public JavaWriter emitImports(Collection<String> types) throws IOException {
+    for (String type : new TreeSet<String>(types)) {
+      Matcher matcher = TYPE_PATTERN.matcher(type);
+      if (!matcher.matches()) {
+        throw new IllegalArgumentException(type);
+      }
+      if (importedTypes.put(type, matcher.group(1)) != null) {
+        throw new IllegalArgumentException(type);
+      }
+      out.write("import ");
+      out.write(type);
+      out.write(";\n");
+    }
+    return this;
+  }
+
+  /**
+   * Emit a static import for each {@code type} provided. For the duration of the file,
+   * all references to these classes will be automatically shortened.
+   */
+  public JavaWriter emitStaticImports(String... types) throws IOException {
+    return emitStaticImports(Arrays.asList(types));
+  }
+
+  /**
+   * Emit a static import for each {@code type} in the provided {@code Collection}. For the
+   * duration of the file, all references to these classes will be automatically shortened.
+   */
+  public JavaWriter emitStaticImports(Collection<String> types) throws IOException {
+    for (String type : new TreeSet<String>(types)) {
+      Matcher matcher = TYPE_PATTERN.matcher(type);
+      if (!matcher.matches()) {
+        throw new IllegalArgumentException(type);
+      }
+      if (importedTypes.put(type, matcher.group(1)) != null) {
+        throw new IllegalArgumentException(type);
+      }
+      out.write("import static ");
+      out.write(type);
+      out.write(";\n");
+    }
+    return this;
+  }
+
+  /**
+   * Emits a name like {@code java.lang.String} or {@code java.util.List<java.lang.String>},
+   * compressing it with imports if possible. Type compression will only be enabled if
+   * {@link #isCompressingTypes} is true.
+   */
+  private JavaWriter emitCompressedType(String type) throws IOException {
+    if (isCompressingTypes) {
+      out.write(compressType(type));
+    } else {
+      out.write(type);
+    }
+    return this;
+  }
+
+  /** Try to compress a fully-qualified class name to only the class name. */
+  public String compressType(String type) {
+    StringBuilder sb = new StringBuilder();
+    if (this.packagePrefix == null) {
+      throw new IllegalStateException();
+    }
+
+    Matcher m = TYPE_PATTERN.matcher(type);
+    int pos = 0;
+    while (true) {
+      boolean found = m.find(pos);
+
+      // Copy non-matching characters like "<".
+      int typeStart = found ? m.start() : type.length();
+      sb.append(type, pos, typeStart);
+
+      if (!found) {
+        break;
+      }
+
+      // Copy a single class name, shortening it if possible.
+      String name = m.group(0);
+      String imported = importedTypes.get(name);
+      if (imported != null) {
+        sb.append(imported);
+      } else if (isClassInPackage(name, packagePrefix)) {
+        String compressed = name.substring(packagePrefix.length());
+        if (isAmbiguous(compressed)) {
+          sb.append(name);
+        } else {
+          sb.append(compressed);
+        }
+      } else if (isClassInPackage(name, "java.lang.")) {
+        sb.append(name.substring("java.lang.".length()));
+      } else {
+        sb.append(name);
+      }
+      pos = m.end();
+    }
+    return sb.toString();
+  }
+
+  private static boolean isClassInPackage(String name, String packagePrefix) {
+    if (name.startsWith(packagePrefix)) {
+      if (name.indexOf('.', packagePrefix.length()) == -1) {
+        return true;
+      }
+      // check to see if the part after the package looks like a class
+      if (Character.isUpperCase(name.charAt(packagePrefix.length()))) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Returns true if the imports contain a class with same simple name as {@code compressed}.
+   *
+   * @param compressed simple name of the type
+   */
+  private boolean isAmbiguous(String compressed) {
+    return importedTypes.values().contains(compressed);
+  }
+
+  /**
+   * Emits an initializer declaration.
+   *
+   * @param isStatic true if it should be an static initializer, false for an instance initializer.
+   */
+  public JavaWriter beginInitializer(boolean isStatic) throws IOException {
+    indent();
+    if (isStatic) {
+      out.write("static");
+      out.write(" {\n");
+    } else {
+      out.write("{\n");
+    }
+    scopes.push(Scope.INITIALIZER);
+    return this;
+  }
+
+  /** Ends the current initializer declaration. */
+  public JavaWriter endInitializer() throws IOException {
+    popScope(Scope.INITIALIZER);
+    indent();
+    out.write("}\n");
+    return this;
+  }
+
+ /**
+  * Emits a type declaration.
+  *
+  * @param kind such as "class", "interface" or "enum".
+  */
+  public JavaWriter beginType(String type, String kind) throws IOException {
+    return beginType(type, kind, EnumSet.noneOf(Modifier.class), null);
+  }
+
+  /**
+   * Emits a type declaration.
+   *
+   * @param kind such as "class", "interface" or "enum".
+   */
+  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers)
+      throws IOException {
+    return beginType(type, kind, modifiers, null);
+  }
+
+  /**
+   * Emits a type declaration.
+   *
+   * @param kind such as "class", "interface" or "enum".
+   * @param extendsType the class to extend, or null for no extends clause.
+   */
+  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers, String extendsType,
+      String... implementsTypes) throws IOException {
+    indent();
+    emitModifiers(modifiers);
+    out.write(kind);
+    out.write(" ");
+    emitCompressedType(type);
+    if (extendsType != null) {
+      out.write(" extends ");
+      emitCompressedType(extendsType);
+    }
+    if (implementsTypes.length > 0) {
+      out.write("\n");
+      indent();
+      out.write("    implements ");
+      for (int i = 0; i < implementsTypes.length; i++) {
+        if (i != 0) {
+          out.write(", ");
+        }
+        emitCompressedType(implementsTypes[i]);
+      }
+    }
+    out.write(" {\n");
+    scopes.push(Scope.TYPE_DECLARATION);
+    types.push(type);
+    return this;
+  }
+
+  /** Completes the current type declaration. */
+  public JavaWriter endType() throws IOException {
+    popScope(Scope.TYPE_DECLARATION);
+    types.pop();
+    indent();
+    out.write("}\n");
+    return this;
+  }
+
+  /** Emits a field declaration. */
+  public JavaWriter emitField(String type, String name) throws IOException {
+    return emitField(type, name, EnumSet.noneOf(Modifier.class), null);
+  }
+
+  /** Emits a field declaration. */
+  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers)
+      throws IOException {
+    return emitField(type, name, modifiers, null);
+  }
+
+  /** Emits a field declaration. */
+  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers,
+      String initialValue) throws IOException {
+    indent();
+    emitModifiers(modifiers);
+    emitCompressedType(type);
+    out.write(" ");
+    out.write(name);
+
+    if (initialValue != null) {
+      out.write(" = ");
+
+      String[] lines = initialValue.split("\n", -1);
+      out.write(lines[0]);
+      for (int i = 1; i < lines.length; i++) {
+        out.write("\n");
+        hangingIndent();
+        out.write(lines[i]);
+      }
+    }
+    out.write(";\n");
+    return this;
+  }
+
+  /**
+   * Emit a method declaration.
+   *
+   * <p>A {@code null} return type may be used to indicate a constructor, but
+   * {@link #beginConstructor(Set, String...)} should be preferred. This behavior may be removed in
+   * a future release.
+   *
+   * @param returnType the method's return type, or null for constructors
+   * @param name the method name, or the fully qualified class name for constructors.
+   * @param modifiers the set of modifiers to be applied to the method
+   * @param parameters alternating parameter types and names.
+   */
+  public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers,
+      String... parameters) throws IOException {
+    return beginMethod(returnType, name, modifiers, Arrays.asList(parameters), null);
+  }
+
+  /**
+   * Emit a method declaration.
+   *
+   * <p>A {@code null} return type may be used to indicate a constructor, but
+   * {@link #beginConstructor(Set, List, List)} should be preferred. This behavior may be removed in
+   * a future release.
+   *
+   * @param returnType the method's return type, or null for constructors.
+   * @param name the method name, or the fully qualified class name for constructors.
+   * @param modifiers the set of modifiers to be applied to the method
+   * @param parameters alternating parameter types and names.
+   * @param throwsTypes the classes to throw, or null for no throws clause.
+   */
+  public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers,
+      List<String> parameters, List<String> throwsTypes) throws IOException {
+    indent();
+    emitModifiers(modifiers);
+    if (returnType != null) {
+      emitCompressedType(returnType);
+      out.write(" ");
+      out.write(name);
+    } else {
+      emitCompressedType(name);
+    }
+    out.write("(");
+    if (parameters != null) {
+      for (int p = 0; p < parameters.size();) {
+        if (p != 0) {
+          out.write(", ");
+        }
+        emitCompressedType(parameters.get(p++));
+        out.write(" ");
+        emitCompressedType(parameters.get(p++));
+      }
+    }
+    out.write(")");
+    if (throwsTypes != null && throwsTypes.size() > 0) {
+      out.write("\n");
+      indent();
+      out.write("    throws ");
+      for (int i = 0; i < throwsTypes.size(); i++) {
+        if (i != 0) {
+          out.write(", ");
+        }
+        emitCompressedType(throwsTypes.get(i));
+      }
+    }
+    if (modifiers.contains(ABSTRACT)) {
+      out.write(";\n");
+      scopes.push(Scope.ABSTRACT_METHOD);
+    } else {
+      out.write(" {\n");
+      scopes.push(returnType == null ? Scope.CONSTRUCTOR : Scope.NON_ABSTRACT_METHOD);
+    }
+    return this;
+  }
+
+  public JavaWriter beginConstructor(Set<Modifier> modifiers, String... parameters)
+      throws IOException {
+    beginMethod(null, types.peekFirst(), modifiers, parameters);
+    return this;
+  }
+
+  public JavaWriter beginConstructor(Set<Modifier> modifiers,
+      List<String> parameters, List<String> throwsTypes)
+      throws IOException {
+    beginMethod(null, types.peekFirst(), modifiers, parameters, throwsTypes);
+    return this;
+  }
+
+  /** Emits some Javadoc comments with line separated by {@code \n}. */
+  public JavaWriter emitJavadoc(String javadoc, Object... params) throws IOException {
+    String formatted = String.format(javadoc, params);
+
+    indent();
+    out.write("/**\n");
+    for (String line : formatted.split("\n")) {
+      indent();
+      out.write(" *");
+      if (!line.isEmpty()) {
+        out.write(" ");
+        out.write(line);
+      }
+      out.write("\n");
+    }
+    indent();
+    out.write(" */\n");
+    return this;
+  }
+
+  /** Emits a single line comment. */
+  public JavaWriter emitSingleLineComment(String comment, Object... args) throws IOException {
+    indent();
+    out.write("// ");
+    out.write(String.format(comment, args));
+    out.write("\n");
+    return this;
+  }
+
+  public JavaWriter emitEmptyLine() throws IOException {
+    out.write("\n");
+    return this;
+  }
+
+  public JavaWriter emitEnumValue(String name) throws IOException {
+    indent();
+    out.write(name);
+    out.write(",\n");
+    return this;
+  }
+
+  /**
+   * A simple switch to emit the proper enum depending if its last causing it to be terminated
+   * by a semi-colon ({@code ;}).
+   */
+  public JavaWriter emitEnumValue(String name, boolean isLast) throws IOException {
+    return isLast ? emitLastEnumValue(name) : emitEnumValue(name);
+  }
+
+  private JavaWriter emitLastEnumValue(String name) throws IOException {
+    indent();
+    out.write(name);
+    out.write(";\n");
+    return this;
+  }
+
+  /** Emit a list of enum values followed by a semi-colon ({@code ;}). */
+  public JavaWriter emitEnumValues(Iterable<String> names) throws IOException {
+    Iterator<String> iterator = names.iterator();
+
+    while (iterator.hasNext()) {
+      String name = iterator.next();
+      if (iterator.hasNext()) {
+        emitEnumValue(name);
+      } else {
+        emitLastEnumValue(name);
+      }
+    }
+
+    return this;
+  }
+
+  /** Equivalent to {@code annotation(annotation, emptyMap())}. */
+  public JavaWriter emitAnnotation(String annotation) throws IOException {
+    return emitAnnotation(annotation, Collections.<String, Object>emptyMap());
+  }
+
+  /** Equivalent to {@code annotation(annotationType.getName(), emptyMap())}. */
+  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType) throws IOException {
+    return emitAnnotation(type(annotationType), Collections.<String, Object>emptyMap());
+  }
+
+  /**
+   * Annotates the next element with {@code annotationType} and a {@code value}.
+   *
+   * @param value an object used as the default (value) parameter of the annotation. The value will
+   *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object
+   *     arrays are written one element per line.
+   */
+  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType, Object value)
+      throws IOException {
+    return emitAnnotation(type(annotationType), value);
+  }
+
+  /**
+   * Annotates the next element with {@code annotation} and a {@code value}.
+   *
+   * @param value an object used as the default (value) parameter of the annotation. The value will
+   *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object
+   *     arrays are written one element per line.
+   */
+  public JavaWriter emitAnnotation(String annotation, Object value) throws IOException {
+    indent();
+    out.write("@");
+    emitCompressedType(annotation);
+    out.write("(");
+    emitAnnotationValue(value);
+    out.write(")");
+    out.write("\n");
+    return this;
+  }
+
+  /** Equivalent to {@code annotation(annotationType.getName(), attributes)}. */
+  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType,
+      Map<String, ?> attributes) throws IOException {
+    return emitAnnotation(type(annotationType), attributes);
+  }
+
+  /**
+   * Annotates the next element with {@code annotation} and {@code attributes}.
+   *
+   * @param attributes a map from annotation attribute names to their values. Values are encoded
+   *     using Object.toString(); use {@link #stringLiteral} for String values. Object arrays are
+   *     written one element per line.
+   */
+  public JavaWriter emitAnnotation(String annotation, Map<String, ?> attributes)
+      throws IOException {
+    indent();
+    out.write("@");
+    emitCompressedType(annotation);
+    switch (attributes.size()) {
+      case 0:
+        break;
+      case 1:
+        Entry<String, ?> onlyEntry = attributes.entrySet().iterator().next();
+        out.write("(");
+        if (!"value".equals(onlyEntry.getKey())) {
+          out.write(onlyEntry.getKey());
+          out.write(" = ");
+        }
+        emitAnnotationValue(onlyEntry.getValue());
+        out.write(")");
+        break;
+      default:
+        boolean split = attributes.size() > MAX_SINGLE_LINE_ATTRIBUTES
+            || containsArray(attributes.values());
+        out.write("(");
+        scopes.push(Scope.ANNOTATION_ATTRIBUTE);
+        String separator = split ? "\n" : "";
+        for (Map.Entry<String, ?> entry : attributes.entrySet()) {
+          out.write(separator);
+          separator = split ? ",\n" : ", ";
+          if (split) {
+            indent();
+          }
+          out.write(entry.getKey());
+          out.write(" = ");
+          Object value = entry.getValue();
+          emitAnnotationValue(value);
+        }
+        popScope(Scope.ANNOTATION_ATTRIBUTE);
+        if (split) {
+          out.write("\n");
+          indent();
+        }
+        out.write(")");
+        break;
+    }
+    out.write("\n");
+    return this;
+  }
+
+  private boolean containsArray(Collection<?> values) {
+    for (Object value : values) {
+      if (value instanceof Object[]) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Writes a single annotation value. If the value is an array, each element in the array will be
+   * written to its own line.
+   */
+  private JavaWriter emitAnnotationValue(Object value) throws IOException {
+    if (value instanceof Object[]) {
+      out.write("{");
+      boolean firstValue = true;
+      scopes.push(Scope.ANNOTATION_ARRAY_VALUE);
+      for (Object o : ((Object[]) value)) {
+        if (firstValue) {
+          firstValue = false;
+          out.write("\n");
+        } else {
+          out.write(",\n");
+        }
+        indent();
+        out.write(o.toString());
+      }
+      popScope(Scope.ANNOTATION_ARRAY_VALUE);
+      out.write("\n");
+      indent();
+      out.write("}");
+    } else {
+      out.write(value.toString());
+    }
+    return this;
+  }
+
+  /**
+   * @param pattern a code pattern like "int i = %s". Newlines will be further indented. Should not
+   *     contain trailing semicolon.
+   */
+  public JavaWriter emitStatement(String pattern, Object... args) throws IOException {
+    checkInMethod();
+    String[] lines = String.format(pattern, args).split("\n", -1);
+    indent();
+    out.write(lines[0]);
+    for (int i = 1; i < lines.length; i++) {
+      out.write("\n");
+      hangingIndent();
+      out.write(lines[i]);
+    }
+    out.write(";\n");
+    return this;
+  }
+
+  /**
+   * @param controlFlow the control flow construct and its code, such as "if (foo == 5)". Shouldn't
+   *     contain braces or newline characters.
+   */
+  public JavaWriter beginControlFlow(String controlFlow) throws IOException {
+    checkInMethod();
+    indent();
+    out.write(controlFlow);
+    out.write(" {\n");
+    scopes.push(Scope.CONTROL_FLOW);
+    return this;
+  }
+
+  /**
+   * @param controlFlow the control flow construct and its code, such as "else if (foo == 10)".
+   *     Shouldn't contain braces or newline characters.
+   */
+  public JavaWriter nextControlFlow(String controlFlow) throws IOException {
+    popScope(Scope.CONTROL_FLOW);
+    indent();
+    scopes.push(Scope.CONTROL_FLOW);
+    out.write("} ");
+    out.write(controlFlow);
+    out.write(" {\n");
+    return this;
+  }
+
+  public JavaWriter endControlFlow() throws IOException {
+    return endControlFlow(null);
+  }
+
+  /**
+   * @param controlFlow the optional control flow construct and its code, such as
+   *     "while(foo == 20)". Only used for "do/while" control flows.
+   */
+  public JavaWriter endControlFlow(String controlFlow) throws IOException {
+    popScope(Scope.CONTROL_FLOW);
+    indent();
+    if (controlFlow != null) {
+      out.write("} ");
+      out.write(controlFlow);
+      out.write(";\n");
+    } else {
+      out.write("}\n");
+    }
+    return this;
+  }
+
+  /** Completes the current method declaration. */
+  public JavaWriter endMethod() throws IOException {
+    Scope popped = scopes.pop();
+    // support calling a constructor a "method" to support the legacy code
+    if (popped == Scope.NON_ABSTRACT_METHOD || popped == Scope.CONSTRUCTOR) {
+      indent();
+      out.write("}\n");
+    } else if (popped != Scope.ABSTRACT_METHOD) {
+      throw new IllegalStateException();
+    }
+    return this;
+  }
+
+  /** Completes the current constructor declaration. */
+  public JavaWriter endConstructor() throws IOException {
+    popScope(Scope.CONSTRUCTOR);
+    indent();
+    out.write("}\n");
+    return this;
+  }
+
+  /** Returns the string literal representing {@code data}, including wrapping quotes. */
+  public static String stringLiteral(String data) {
+    StringBuilder result = new StringBuilder();
+    result.append('"');
+    for (int i = 0; i < data.length(); i++) {
+      char c = data.charAt(i);
+      switch (c) {
+        case '"':
+          result.append("\\\"");
+          break;
+        case '\\':
+          result.append("\\\\");
+          break;
+        case '\b':
+          result.append("\\b");
+          break;
+        case '\t':
+          result.append("\\t");
+          break;
+        case '\n':
+          result.append("\\n");
+          break;
+        case '\f':
+          result.append("\\f");
+          break;
+        case '\r':
+          result.append("\\r");
+          break;
+        default:
+          if (Character.isISOControl(c)) {
+            result.append(String.format("\\u%04x", (int) c));
+          } else {
+            result.append(c);
+          }
+      }
+    }
+    result.append('"');
+    return result.toString();
+  }
+
+  /** Build a string representation of a type and optionally its generic type arguments. */
+  public static String type(Class<?> raw, String... parameters) {
+    if (parameters.length == 0) {
+      return raw.getCanonicalName();
+    }
+    if (raw.getTypeParameters().length != parameters.length) {
+      throw new IllegalArgumentException();
+    }
+    StringBuilder result = new StringBuilder();
+    result.append(raw.getCanonicalName());
+    result.append("<");
+    result.append(parameters[0]);
+    for (int i = 1; i < parameters.length; i++) {
+      result.append(", ");
+      result.append(parameters[i]);
+    }
+    result.append(">");
+    return result.toString();
+  }
+
+  @Override public void close() throws IOException {
+    out.close();
+  }
+
+  /** Emits the modifiers to the writer. */
+  private void emitModifiers(Set<Modifier> modifiers) throws IOException {
+    // Use an EnumSet to ensure the proper ordering
+    if (!(modifiers instanceof EnumSet)) {
+      modifiers = EnumSet.copyOf(modifiers);
+    }
+    for (Modifier modifier : modifiers) {
+      out.append(modifier.toString()).append(' ');
+    }
+  }
+
+  private void indent() throws IOException {
+    for (int i = 0, count = scopes.size(); i < count; i++) {
+      out.write(indent);
+    }
+  }
+
+  private void hangingIndent() throws IOException {
+    for (int i = 0, count = scopes.size() + 2; i < count; i++) {
+      out.write(indent);
+    }
+  }
+
+  private static final EnumSet<Scope> METHOD_SCOPES = EnumSet.of(
+      Scope.NON_ABSTRACT_METHOD, Scope.CONSTRUCTOR, Scope.CONTROL_FLOW, Scope.INITIALIZER);
+
+  private void checkInMethod() {
+    if (!METHOD_SCOPES.contains(scopes.peekFirst())) {
+      throw new IllegalArgumentException();
+    }
+  }
+
+  private void popScope(Scope expected) {
+    if (scopes.pop() != expected) {
+      throw new IllegalStateException();
+    }
+  }
+
+  private enum Scope {
+    TYPE_DECLARATION,
+    ABSTRACT_METHOD,
+    NON_ABSTRACT_METHOD,
+    CONSTRUCTOR,
+    CONTROL_FLOW,
+    ANNOTATION_ATTRIBUTE,
+    ANNOTATION_ARRAY_VALUE,
+    INITIALIZER
+  }
+}
diff --git a/processor/build.gradle b/processor/build.gradle
new file mode 100644
index 0000000..0d32f54
--- /dev/null
+++ b/processor/build.gradle
@@ -0,0 +1,16 @@
+apply plugin: 'java'
+
+repositories {
+  mavenCentral()
+}
+
+dependencies {
+  compile group: 'org.apache.commons', name: 'commons-lang3', version: '3.1+'
+  compile project(':javawriter')
+  compile project(':util')
+  compile project(':common')
+  testCompile group: 'junit', name: 'junit', version: '4.8.2+'
+  testCompile project(':processor:support')
+  testCompile project(':processor:testuut')
+  testCompile project(':processor:testuut:dependent')
+}
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonAnnotationProcessor.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonAnnotationProcessor.java
new file mode 100644
index 0000000..bafe6e9
--- /dev/null
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonAnnotationProcessor.java
@@ -0,0 +1,313 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.JavaFileObject;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.lang.annotation.Annotation;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import com.instagram.common.json.JsonAnnotationProcessorConstants;
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+import com.instagram.common.json.annotation.util.Console;
+import com.instagram.common.json.annotation.util.ProcessorClassData;
+import com.instagram.common.json.annotation.util.TypeUtils;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.Maps;
+
+import static javax.lang.model.element.ElementKind.CLASS;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+/**
+ * This annotation processor is run at compile time to find classes annotated with {@link JsonType}.
+ * Deserializers are generated for such classes.
+ */
+public class JsonAnnotationProcessor extends AbstractProcessor {
+  private Messager mMessager;
+  private Elements mElements;
+  private Types mTypes;
+  private Filer mFiler;
+  private TypeUtils mTypeUtils;
+  private static class State {
+    private Map<TypeElement, JsonParserClassData> mClassElementToInjectorMap;
+
+    State() {
+      mClassElementToInjectorMap = Maps.newHashMap();
+    }
+  }
+  private State mState;
+
+  @Override
+  public synchronized void init(ProcessingEnvironment env) {
+    super.init(env);
+
+    mMessager = env.getMessager();
+    mElements = env.getElementUtils();
+    mTypes = env.getTypeUtils();
+    mFiler = env.getFiler();
+    mTypeUtils = new TypeUtils(mTypes, mMessager);
+  }
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    Set<String> supportTypes = new LinkedHashSet<String>();
+    supportTypes.add(JsonField.class.getCanonicalName());
+    supportTypes.add(JsonType.class.getCanonicalName());
+
+    return supportTypes;
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
+    try {
+      // each round of processing requires a clean state.
+      mState = new State();
+
+      gatherClassAnnotations(env);
+      gatherFieldAnnotations(env);
+
+      for (Map.Entry<TypeElement, JsonParserClassData> entry :
+          mState.mClassElementToInjectorMap.entrySet()) {
+        TypeElement typeElement = entry.getKey();
+        JsonParserClassData injector = entry.getValue();
+
+        try {
+          JavaFileObject jfo = mFiler.createSourceFile(injector.getInjectedFqcn(), typeElement);
+          Writer writer = jfo.openWriter();
+          writer.write(injector.getJavaCode(processingEnv.getMessager()));
+          writer.flush();
+          writer.close();
+        } catch (IOException e) {
+          error(typeElement,
+              "Unable to write injector for type %s: %s", typeElement, e.getMessage());
+        }
+      }
+
+      return true;
+    } catch (Throwable ex) {
+      StringWriter sw = new StringWriter();
+      ex.printStackTrace(new PrintWriter(sw));
+      error("annotation exception: %s cause: %s", ex.toString(), sw.toString());
+      return false;
+    }
+  }
+
+  /**
+   * This finds the classes that are annotated with {@link JsonType}.
+   */
+  private void gatherClassAnnotations(RoundEnvironment env) {
+    // Process each @TypeTesting elements.
+    for (Element element : env.getElementsAnnotatedWith(JsonType.class)) {
+      try {
+        processClassAnnotation(element);
+      } catch (Exception e) {
+        StringWriter stackTrace = new StringWriter();
+        e.printStackTrace(new PrintWriter(stackTrace));
+
+        error(element, "Unable to generate injector for @JsonType.\n\n%s",
+            stackTrace.toString());
+      }
+    }
+  }
+
+  /**
+   * This processes a single class that is annotated with {@link JsonType}.  It verifies that the
+   * class is public and creates an {@link ProcessorClassData} for it.
+   */
+  private void processClassAnnotation(Element element) {
+    TypeElement typeElement = (TypeElement) element;
+
+    // Verify containing class visibility is not private.
+    if (element.getModifiers().contains(PRIVATE)) {
+      error(element, "@%s %s may not be applied to private classes. (%s.%s)",
+          JsonType.class.getSimpleName(), typeElement.getQualifiedName(),
+          element.getSimpleName());
+      return;
+    }
+
+    JsonParserClassData injector = mState.mClassElementToInjectorMap.get(typeElement);
+    if (injector == null) {
+      JsonType annotation = element.getAnnotation(JsonType.class);
+
+      String parentGeneratedClassName = null;
+
+      TypeMirror superclass = typeElement.getSuperclass();
+      // walk up the superclass hierarchy until we find another class we know about.
+      while (superclass.getKind() != TypeKind.NONE) {
+        TypeElement superclassElement = (TypeElement) mTypes.asElement(superclass);
+
+        if (superclassElement.getAnnotation(JsonType.class) != null) {
+          String superclassPackageName = mTypeUtils.getPackageName(mElements, superclassElement);
+          parentGeneratedClassName = superclassPackageName + "." +
+              mTypeUtils.getPrefixForGeneratedClass(superclassElement, superclassPackageName) +
+              JsonAnnotationProcessorConstants.HELPER_CLASS_SUFFIX;
+
+          break;
+        }
+
+        superclass = superclassElement.getSuperclass();
+      }
+
+      String packageName = mTypeUtils.getPackageName(mElements, typeElement);
+      injector = new JsonParserClassData(
+          packageName,
+          typeElement.getQualifiedName().toString(),
+          mTypeUtils.getPrefixForGeneratedClass(typeElement, packageName) +
+              JsonAnnotationProcessorConstants.HELPER_CLASS_SUFFIX,
+          new ProcessorClassData.AnnotationRecordFactory<String, TypeData>() {
+
+            @Override
+            public TypeData createAnnotationRecord(String key) {
+              return new TypeData();
+            }
+          },
+          annotation.postprocessingEnabled(),
+          parentGeneratedClassName);
+      mState.mClassElementToInjectorMap.put(typeElement, injector);
+    }
+  }
+
+  /**
+   * This finds the fields that are annotated with {@link JsonField}.
+   */
+  private void gatherFieldAnnotations(RoundEnvironment env) {
+    // Process each @TypeTesting elements.
+    for (Element element : env.getElementsAnnotatedWith(JsonField.class)) {
+      try {
+        processFieldAnnotation(element);
+      } catch (Exception e) {
+        StringWriter stackTrace = new StringWriter();
+        e.printStackTrace(new PrintWriter(stackTrace));
+
+        error(element, "Unable to generate view injector for @JsonField.\n\n%s",
+            stackTrace.toString());
+      }
+    }
+  }
+
+  /**
+   * This processes a single field annotated with {@link JsonField}.  It locates the enclosing
+   * class and then gathers data on the declared type of the field.
+   */
+  private void processFieldAnnotation(Element element) {
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify common generated code restrictions.
+    if (!isFieldAnnotationValid(JsonField.class, element)) {
+      return;
+    }
+
+    TypeMirror type = element.asType();
+
+    JsonParserClassData injector = mState.mClassElementToInjectorMap.get(enclosingElement);
+
+    TypeData data = injector.getOrCreateRecord(element.getSimpleName().toString());
+
+    JsonField annotation = element.getAnnotation(JsonField.class);
+
+    data.setFieldName(annotation.fieldName());
+    data.setMapping(annotation.mapping());
+    data.setValueExtractFormatter(annotation.valueExtractFormatter());
+    data.setAssignmentFormatter(annotation.fieldAssignmentFormatter());
+    data.setSerializeCodeFormatter(annotation.serializeCodeFormatter());
+
+    if (mTypeUtils.isListType(type)) {
+      // inspect the inner type.
+      data.setInCollection(true);
+      type = mTypeUtils.getListParameterizedType(type);
+    }
+
+    data.setParseType(mTypeUtils.getParseType(type, JsonType.class));
+    if (data.getParseType() == TypeUtils.ParseType.PARSABLE_OBJECT) {
+      TypeMirror erasedType = mTypes.erasure(type);
+      DeclaredType declaredType = (DeclaredType) erasedType;
+      TypeElement typeElement = (TypeElement) declaredType.asElement();
+
+      String packageName = mTypeUtils.getPackageName(mElements, typeElement);
+      String className = mTypeUtils.getClassName(typeElement, packageName);
+      String parserClassName = mTypeUtils.getPrefixForGeneratedClass(typeElement, packageName);
+
+      data.setParsableType(packageName + "." + className);
+      data.setParsableTypeParserClass(packageName + "." + parserClassName);
+    } else if (data.getParseType() == TypeUtils.ParseType.ENUM_OBJECT) {
+      // verify that we have value extract and serializer formatters.
+      if (Strings.isNullOrEmpty(annotation.valueExtractFormatter()) ||
+          Strings.isNullOrEmpty(annotation.serializeCodeFormatter())) {
+        error(element,
+            "%s: enums must have both value extract formatters and serialize code formatters",
+            enclosingElement);
+      }
+    }
+  }
+
+  private boolean isFieldAnnotationValid(
+      Class<? extends Annotation> annotationClass,
+      Element element) {
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify containing type.
+    if (enclosingElement.getKind() != CLASS) {
+      error(enclosingElement, "@%s field may only be contained in classes. (%s.%s)",
+          annotationClass.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      return false;
+    }
+
+    Annotation annotation = enclosingElement.getAnnotation(JsonType.class);
+    if (annotation == null) {
+      error(enclosingElement,
+          "@%s field may only be contained in classes annotated with @%s (%s.%s)",
+          annotationClass.getSimpleName(), JsonField.class.toString(),
+          enclosingElement.getQualifiedName(), element.getSimpleName());
+      return false;
+    }
+
+    // Verify containing class visibility is not private.
+    if (enclosingElement.getModifiers().contains(PRIVATE)) {
+      error(enclosingElement, "@%s %s may not be contained in private classes. (%s.%s)",
+          annotationClass.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      return false;
+    }
+
+    return true;
+  }
+
+  private void error(String message, Object... args) {
+    Console.error(processingEnv.getMessager(), message, args);
+  }
+
+  private void error(Element element, String message, Object... args) {
+    Console.error(processingEnv.getMessager(), element, message, args);
+  }
+
+  private void warning(String message, Object... args) {
+    Console.warning(processingEnv.getMessager(), message, args);
+  }
+}
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java
new file mode 100644
index 0000000..d6cdd5d
--- /dev/null
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java
@@ -0,0 +1,515 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import javax.annotation.processing.Messager;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.Map;
+
+import com.instagram.common.json.JsonAnnotationProcessorConstants;
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+import com.instagram.common.json.annotation.util.Console;
+import com.instagram.common.json.annotation.util.ProcessorClassData;
+import com.instagram.common.json.annotation.util.TypeUtils;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.Maps;
+import com.squareup.javawriter.JavaWriter;
+
+import static javax.lang.model.element.Modifier.*;
+
+/**
+ * This collects the data about the fields of a class, and generates the java code to parse the
+ * object.
+ */
+public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
+
+  private final boolean mPostprocessingEnabled;
+  private final String mParentInjectedClassName;
+
+  public JsonParserClassData(
+      String classPackage, String className, String injectedClassName,
+      AnnotationRecordFactory<String, TypeData> factory,
+      boolean postprocessingEnabled,
+      String parentInjectedClassName) {
+    super(classPackage, className, injectedClassName, factory);
+    mPostprocessingEnabled = postprocessingEnabled;
+    mParentInjectedClassName = parentInjectedClassName;
+  }
+
+  @Override
+  public String getJavaCode(final Messager messager) {
+    StringWriter sw = new StringWriter();
+    JavaWriter writer = new JavaWriter(sw);
+
+    try {
+      writer.emitPackage(mClassPackage);
+
+      writer.emitImports(
+          "java.io.IOException",
+          "java.io.StringWriter",
+          "java.util.ArrayList",
+          "java.util.List",
+          "com.fasterxml.jackson.core.JsonGenerator",
+          "com.fasterxml.jackson.core.JsonParser",
+          "com.fasterxml.jackson.core.JsonToken",
+          "com.instagram.common.json.JsonFactoryHolder"
+      );
+
+      writer.beginType(mInjectedClassName, "class", EnumSet.of(PUBLIC, FINAL));
+
+      String returnValue = mPostprocessingEnabled ?
+          ("instance." + JsonType.POSTPROCESSING_METHOD_NAME + "()") : "instance";
+
+      writer
+            .beginMethod(
+                mClassName,
+                "parseFromJson",
+                EnumSet.of(PUBLIC, STATIC, FINAL),
+                Arrays.asList("JsonParser", "jp"),
+                Arrays.asList("IOException"))
+              .emitStatement("%s instance = new %s()", mClassName, mClassName)
+              .emitSingleLineComment("validate that we're on the right token")
+              .beginControlFlow("if (jp.getCurrentToken() != JsonToken.START_OBJECT)")
+                .emitStatement("jp.skipChildren()")
+                .emitStatement("return null")
+              .endControlFlow()
+              .beginControlFlow("while (jp.nextToken() != JsonToken.END_OBJECT)")
+                .emitStatement("String fieldName = jp.getCurrentName()")
+                .emitStatement("jp.nextToken()")
+                .emitStatement("processSingleField(instance, fieldName, jp)")
+                // always skip children.  if we expected an array or an object, we would have
+                // consumed the START_ARRAY or START_OBJECT.  therefore, we would only skip forward
+                // if we're seeing something unexpected.
+                .emitStatement("jp.skipChildren()")
+              .endControlFlow()
+              .emitStatement("return %s", returnValue)
+            .endMethod()
+            .emitEmptyLine();
+
+      writer
+          .beginMethod(
+              "boolean",
+              "processSingleField",
+              EnumSet.of(PUBLIC, STATIC, FINAL),
+              Arrays.asList(mClassName, "instance", "String", "fieldName", "JsonParser", "jp"),
+              Arrays.asList("IOException"))
+          .emitWithGenerator(
+              new JavaWriter.JavaGenerator() {
+                @Override
+                public void emitJava(JavaWriter writer) throws IOException {
+                  JsonParserClassData.this.writeFields(messager, writer);
+
+                  // if we reached here, we need to call the superclasses processSingleField
+                  // method.
+                  if (mParentInjectedClassName != null) {
+                    writer.emitStatement("return %s.processSingleField(instance, fieldName, jp)",
+                        mParentInjectedClassName);
+                  } else {
+                    writer.emitStatement("return false");
+                  }
+                }
+              })
+          .endMethod()
+          .emitEmptyLine();
+
+      writer
+          .beginMethod(
+              mClassName,
+              "parseFromJson",
+              EnumSet.of(PUBLIC, STATIC, FINAL),
+              Arrays.asList("String", "inputString"),
+              Arrays.asList("IOException"))
+            .emitStatement(
+                "JsonParser jp = JsonFactoryHolder.APP_FACTORY.createParser(inputString)")
+            .emitStatement("jp.nextToken()")
+            .emitStatement("return parseFromJson(jp)")
+          .endMethod()
+          .emitEmptyLine();
+
+      writer
+            .beginMethod(
+                "void",
+                "serializeToJson",
+                EnumSet.of(PUBLIC, STATIC, FINAL),
+                Arrays.asList("JsonGenerator", "generator",
+                    mClassName, "object",
+                    "boolean", "writeStartAndEnd"),
+                Arrays.asList("IOException"))
+              .beginControlFlow("if (writeStartAndEnd)")
+                .emitStatement("generator.writeStartObject()")
+              .endControlFlow()
+              .emitWithGenerator(
+                  new JavaWriter.JavaGenerator() {
+                    @Override
+                    public void emitJava(JavaWriter writer) throws IOException {
+                      JsonParserClassData.this.writeSerializeCalls(messager, writer);
+
+                      // if we reached here, we need to call the superclasses processSingleField
+                      // method.
+                      if (mParentInjectedClassName != null) {
+                        writer.emitStatement(mParentInjectedClassName +
+                                ".serializeToJson(generator, object, false)");
+                      }
+
+                    }
+                  })
+              .beginControlFlow("if (writeStartAndEnd)")
+                .emitStatement("generator.writeEndObject()")
+              .endControlFlow()
+            .endMethod()
+            .emitEmptyLine();
+
+      writer
+          .beginMethod(
+              "String",
+              "serializeToJson",
+              EnumSet.of(PUBLIC, STATIC, FINAL),
+              Arrays.asList(mClassName, "object"),
+              Arrays.asList("IOException"))
+          .emitStatement("StringWriter stringWriter = new StringWriter()")
+          .emitStatement(
+              "JsonGenerator generator = " +
+                  "JsonFactoryHolder.APP_FACTORY.createGenerator(stringWriter)")
+          .emitStatement("serializeToJson(generator, object, true)")
+          .emitStatement("generator.close()")
+          .emitStatement("return stringWriter.toString()")
+          .endMethod()
+          .emitEmptyLine();
+
+      writer.endType();
+    } catch (IOException ex) {
+      Console.error(
+          messager, "IOException while generating %s: %s",
+          mInjectedClassName, ex.toString());
+    }
+
+    return sw.toString();
+  }
+
+  /**
+   * This writes the if-else block for the fields in this class.
+   * <p/>
+   * NOTE: This could be optimized further by building a radix trie, and building out the if-else
+   * block from traversing the radix trie.
+   */
+  private void writeFields(Messager messager, JavaWriter writer) throws IOException {
+    boolean firstEntry = true;
+    for (Map.Entry<String, TypeData> entry : getIterator()) {
+      TypeData data = entry.getValue();
+
+      if (firstEntry) {
+        writer.beginControlFlow("if (\"" + data.getFieldName() + "\".equals(fieldName))");
+      } else {
+        writer.nextControlFlow("else if (\"" + data.getFieldName() + "\".equals(fieldName))");
+      }
+
+      if (data.isInCollection()) {
+        generateArrayParser(messager, writer, data);
+        String assignmentFormatter = data.getAssignmentFormatter();
+        if (Strings.isNullOrEmpty(assignmentFormatter)) {
+          assignmentFormatter = DEFAULT_ASSIGNMENT_FORMATTER;
+        }
+        writer.emitStatement(
+            StrFormat.createStringFormatter(assignmentFormatter)
+                .addParam("object_varname", "instance")
+                .addParam("field_varname", entry.getKey())
+                .addParam("extracted_value", "results")
+                .format());
+      } else {
+        String rValue = generateExtractRvalue(data);
+        String assignmentFormatter = data.getAssignmentFormatter();
+        if (Strings.isNullOrEmpty(assignmentFormatter)) {
+          assignmentFormatter = DEFAULT_ASSIGNMENT_FORMATTER;
+        }
+        writer.emitStatement(
+            StrFormat.createStringFormatter(assignmentFormatter)
+                .addParam("object_varname", "instance")
+                .addParam("field_varname", entry.getKey())
+                .addParam("extracted_value", rValue)
+                .format());
+      }
+
+      writer.emitStatement("return true");
+
+      firstEntry = false;
+    }
+
+    if (firstEntry == false) {
+      writer.endControlFlow();
+    }
+  }
+
+  /**
+   * This writes the code to properly parse an array.
+   */
+  private void generateArrayParser(Messager messager, JavaWriter writer, TypeData data)
+      throws IOException {
+    String innerType = getJavaType(messager, data);
+    writer.emitStatement("List<%s> results = null", innerType)
+          .beginControlFlow("if (jp.getCurrentToken() == JsonToken.START_ARRAY)")
+            .emitStatement("results = new ArrayList<%s>()", innerType)
+            .beginControlFlow("while (jp.nextToken() != JsonToken.END_ARRAY)")
+              .emitStatement("%s parsed = %s", innerType, generateExtractRvalue(data))
+              .beginControlFlow("if (parsed != null)")
+                .emitStatement("results.add(parsed)")
+              .endControlFlow()
+            .endControlFlow()
+          .endControlFlow();
+  }
+
+  /**
+   * We allow consumers of this library to override how we interact with the jackson to get the
+   * value.  This generates the code to generate the rvalue expression.
+   */
+  private String generateExtractRvalue(TypeData data) {
+    String valueExtractFormatter = data.getValueExtractFormatter();
+    if (Strings.isNullOrEmpty(valueExtractFormatter)) {
+      if (data.getParseType() == TypeUtils.ParseType.PARSABLE_OBJECT) {
+        valueExtractFormatter = PARSABLE_OBJECT_VALUE_EXTRACT_FORMATTER;
+      } else {
+        if (data.getMapping() == JsonField.TypeMapping.EXACT) {
+          valueExtractFormatter = sExactFormatters.get(data.getParseType());
+        } else if (data.getMapping() == JsonField.TypeMapping.COERCED) {
+          valueExtractFormatter = sCoercedFormatters.get(data.getParseType());
+        }
+      }
+    }
+
+    return StrFormat.createStringFormatter(valueExtractFormatter)
+        .addParam("parser_object", "jp")
+        .addParam("subobject_helper_class",
+            data.getParsableTypeParserClass() +
+                JsonAnnotationProcessorConstants.HELPER_CLASS_SUFFIX)
+        .format();
+  }
+
+  private String getJavaType(Messager messager, TypeData type) {
+    if (type.getParseType() == TypeUtils.ParseType.PARSABLE_OBJECT) {
+      return type.getParsableType();
+    }
+
+    String javaType = sJavaTypes.get(type.getParseType());
+    if (javaType != null) {
+      return javaType;
+    }
+
+    throw new IllegalStateException(
+        "Could not divine java type for " + type.getFieldName() + " in class " + mClassName);
+  }
+
+  // These are all the default formatters.
+  private static String DEFAULT_ASSIGNMENT_FORMATTER =
+      "${object_varname}.${field_varname} = ${extracted_value}";
+  private static String PARSABLE_OBJECT_VALUE_EXTRACT_FORMATTER =
+      "${subobject_helper_class}.parseFromJson(${parser_object})";
+
+  private static Map<TypeUtils.ParseType, String> sExactFormatters = Maps.newHashMap();
+  private static Map<TypeUtils.ParseType, String> sCoercedFormatters = Maps.newHashMap();
+  private static Map<TypeUtils.ParseType, String> sJavaTypes = Maps.newHashMap();
+  static {
+    sExactFormatters.put(TypeUtils.ParseType.BOOLEAN, "${parser_object}.getBooleanValue()");
+    sExactFormatters.put(TypeUtils.ParseType.BOOLEAN_OBJECT,
+        "((${parser_object}.getCurrentToken() == JsonToken.VALUE_TRUE || " +
+          "${parser_object}.getCurrentToken() == JsonToken.VALUE_FALSE) ? " +
+            "Boolean.valueOf(${parser_object}.getValueAsBoolean()) : null)");
+    sExactFormatters.put(TypeUtils.ParseType.INTEGER, "${parser_object}.getIntValue()");
+    sExactFormatters.put(TypeUtils.ParseType.INTEGER_OBJECT,
+        "(${parser_object}.getCurrentToken() == JsonToken.VALUE_NUMBER_INT ? " +
+            "Integer.valueOf(${parser_object}.getValueAsInt()) : null)");
+    sExactFormatters.put(TypeUtils.ParseType.LONG, "${parser_object}.getLongValue()");
+    sExactFormatters.put(TypeUtils.ParseType.LONG_OBJECT,
+        "(${parser_object}.getCurrentToken() == JsonToken.VALUE_NUMBER_INT ? " +
+            "Long.valueOf(${parser_object}.getValueAsLong()) : null)");
+    sExactFormatters.put(TypeUtils.ParseType.FLOAT, "${parser_object}.getFloatValue()");
+    sExactFormatters.put(TypeUtils.ParseType.FLOAT_OBJECT,
+        "((${parser_object}.getCurrentToken() == JsonToken.VALUE_NUMBER_FLOAT || " +
+          "${parser_object}.getCurrentToken() == JsonToken.VALUE_NUMBER_INT) ? " +
+            "new Float(${parser_object}.getValueAsDouble()) : null)");
+    sExactFormatters.put(TypeUtils.ParseType.DOUBLE, "${parser_object}.getDoubleValue()");
+    sExactFormatters.put(TypeUtils.ParseType.DOUBLE_OBJECT,
+        "((${parser_object}.getCurrentToken() == JsonToken.VALUE_NUMBER_FLOAT || " +
+            "${parser_object}.getCurrentToken() == JsonToken.VALUE_NUMBER_INT) ? " +
+            "Double.valueOf(${parser_object}.getValueAsDouble()) : null)");
+    sExactFormatters.put(TypeUtils.ParseType.STRING,
+        "(${parser_object}.getCurrentToken() == JsonToken.VALUE_STRING ? ${parser_object}.getText() : null)");
+
+    sCoercedFormatters.put(TypeUtils.ParseType.BOOLEAN, "${parser_object}.getValueAsBoolean()");
+    sCoercedFormatters.put(
+        TypeUtils.ParseType.BOOLEAN_OBJECT, "Boolean.valueOf(${parser_object}.getValueAsBoolean())");
+    sCoercedFormatters.put(TypeUtils.ParseType.INTEGER, "${parser_object}.getValueAsInt()");
+    sCoercedFormatters.put(TypeUtils.ParseType.INTEGER_OBJECT,
+        "Integer.valueOf(${parser_object}.getValueAsInt())");
+    sCoercedFormatters.put(TypeUtils.ParseType.LONG, "${parser_object}.getValueAsLong()");
+    sCoercedFormatters.put(TypeUtils.ParseType.LONG_OBJECT,
+        "Long.valueOf(${parser_object}.getValueAsLong())");
+    sCoercedFormatters.put(TypeUtils.ParseType.FLOAT,
+        "((float) ${parser_object}.getValueAsDouble())");
+    sCoercedFormatters.put(TypeUtils.ParseType.FLOAT_OBJECT,
+        "new Float(${parser_object}.getValueAsDouble())");
+    sCoercedFormatters.put(TypeUtils.ParseType.DOUBLE, "${parser_object}.getValueAsDouble()");
+    sCoercedFormatters.put(
+        TypeUtils.ParseType.DOUBLE_OBJECT, "Double.valueOf(${parser_object}.getValueAsDouble())");
+    sCoercedFormatters.put(TypeUtils.ParseType.STRING, "${parser_object}.getText()");
+
+    sJavaTypes.put(TypeUtils.ParseType.BOOLEAN_OBJECT, "Boolean");
+    sJavaTypes.put(TypeUtils.ParseType.INTEGER_OBJECT, "Integer");
+    sJavaTypes.put(TypeUtils.ParseType.LONG_OBJECT, "Long");
+    sJavaTypes.put(TypeUtils.ParseType.FLOAT_OBJECT, "Float");
+    sJavaTypes.put(TypeUtils.ParseType.DOUBLE_OBJECT, "Double");
+    sJavaTypes.put(TypeUtils.ParseType.STRING, "String");
+  }
+
+  /**
+   * This writes the code to serialize this class to a JsonGenerator.
+   */
+  private void writeSerializeCalls(Messager messager, JavaWriter writer) throws IOException {
+    for (Map.Entry<String, TypeData> entry : getIterator()) {
+      TypeData data = entry.getValue();
+      String serializeCode = data.getSerializeCodeFormatter();
+
+      if (data.isInCollection()) {
+        if (Strings.isNullOrEmpty(serializeCode)) {
+          if (data.getParseType() == TypeUtils.ParseType.PARSABLE_OBJECT) {
+            serializeCode = PARSABLE_OBJECT_ARRAY_SERIALIZE_CALL;
+          } else {
+            serializeCode = mArraySerializeCalls.get(data.getParseType());
+          }
+        }
+
+        String listType = getJavaType(messager, entry.getValue());
+
+        writer
+            .beginControlFlow("if (object." + entry.getKey() + " != null)")
+              .emitStatement("generator.writeFieldName(\"%s\")", data.getFieldName())
+              .emitStatement("generator.writeStartArray()")
+              .beginControlFlow("for (" + listType +
+                  " element : (List<" + listType + ">) object." + entry.getKey() + ")")
+                .beginControlFlow("if (element != null)")
+                  .emitStatement(
+                      StrFormat.createStringFormatter(serializeCode)
+                        .addParam("generator_object", "generator")
+                        .addParam("iterator", "element")
+                        .addParam("subobject_helper_class",
+                            data.getParsableTypeParserClass() +
+                                JsonAnnotationProcessorConstants.HELPER_CLASS_SUFFIX)
+                        .format())
+                .endControlFlow()
+              .endControlFlow()
+              .emitStatement("generator.writeEndArray()")
+            .endControlFlow();
+      } else {
+        if (data.getParseType() == TypeUtils.ParseType.PARSABLE_OBJECT) {
+          if (Strings.isNullOrEmpty(serializeCode)) {
+            serializeCode = PARSABLE_OBJECT_SERIALIZE_CALL;
+          }
+          writer
+              .beginControlFlow("if (object." + entry.getKey() + " != null)")
+                .emitStatement("generator.writeFieldName(\"%s\")", data.getFieldName())
+                .emitStatement(
+                    StrFormat.createStringFormatter(serializeCode)
+                        .addParam("generator_object", "generator")
+                        .addParam("object_varname", "object")
+                        .addParam("field_varname", entry.getKey())
+                        .addParam("subobject_helper_class",
+                            data.getParsableTypeParserClass() +
+                                JsonAnnotationProcessorConstants.HELPER_CLASS_SUFFIX)
+                        .format())
+              .endControlFlow();
+        } else {
+          if (Strings.isNullOrEmpty(serializeCode)) {
+            serializeCode = mScalarSerializeCalls.get(data.getParseType());
+          }
+
+          String statement =
+              StrFormat.createStringFormatter(serializeCode)
+                  .addParam("generator_object", "generator")
+                  .addParam("object_varname", "object")
+                  .addParam("field_varname", entry.getKey())
+                  .addParam("json_fieldname", data.getFieldName())
+                  .format();
+
+          switch (data.getParseType()) {
+            case BOOLEAN:
+            case INTEGER:
+            case LONG:
+            case FLOAT:
+            case DOUBLE:
+              writer.emitStatement(statement);
+              break;
+
+            default:
+              writer
+                  .beginControlFlow("if (object." + entry.getKey() + " != null)")
+                  .emitStatement(statement)
+                  .endControlFlow();
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * used to write a single instance of a parsable object.
+   */
+  private static final String PARSABLE_OBJECT_SERIALIZE_CALL =
+      "${subobject_helper_class}.serializeToJson(${generator_object}, ${object_varname}.${field_varname}, true)";
+  private static final String PARSABLE_OBJECT_ARRAY_SERIALIZE_CALL =
+      "${subobject_helper_class}.serializeToJson(${generator_object}, ${iterator}, true)";
+
+  private static Map<TypeUtils.ParseType, String> mScalarSerializeCalls = Maps.newHashMap();
+  private static Map<TypeUtils.ParseType, String> mArraySerializeCalls = Maps.newHashMap();
+  static {
+    mScalarSerializeCalls.put(TypeUtils.ParseType.BOOLEAN,
+        "${generator_object}.writeBooleanField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
+    mScalarSerializeCalls.put(TypeUtils.ParseType.BOOLEAN_OBJECT,
+        "${generator_object}.writeBooleanField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
+    mScalarSerializeCalls.put(TypeUtils.ParseType.INTEGER,
+        "${generator_object}.writeNumberField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
+    mScalarSerializeCalls.put(TypeUtils.ParseType.INTEGER_OBJECT,
+        "${generator_object}.writeNumberField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
+    mScalarSerializeCalls.put(TypeUtils.ParseType.LONG,
+        "${generator_object}.writeNumberField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
+    mScalarSerializeCalls.put(TypeUtils.ParseType.LONG_OBJECT,
+        "${generator_object}.writeNumberField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
+    mScalarSerializeCalls.put(TypeUtils.ParseType.FLOAT,
+        "${generator_object}.writeNumberField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
+    mScalarSerializeCalls.put(TypeUtils.ParseType.FLOAT_OBJECT,
+        "${generator_object}.writeNumberField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
+    mScalarSerializeCalls.put(TypeUtils.ParseType.DOUBLE,
+        "${generator_object}.writeNumberField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
+    mScalarSerializeCalls.put(TypeUtils.ParseType.DOUBLE_OBJECT,
+        "${generator_object}.writeNumberField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
+    mScalarSerializeCalls.put(TypeUtils.ParseType.STRING,
+        "${generator_object}.writeStringField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
+
+    mArraySerializeCalls.put(TypeUtils.ParseType.BOOLEAN,
+        "${generator_object}.writeBoolean(${iterator})");
+    mArraySerializeCalls.put(TypeUtils.ParseType.BOOLEAN_OBJECT,
+        "${generator_object}.writeBoolean(${iterator})");
+    mArraySerializeCalls.put(TypeUtils.ParseType.INTEGER,
+        "${generator_object}.writeNumber(${iterator})");
+    mArraySerializeCalls.put(TypeUtils.ParseType.INTEGER_OBJECT,
+        "${generator_object}.writeNumber(${iterator})");
+    mArraySerializeCalls.put(TypeUtils.ParseType.LONG,
+        "${generator_object}.writeNumber(${iterator})");
+    mArraySerializeCalls.put(TypeUtils.ParseType.LONG_OBJECT,
+        "${generator_object}.writeNumber(${iterator})");
+    mArraySerializeCalls.put(TypeUtils.ParseType.FLOAT,
+        "${generator_object}.writeNumber(${iterator})");
+    mArraySerializeCalls.put(TypeUtils.ParseType.FLOAT_OBJECT,
+        "${generator_object}.writeNumber(${iterator})");
+    mArraySerializeCalls.put(TypeUtils.ParseType.DOUBLE,
+        "${generator_object}.writeNumber(${iterator})");
+    mArraySerializeCalls.put(TypeUtils.ParseType.DOUBLE_OBJECT,
+        "${generator_object}.writeNumber(${iterator})");
+    mArraySerializeCalls.put(TypeUtils.ParseType.STRING,
+        "${generator_object}.writeString(${iterator})");
+
+  }
+}
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/StrFormat.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/StrFormat.java
new file mode 100644
index 0000000..50c8919
--- /dev/null
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/StrFormat.java
@@ -0,0 +1,34 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import java.util.Map;
+
+import com.google.common.collect.Maps;
+import org.apache.commons.lang3.text.StrSubstitutor;
+
+/**
+ * Syntactic sugar wrapper for {@link StrSubstitutor}.
+ */
+class StrFormat {
+  private String mFormatString;
+  private Map<String, String> mInternalMap;
+
+  StrFormat(String formatString) {
+    mFormatString = formatString;
+    mInternalMap = Maps.newHashMap();
+  }
+
+  StrFormat addParam(String variableName, String replacementText) {
+    mInternalMap.put(variableName, replacementText);
+    return this;
+  }
+
+  String format() {
+    return StrSubstitutor.replace(mFormatString, mInternalMap);
+  }
+
+  static StrFormat createStringFormatter(String formatString) {
+    return new StrFormat(formatString);
+  }
+}
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/TypeData.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/TypeData.java
new file mode 100644
index 0000000..8e9f656
--- /dev/null
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/TypeData.java
@@ -0,0 +1,93 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.util.TypeUtils;
+
+/**
+ * Represents the data needed to serialize and deserialize a field.
+ */
+class TypeData {
+  private String mFieldName;
+  private JsonField.TypeMapping mMapping;
+  private String mValueExtractFormatter;
+  private String mAssignmentFormatter;
+  private String mSerializeCodeFormatter;
+  private boolean mInCollection;
+  private TypeUtils.ParseType mParseType;
+  private String mParsableType;
+  private String mParsableTypeParserClass;
+
+  String getFieldName() {
+    return mFieldName;
+  }
+
+  void setFieldName(String fieldName) {
+    this.mFieldName = fieldName;
+  }
+
+  JsonField.TypeMapping getMapping() {
+    return mMapping;
+  }
+
+  void setMapping(JsonField.TypeMapping mapping) {
+    this.mMapping = mapping;
+  }
+
+  public String getValueExtractFormatter() {
+    return mValueExtractFormatter;
+  }
+
+  public void setValueExtractFormatter(String valueExtractFormatter) {
+    mValueExtractFormatter = valueExtractFormatter;
+  }
+
+  public String getAssignmentFormatter() {
+    return mAssignmentFormatter;
+  }
+
+  public void setAssignmentFormatter(String assignmentFormatter) {
+    mAssignmentFormatter = assignmentFormatter;
+  }
+
+  public String getSerializeCodeFormatter() {
+    return mSerializeCodeFormatter;
+  }
+
+  public void setSerializeCodeFormatter(String serializeCodeFormatter) {
+    mSerializeCodeFormatter = serializeCodeFormatter;
+  }
+
+  boolean isInCollection() {
+    return mInCollection;
+  }
+
+  void setInCollection(boolean inCollection) {
+    mInCollection = inCollection;
+  }
+
+  TypeUtils.ParseType getParseType() {
+    return mParseType;
+  }
+
+  void setParseType(TypeUtils.ParseType parseType) {
+    mParseType = parseType;
+  }
+
+  String getParsableType() {
+    return mParsableType;
+  }
+
+  void setParsableType(String parsableType) {
+    mParsableType = parsableType;
+  }
+
+  String getParsableTypeParserClass() {
+    return mParsableTypeParserClass;
+  }
+
+  void setParsableTypeParserClass(String parsableTypeParserClass) {
+    mParsableTypeParserClass = parsableTypeParserClass;
+  }
+}
diff --git a/processor/src/test/java/com/instagram/common/json/annotation/processor/DeserializeTest.java b/processor/src/test/java/com/instagram/common/json/annotation/processor/DeserializeTest.java
new file mode 100644
index 0000000..087ae51
--- /dev/null
+++ b/processor/src/test/java/com/instagram/common/json/annotation/processor/DeserializeTest.java
@@ -0,0 +1,338 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.List;
+
+import com.instagram.common.json.annotation.processor.support.ExtensibleJSONWriter;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.core.JsonParseException;
+import com.fasterxml.jackson.core.JsonParser;
+import com.google.common.collect.Lists;
+import org.json.JSONException;
+import org.json.JSONWriter;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Basic deserialization tests.
+ */
+public class DeserializeTest {
+  @Test
+  public void simpleDeserializeTest() throws IOException, JSONException {
+    final int intValue = 25;
+    final int integerValue = 37;
+    final float floatValue = 1.0f;
+    final float floatObjValue = 2.0f;
+    final String stringValue = "hello world\r\n\'\"";
+    final List<Integer> integerList = Lists.newArrayList(1, 2, 3, 4);
+    final int subIntValue = 30;
+
+    StringWriter stringWriter = new StringWriter();
+    ExtensibleJSONWriter writer = new ExtensibleJSONWriter(stringWriter);
+
+    writer.object()
+        .key(SimpleParseUUT.INT_FIELD_NAME).value(intValue)
+        .key(SimpleParseUUT.INTEGER_FIELD_NAME).value(integerValue)
+        .key(SimpleParseUUT.FLOAT_FIELD_NAME).value(floatValue)
+        .key(SimpleParseUUT.FLOAT_OBJ_FIELD_NAME).value(floatObjValue)
+        .key(SimpleParseUUT.STRING_FIELD_NAME).value(stringValue)
+        .key(SimpleParseUUT.INTEGER_LIST_FIELD_NAME)
+          .array()
+          .extend(new ExtensibleJSONWriter.Extender() {
+            @Override
+            public void extend(ExtensibleJSONWriter writer) throws JSONException {
+              for (Integer integer : integerList) {
+                writer.value(integer);
+              }
+            }
+          })
+          .endArray()
+        .key(SimpleParseUUT.SUBOBJECT_FIELD_NAME)
+          .object()
+            .key(SimpleParseUUT.SubobjectParseUUT.INT_FIELD_NAME).value(subIntValue)
+          .endObject()
+      .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    SimpleParseUUT uut = SimpleParseUUT__JsonHelper.parseFromJson(jp);
+
+    assertSame(intValue, uut.intField);
+    assertSame(integerValue, uut.integerField.intValue());
+    assertEquals(Float.valueOf(floatValue), Float.valueOf(uut.floatField));
+    assertEquals(Float.valueOf(floatObjValue), uut.FloatField);
+    assertEquals(stringValue, uut.stringField);
+    assertEquals(integerList, uut.integerListField);
+    assertSame(subIntValue, uut.subobjectField.intField);
+  }
+
+  @Test
+  public void valueExtractTest() throws IOException, JSONException {
+    final int encodedValue = 25;
+    final int deserializedValue = 40;
+
+    StringWriter stringWriter = new StringWriter();
+    JSONWriter writer = new JSONWriter(stringWriter);
+
+    writer.object()
+        .key(FormatterUUT.VALUE_FORMATTER_FIELD_NAME).value(encodedValue)
+        .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    FormatterUUT uut = FormatterUUT__JsonHelper.parseFromJson(jp);
+
+    assertSame(deserializedValue, uut.valueFormatter);
+  }
+
+  @Test
+  public void fieldAssignmentTest() throws IOException, JSONException {
+    final int encodedValue = 25;
+    final int deserializedValue = -encodedValue;
+
+    StringWriter stringWriter = new StringWriter();
+    JSONWriter writer = new JSONWriter(stringWriter);
+
+    writer.object()
+        .key(FormatterUUT.FIELD_ASSIGNMENT_FIELD_NAME).value(encodedValue)
+        .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    FormatterUUT uut = FormatterUUT__JsonHelper.parseFromJson(jp);
+
+    assertSame(deserializedValue, uut.fieldAssignmentFormatter);
+  }
+
+  @Test
+  public void enumTest() throws IOException, JSONException {
+    final EnumUUT.EnumType value = EnumUUT.EnumType.VALUE2;
+
+    StringWriter stringWriter = new StringWriter();
+    JSONWriter writer = new JSONWriter(stringWriter);
+
+    writer.object()
+        .key(EnumUUT.ENUM_FIELD_NAME).value(value.toString())
+        .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    EnumUUT uut = EnumUUT__JsonHelper.parseFromJson(jp);
+
+    assertSame(value, uut.enumField);
+  }
+
+  @Test
+  public void exactMappingTest() throws IOException, JSONException {
+    // boolean exact fail.  should throw exception.
+    try {
+      parseObjectFromContents(
+          new ExtensibleJSONWriter.Extender() {
+            @Override
+            public void extend(ExtensibleJSONWriter writer) throws JSONException {
+              writer.key(ExactMappingUUT.BOOLEAN_FIELD_NAME).value(15);
+            }
+          });
+      fail("primitive type exact mismatches should throw exception");
+    } catch (JsonParseException ex) {
+      // this is expected.
+    }
+
+    // Boolean exact fail.  should be null.
+    assertNull(parseObjectFromContents(
+        new ExtensibleJSONWriter.Extender() {
+          @Override
+          public void extend(ExtensibleJSONWriter writer) throws JSONException {
+            writer.key(ExactMappingUUT.BOOLEAN_OBJ_FIELD_NAME).value(15);
+          }
+        })
+        .BooleanField);
+
+    // int exact fail.  should throw exception.
+    try {
+      parseObjectFromContents(
+          new ExtensibleJSONWriter.Extender() {
+            @Override
+            public void extend(ExtensibleJSONWriter writer) throws JSONException {
+              writer.key(ExactMappingUUT.INT_FIELD_NAME).value(false);
+            }
+          });
+      fail("primitive type exact mismatches should throw exception");
+    } catch (JsonParseException ex) {
+      // this is expected.
+    }
+
+    // Integer exact fail.  should be null.
+    assertNull(parseObjectFromContents(
+        new ExtensibleJSONWriter.Extender() {
+          @Override
+          public void extend(ExtensibleJSONWriter writer) throws JSONException {
+            writer.key(ExactMappingUUT.INTEGER_FIELD_NAME).value(false);
+          }
+        })
+        .IntegerField);
+
+    // long exact fail.  should throw exception.
+    try {
+      parseObjectFromContents(
+          new ExtensibleJSONWriter.Extender() {
+            @Override
+            public void extend(ExtensibleJSONWriter writer) throws JSONException {
+              writer.key(ExactMappingUUT.LONG_FIELD_NAME).value("abc");
+            }
+          });
+      fail("primitive type exact mismatches should throw exception");
+    } catch (JsonParseException ex) {
+      // this is expected.
+    }
+
+    // Long exact fail.  should be null.
+    assertNull(parseObjectFromContents(
+        new ExtensibleJSONWriter.Extender() {
+          @Override
+          public void extend(ExtensibleJSONWriter writer) throws JSONException {
+            writer.key(ExactMappingUUT.LONG_OBJ_FIELD_NAME).value("abc");
+          }
+        })
+        .LongField);
+
+    // float exact fail.  should throw exception.
+    try {
+      parseObjectFromContents(
+          new ExtensibleJSONWriter.Extender() {
+            @Override
+            public void extend(ExtensibleJSONWriter writer) throws JSONException {
+              writer.key(ExactMappingUUT.FLOAT_FIELD_NAME).value("abc");
+            }
+          });
+      fail("primitive type exact mismatches should throw exception");
+    } catch (JsonParseException ex) {
+      // this is expected.
+    }
+
+    // Float exact fail.  should be null.
+    assertNull(parseObjectFromContents(
+        new ExtensibleJSONWriter.Extender() {
+          @Override
+          public void extend(ExtensibleJSONWriter writer) throws JSONException {
+            writer.key(ExactMappingUUT.FLOAT_OBJ_FIELD_NAME).value("abc");
+          }
+        })
+        .FloatField);
+
+    // double exact fail.  should throw exception.
+    try {
+      parseObjectFromContents(
+          new ExtensibleJSONWriter.Extender() {
+            @Override
+            public void extend(ExtensibleJSONWriter writer) throws JSONException {
+              writer.key(ExactMappingUUT.DOUBLE_FIELD_NAME).value("abc");
+            }
+          });
+      fail("primitive type exact mismatches should throw exception");
+    } catch (JsonParseException ex) {
+      // this is expected.
+    }
+
+    // Double exact fail.  should be null.
+    assertNull(parseObjectFromContents(
+        new ExtensibleJSONWriter.Extender() {
+          @Override
+          public void extend(ExtensibleJSONWriter writer) throws JSONException {
+            writer.key(ExactMappingUUT.DOUBLE_OBJ_FIELD_NAME).value("abc");
+          }
+        })
+        .DoubleField);
+
+    // string exact fail.  should be null.
+    assertNull(parseObjectFromContents(
+        new ExtensibleJSONWriter.Extender() {
+          @Override
+          public void extend(ExtensibleJSONWriter writer) throws JSONException {
+            writer.key(ExactMappingUUT.STRING_FIELD_NAME).value(15);
+          }
+        })
+        .StringField);
+  }
+
+  /**
+   * Write an object in which the contents are sourced from the extender.  Then parse it as an
+   * {@link ExactMappingUUT} object and return it.
+   */
+  private static ExactMappingUUT parseObjectFromContents(ExtensibleJSONWriter.Extender extender)
+      throws IOException, JSONException {
+    StringWriter stringWriter = new StringWriter();
+    ExtensibleJSONWriter writer = new ExtensibleJSONWriter(stringWriter);
+
+    writer.object()
+        .extend(extender)
+        .endObject();
+
+    return ExactMappingUUT__JsonHelper.parseFromJson(stringWriter.toString());
+  }
+
+  @Test
+  public void postprocessTest() throws IOException, JSONException {
+    final int value = 25;
+
+    StringWriter stringWriter = new StringWriter();
+    JSONWriter writer = new JSONWriter(stringWriter);
+
+    writer.object()
+        .key(PostprocessingUUT.FIELD_NAME).value(value)
+        .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    PostprocessingUUT uut = PostprocessingUUT__JsonHelper.parseFromJson(jp);
+
+    assertSame(value + 1, uut.value);
+  }
+
+  @Test
+  public void malformedArrayEntry() throws IOException, JSONException {
+    final List<Integer> integerList = Lists.newArrayList(1, null, 3, 4);
+    final int subIntValue = 30;
+
+    StringWriter stringWriter = new StringWriter();
+    ExtensibleJSONWriter writer = new ExtensibleJSONWriter(stringWriter);
+
+    writer.object()
+        .key(StrictListParseUUT.INTEGER_LIST_FIELD_NAME)
+        .array()
+          .extend(new ExtensibleJSONWriter.Extender() {
+          @Override
+          public void extend(ExtensibleJSONWriter writer) throws JSONException {
+              for (Integer integer : integerList) {
+                writer.value(integer);
+              }
+            }
+        })
+        .endArray()
+        .key(StrictListParseUUT.SUBOBJECT_LIST_FIELD_NAME)
+        .object()
+          .key(StrictListParseUUT.SubobjectParseUUT.INT_FIELD_NAME).value(subIntValue)
+        .endObject()
+        .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    StrictListParseUUT uut = StrictListParseUUT__JsonHelper.parseFromJson(jp);
+
+    assertEquals(3, uut.integerListField.size());
+    assertEquals(1, uut.integerListField.get(0).intValue());
+    assertEquals(3, uut.integerListField.get(1).intValue());
+    assertEquals(4, uut.integerListField.get(2).intValue());
+  }
+}
diff --git a/processor/src/test/java/com/instagram/common/json/annotation/processor/InterModuleTest.java b/processor/src/test/java/com/instagram/common/json/annotation/processor/InterModuleTest.java
new file mode 100644
index 0000000..87c01d4
--- /dev/null
+++ b/processor/src/test/java/com/instagram/common/json/annotation/processor/InterModuleTest.java
@@ -0,0 +1,68 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import java.io.IOException;
+
+import com.instagram.common.json.annotation.processor.dependent.SubclassUUT;
+import com.instagram.common.json.annotation.processor.dependent.SubclassUUT__JsonHelper;
+import com.instagram.common.json.annotation.processor.dependent.WrapperClassUUT;
+import com.instagram.common.json.annotation.processor.dependent.WrapperClassUUT__JsonHelper;
+import com.instagram.common.json.annotation.processor.parent.ParentUUT;
+
+import org.json.JSONException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * Try to do stuff across modules.
+ */
+public class InterModuleTest {
+
+  /**
+   * Subclasses a java object in a different class.
+   */
+  @Test
+  public void subclassingTest() throws IOException, JSONException {
+    final int intValue = 25;
+    final String stringValue = "hello world\r\n\'\"";
+    final int subIntValue = 30;
+
+    SubclassUUT uut = new SubclassUUT();
+    uut.parentInt = intValue;
+    uut.subclassInt = subIntValue;
+    uut.parentString = stringValue;
+
+    // serialize it
+    String serialized = SubclassUUT__JsonHelper.serializeToJson(uut);
+
+    SubclassUUT parsed = SubclassUUT__JsonHelper.parseFromJson(serialized);
+
+    assertEquals(uut.parentInt, parsed.parentInt);
+    assertEquals(uut.parentString, parsed.parentString);
+    assertEquals(uut.subclassInt, parsed.subclassInt);
+  }
+
+  /**
+   * Includes a java object in a different class.
+   */
+  @Test
+  public void wrapperTest() throws IOException, JSONException {
+    final int intValue = 25;
+    final String stringValue = "hello world\r\n\'\"";
+
+    WrapperClassUUT uut = new WrapperClassUUT();
+    uut.parent = new ParentUUT();
+    uut.parent.parentInt = intValue;
+    uut.parent.parentString = stringValue;
+
+    // serialize it
+    String serialized = WrapperClassUUT__JsonHelper.serializeToJson(uut);
+
+    WrapperClassUUT parsed = WrapperClassUUT__JsonHelper.parseFromJson(serialized);
+
+    assertEquals(uut.parent.parentInt, parsed.parent.parentInt);
+    assertEquals(uut.parent.parentString, parsed.parent.parentString);
+  }
+}
diff --git a/processor/src/test/java/com/instagram/common/json/annotation/processor/MalformedJsonTest.java b/processor/src/test/java/com/instagram/common/json/annotation/processor/MalformedJsonTest.java
new file mode 100644
index 0000000..91dd8d8
--- /dev/null
+++ b/processor/src/test/java/com/instagram/common/json/annotation/processor/MalformedJsonTest.java
@@ -0,0 +1,159 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.List;
+
+import com.instagram.common.json.annotation.processor.support.ExtensibleJSONWriter;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.core.JsonParser;
+import com.google.common.collect.Lists;
+import org.json.JSONException;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Where we attack the parser with poorly formed json, where structures and arrays are interchanged
+ * with scalars.  These are errors that can result in infinite loops or improper termination of
+ * parsing.
+ */
+public class MalformedJsonTest {
+  private final int intValue = 25;
+  private final int integerValue = 37;
+  private final List<Integer> integerList = Lists.newArrayList(1, 2, 3, 4);
+
+  @Test
+  public void arrayInsteadOfScalar() throws IOException, JSONException {
+    StringWriter stringWriter = new StringWriter();
+    ExtensibleJSONWriter writer = new ExtensibleJSONWriter(stringWriter);
+
+    writer.object()
+        .key(SimpleParseUUT.STRING_FIELD_NAME)
+        .array()
+          .extend(new ExtensibleJSONWriter.Extender() {
+            @Override
+            public void extend(ExtensibleJSONWriter writer) throws JSONException {
+              for (Integer integer : integerList) {
+                writer.value(integer);
+              }
+            }
+          })
+          .endArray()
+        .key(SimpleParseUUT.INT_FIELD_NAME).value(intValue)
+        .key(SimpleParseUUT.INTEGER_FIELD_NAME).value(integerValue)
+        .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    SimpleParseUUT uut = SimpleParseUUT__JsonHelper.parseFromJson(jp);
+
+    assertSame(intValue, uut.intField);
+    assertSame(integerValue, uut.integerField.intValue());
+    assertNull(uut.stringField);
+  }
+
+  @Test
+  public void dictInsteadOfScalar() throws IOException, JSONException {
+    StringWriter stringWriter = new StringWriter();
+    ExtensibleJSONWriter writer = new ExtensibleJSONWriter(stringWriter);
+
+    writer.object()
+        .key(SimpleParseUUT.STRING_FIELD_NAME)
+        .object()
+          .key("garbage").value("123")
+        .endObject()
+        .key(SimpleParseUUT.INT_FIELD_NAME).value(intValue)
+        .key(SimpleParseUUT.INTEGER_FIELD_NAME).value(integerValue)
+        .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    SimpleParseUUT uut = SimpleParseUUT__JsonHelper.parseFromJson(jp);
+
+    assertSame(intValue, uut.intField);
+    assertSame(integerValue, uut.integerField.intValue());
+    assertNull(uut.stringField);
+  }
+
+  @Test
+  public void scalarInsteadOfArray() throws IOException, JSONException {
+    final int intValue = 25;
+    final int integerValue = 37;
+    final String stringValue = "hello world\r\n\'\"";
+    final int subIntValue = 30;
+
+    StringWriter stringWriter = new StringWriter();
+    ExtensibleJSONWriter writer = new ExtensibleJSONWriter(stringWriter);
+
+    writer.object()
+        .key(SimpleParseUUT.INT_FIELD_NAME).value(intValue)
+        .key(SimpleParseUUT.INTEGER_FIELD_NAME).value(integerValue)
+        .key(SimpleParseUUT.STRING_FIELD_NAME).value(stringValue)
+        .key(SimpleParseUUT.INTEGER_LIST_FIELD_NAME).value(intValue)
+        .key(SimpleParseUUT.SUBOBJECT_FIELD_NAME)
+        .object()
+        .key(SimpleParseUUT.SubobjectParseUUT.INT_FIELD_NAME).value(subIntValue)
+        .endObject()
+        .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    SimpleParseUUT uut = SimpleParseUUT__JsonHelper.parseFromJson(jp);
+
+    assertSame(intValue, uut.intField);
+    assertSame(integerValue, uut.integerField.intValue());
+    assertEquals(stringValue, uut.stringField);
+    assertNull(uut.integerListField);
+    assertSame(subIntValue, uut.subobjectField.intField);
+  }
+
+  @Test
+  public void scalarInsteadOfObject() throws IOException, JSONException {
+    final int intValue = 25;
+    final int integerValue = 37;
+    final String stringValue = "hello world\r\n\'\"";
+    final List<Integer> integerList = Lists.newArrayList(1, 2, 3, 4);
+    final int subIntValue = 30;
+
+    StringWriter stringWriter = new StringWriter();
+    ExtensibleJSONWriter writer = new ExtensibleJSONWriter(stringWriter);
+
+    writer.object()
+        .key(SimpleParseUUT.INT_FIELD_NAME).value(intValue)
+        .key(SimpleParseUUT.INTEGER_FIELD_NAME).value(integerValue)
+        .key(SimpleParseUUT.STRING_FIELD_NAME).value(stringValue)
+        .key(SimpleParseUUT.INTEGER_LIST_FIELD_NAME)
+        .array()
+        .extend(
+            new ExtensibleJSONWriter.Extender() {
+              @Override
+              public void extend(ExtensibleJSONWriter writer) throws JSONException {
+                for (Integer integer : integerList) {
+                  writer.value(integer);
+                }
+              }
+            })
+        .endArray()
+        .key(SimpleParseUUT.SUBOBJECT_FIELD_NAME).value(subIntValue)
+        .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    SimpleParseUUT uut = SimpleParseUUT__JsonHelper.parseFromJson(jp);
+
+    assertSame(intValue, uut.intField);
+    assertSame(integerValue, uut.integerField.intValue());
+    assertEquals(stringValue, uut.stringField);
+    assertEquals(integerList, uut.integerListField);
+    assertNull(uut.subobjectField);
+  }
+
+}
diff --git a/processor/src/test/java/com/instagram/common/json/annotation/processor/SerializeTest.java b/processor/src/test/java/com/instagram/common/json/annotation/processor/SerializeTest.java
new file mode 100644
index 0000000..9b674f0
--- /dev/null
+++ b/processor/src/test/java/com/instagram/common/json/annotation/processor/SerializeTest.java
@@ -0,0 +1,176 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.List;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonParser;
+import com.google.common.collect.Lists;
+import org.json.JSONException;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+
+/**
+ * Basic serialization tests.  It depends on deserialization working correctly but that's an
+ * acceptable assumption since if deserialization is broken, {@link DeserializeTest} should fail.
+ */
+public class SerializeTest {
+  @Test
+  public void simpleSerializeTest() throws IOException, JSONException {
+    final int intValue = 25;
+    final int integerValue = 37;
+    final String stringValue = "hello world\r\n\'\"";
+    final List<Integer> integerList = Lists.newArrayList(1, 2, 3, 4);
+    final int subIntValue = 30;
+
+    SimpleParseUUT source = new SimpleParseUUT();
+    source.intField = intValue;
+    source.integerField = integerValue;
+    source.stringField = stringValue;
+    source.integerListField = integerList;
+    source.subobjectField = new SimpleParseUUT.SubobjectParseUUT();
+    source.subobjectField.intField = subIntValue;
+
+    StringWriter stringWriter = new StringWriter();
+    JsonGenerator jsonGenerator = new JsonFactory().createGenerator(stringWriter);
+
+    SimpleParseUUT__JsonHelper.serializeToJson(jsonGenerator, source, true);
+    jsonGenerator.close();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    SimpleParseUUT parsed = SimpleParseUUT__JsonHelper.parseFromJson(jp);
+
+    assertSame(source.intField, parsed.intField);
+    assertEquals(source.integerField, parsed.integerField);
+    assertEquals(source.stringField, parsed.stringField);
+    assertEquals(source.integerListField, parsed.integerListField);
+    assertSame(source.subobjectField.intField, parsed.subobjectField.intField);
+  }
+
+  @Test
+  public void stringSerializeTest() throws IOException {
+    final int intValue = 25;
+    final int integerValue = 37;
+    final String stringValue = "hello world\r\n\'\"";
+    final List<Integer> integerList = Lists.newArrayList(1, 2, 3, 4);
+    final int subIntValue = 30;
+
+    SimpleParseUUT source = new SimpleParseUUT();
+    source.intField = intValue;
+    source.integerField = integerValue;
+    source.stringField = stringValue;
+    source.integerListField = integerList;
+    source.subobjectField = new SimpleParseUUT.SubobjectParseUUT();
+    source.subobjectField.intField = subIntValue;
+
+    String serialized = SimpleParseUUT__JsonHelper.serializeToJson(source);
+    SimpleParseUUT parsed = SimpleParseUUT__JsonHelper.parseFromJson(serialized);
+
+    assertSame(source.intField, parsed.intField);
+    assertEquals(source.integerField, parsed.integerField);
+    assertEquals(source.stringField, parsed.stringField);
+    assertEquals(source.integerListField, parsed.integerListField);
+    assertSame(source.subobjectField.intField, parsed.subobjectField.intField);
+  }
+
+  @Test
+  public void enumTest() throws IOException {
+    final EnumUUT.EnumType value = EnumUUT.EnumType.VALUE3;
+
+    EnumUUT source = new EnumUUT();
+    source.enumField = value;
+
+    String serialized = EnumUUT__JsonHelper.serializeToJson(source);
+    EnumUUT parsed = EnumUUT__JsonHelper.parseFromJson(serialized);
+
+    assertSame(source.enumField, parsed.enumField);
+  }
+
+  @Test
+  public void nullObject() throws IOException {
+    final int intValue = 25;
+    final int integerValue = 37;
+    final String stringValue = "hello world\r\n\'\"";
+    final List<Integer> integerList = Lists.newArrayList(1, 2, 3, 4);
+    final int subIntValue = 30;
+
+    SimpleParseUUT source = new SimpleParseUUT();
+    source.intField = intValue;
+    // intentionally do not set integerField
+    source.stringField = stringValue;
+    source.integerListField = integerList;
+    source.subobjectField = new SimpleParseUUT.SubobjectParseUUT();
+    source.subobjectField.intField = subIntValue;
+
+    String serialized = SimpleParseUUT__JsonHelper.serializeToJson(source);
+    SimpleParseUUT parsed = SimpleParseUUT__JsonHelper.parseFromJson(serialized);
+
+    assertSame(source.intField, parsed.intField);
+    assertNull(parsed.integerField);
+    assertEquals(source.stringField, parsed.stringField);
+    assertEquals(source.integerListField, parsed.integerListField);
+    assertSame(source.subobjectField.intField, parsed.subobjectField.intField);
+  }
+
+  @Test
+  public void nullArray() throws IOException {
+    final int intValue = 25;
+    final int integerValue = 37;
+    final String stringValue = "hello world\r\n\'\"";
+    final int subIntValue = 30;
+
+    SimpleParseUUT source = new SimpleParseUUT();
+    source.intField = intValue;
+    source.integerField = integerValue;
+    source.stringField = stringValue;
+    // intentionally do not set integerListField
+    source.subobjectField = new SimpleParseUUT.SubobjectParseUUT();
+    source.subobjectField.intField = subIntValue;
+
+    String serialized = SimpleParseUUT__JsonHelper.serializeToJson(source);
+    SimpleParseUUT parsed = SimpleParseUUT__JsonHelper.parseFromJson(serialized);
+
+    assertSame(source.intField, parsed.intField);
+    assertEquals(source.integerField, parsed.integerField);
+    assertEquals(source.stringField, parsed.stringField);
+    assertNull(parsed.integerListField);
+    assertSame(source.subobjectField.intField, parsed.subobjectField.intField);
+  }
+
+  @Test
+  public void nullArrayEntry() throws IOException {
+    final int intValue = 25;
+    final int integerValue = 37;
+    final String stringValue = "hello world\r\n\'\"";
+    final List<Integer> integerList = Lists.newArrayList(1, 2, 3, null);
+    final int subIntValue = 30;
+
+    SimpleParseUUT source = new SimpleParseUUT();
+    source.intField = intValue;
+    source.integerField = integerValue;
+    source.stringField = stringValue;
+    source.integerListField = integerList;
+    source.subobjectField = new SimpleParseUUT.SubobjectParseUUT();
+    source.subobjectField.intField = subIntValue;
+
+    String serialized = SimpleParseUUT__JsonHelper.serializeToJson(source);
+    SimpleParseUUT parsed = SimpleParseUUT__JsonHelper.parseFromJson(serialized);
+
+    assertSame(source.intField, parsed.intField);
+    assertEquals(source.integerField, parsed.integerField);
+    assertEquals(source.stringField, parsed.stringField);
+    assertEquals(source.integerListField.size() - 1, parsed.integerListField.size());
+    for (int ix = 0; ix < source.integerListField.size() - 1; ix ++) {
+      assertEquals(source.integerListField.get(ix), parsed.integerListField.get(ix));
+    }
+    assertSame(source.subobjectField.intField, parsed.subobjectField.intField);
+  }
+}
diff --git a/processor/support/build.gradle b/processor/support/build.gradle
new file mode 100644
index 0000000..e758d62
--- /dev/null
+++ b/processor/support/build.gradle
@@ -0,0 +1,5 @@
+apply plugin: 'java'
+
+dependencies {
+  compile group: 'org.json', name: 'json', version: '20090211'
+}
diff --git a/processor/support/src/main/java/com/instagram/common/json/annotation/processor/support/ExtensibleJSONWriter.java b/processor/support/src/main/java/com/instagram/common/json/annotation/processor/support/ExtensibleJSONWriter.java
new file mode 100644
index 0000000..ca585b9
--- /dev/null
+++ b/processor/support/src/main/java/com/instagram/common/json/annotation/processor/support/ExtensibleJSONWriter.java
@@ -0,0 +1,108 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor.support;
+
+import java.io.Writer;
+
+import org.json.JSONException;
+import org.json.JSONWriter;
+
+/**
+ * This is a subclass of {@link JSONWriter} that allows a function to be called within a sequence of
+ * commands.  This is syntactic sugar for constructs like:
+ * <p/>
+ * <pre>
+ *   writer.array()
+ *           .value(XXX)
+ *           .value(YYY)
+ *           .object()
+ *           // call some function that writes the object data
+ *           .extend(EXTENDER)
+ *           .endObject()
+ *         .endArray();
+ * </pre>
+ * <p/>
+ * Without this syntactic sugar, one would have to have one block for everything leading up to the
+ * function call, the function call, and the remaining items.  This also separates the opening
+ * <code>array()</code>/<code>object()</code> calls from their closing counterparts.
+ * <p/>
+ */
+public class ExtensibleJSONWriter extends JSONWriter {
+
+  /**
+   * Implementations of this interface can be passed into {@link #extend(Extender)} to do the actual
+   * work.
+   */
+  public interface Extender {
+    void extend(ExtensibleJSONWriter writer) throws JSONException;
+  }
+
+  public ExtensibleJSONWriter(Writer writer) {
+    super(writer);
+  }
+
+  /**
+   * Execute the {@link Extender#extend(Extender)} method.
+   */
+  public ExtensibleJSONWriter extend(Extender extender) throws JSONException {
+    extender.extend(this);
+    return this;
+  }
+
+  /////////////
+  // The remaining methods are simply overriden methods of {@link JSONWriter} that return an
+  // {@link ExtensibleJSONWriter}.
+  @Override
+  public ExtensibleJSONWriter array() throws JSONException {
+    super.array();
+    return this;
+  }
+
+  @Override
+  public ExtensibleJSONWriter endArray() throws JSONException {
+    super.endArray();
+    return this;
+  }
+
+  @Override
+  public ExtensibleJSONWriter endObject() throws JSONException {
+    super.endObject();
+    return this;
+  }
+
+  @Override
+  public ExtensibleJSONWriter key(String s) throws JSONException {
+    super.key(s);
+    return this;
+  }
+
+  @Override
+  public ExtensibleJSONWriter object() throws JSONException {
+    super.object();
+    return this;
+  }
+
+  @Override
+  public ExtensibleJSONWriter value(boolean b) throws JSONException {
+    super.value(b);
+    return this;
+  }
+
+  @Override
+  public ExtensibleJSONWriter value(double v) throws JSONException {
+    super.value(v);
+    return this;
+  }
+
+  @Override
+  public ExtensibleJSONWriter value(long l) throws JSONException {
+    super.value(l);
+    return this;
+  }
+
+  @Override
+  public ExtensibleJSONWriter value(Object o) throws JSONException {
+    super.value(o);
+    return this;
+  }
+}
diff --git a/processor/testuut/build.gradle b/processor/testuut/build.gradle
new file mode 100644
index 0000000..17a0b52
--- /dev/null
+++ b/processor/testuut/build.gradle
@@ -0,0 +1,12 @@
+apply plugin: 'java'
+
+compileJava {
+  options.compilerArgs += [
+                       '-processor',
+                       'com.instagram.common.json.annotation.processor.JsonAnnotationProcessor'
+  ]
+}
+dependencies {
+  compile project(':common')
+  compile project(':processor')
+}
diff --git a/processor/testuut/dependent/build.gradle b/processor/testuut/dependent/build.gradle
new file mode 100644
index 0000000..e8bf798
--- /dev/null
+++ b/processor/testuut/dependent/build.gradle
@@ -0,0 +1,13 @@
+apply plugin: 'java'
+
+compileJava {
+  options.compilerArgs += [
+                       '-processor',
+                       'com.instagram.common.json.annotation.processor.JsonAnnotationProcessor'
+  ]
+}
+dependencies {
+  compile project(':common')
+  compile project(':processor')
+  compile project(':processor:testuut:parent')
+}
diff --git a/processor/testuut/dependent/src/main/java/com/instagram/common/json/annotation/processor/SubclassUUT.java b/processor/testuut/dependent/src/main/java/com/instagram/common/json/annotation/processor/SubclassUUT.java
new file mode 100644
index 0000000..a3a6b78
--- /dev/null
+++ b/processor/testuut/dependent/src/main/java/com/instagram/common/json/annotation/processor/SubclassUUT.java
@@ -0,0 +1,18 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor.dependent;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+import com.instagram.common.json.annotation.processor.parent.ParentUUT;
+
+/**
+ * Subclasses {@link ParentUUT}.
+ */
+@JsonType
+public class SubclassUUT extends ParentUUT {
+  public static final String SUBCLASS_INT_KEY = "subclass_int";
+
+  @JsonField(fieldName = SUBCLASS_INT_KEY)
+  public int subclassInt;
+}
diff --git a/processor/testuut/dependent/src/main/java/com/instagram/common/json/annotation/processor/WrapperClassUUT.java b/processor/testuut/dependent/src/main/java/com/instagram/common/json/annotation/processor/WrapperClassUUT.java
new file mode 100644
index 0000000..f203455
--- /dev/null
+++ b/processor/testuut/dependent/src/main/java/com/instagram/common/json/annotation/processor/WrapperClassUUT.java
@@ -0,0 +1,18 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor.dependent;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+import com.instagram.common.json.annotation.processor.parent.ParentUUT;
+
+/**
+ * Wraps {@link ParentUUT}.
+ */
+@JsonType
+public class WrapperClassUUT {
+  public static final String PARENT_KEY = "parent";
+
+  @JsonField(fieldName = PARENT_KEY)
+  public ParentUUT parent;
+}
diff --git a/processor/testuut/parent/build.gradle b/processor/testuut/parent/build.gradle
new file mode 100644
index 0000000..17a0b52
--- /dev/null
+++ b/processor/testuut/parent/build.gradle
@@ -0,0 +1,12 @@
+apply plugin: 'java'
+
+compileJava {
+  options.compilerArgs += [
+                       '-processor',
+                       'com.instagram.common.json.annotation.processor.JsonAnnotationProcessor'
+  ]
+}
+dependencies {
+  compile project(':common')
+  compile project(':processor')
+}
diff --git a/processor/testuut/parent/src/main/java/com/instagram/common/json/annotation/processor/ParentUUT.java b/processor/testuut/parent/src/main/java/com/instagram/common/json/annotation/processor/ParentUUT.java
new file mode 100644
index 0000000..8371816
--- /dev/null
+++ b/processor/testuut/parent/src/main/java/com/instagram/common/json/annotation/processor/ParentUUT.java
@@ -0,0 +1,21 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor.parent;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+/**
+ * Parent class.
+ */
+@JsonType
+public class ParentUUT {
+  public static final String PARENT_STRING_KEY = "parent_string";
+  public static final String PARENT_INT_KEY = "parent_int";
+
+  @JsonField(fieldName = PARENT_STRING_KEY)
+  public String parentString;
+
+  @JsonField(fieldName = PARENT_INT_KEY)
+  public int parentInt;
+}
diff --git a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/EnumUUT.java b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/EnumUUT.java
new file mode 100644
index 0000000..b81dc0a
--- /dev/null
+++ b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/EnumUUT.java
@@ -0,0 +1,27 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+/**
+ * UUT to test using enums in autogenerated parsing and serialization.
+ */
+@JsonType
+public class EnumUUT {
+  public static final String ENUM_FIELD_NAME = "enum";
+
+  public enum EnumType {
+    VALUE0,
+    VALUE1,
+    VALUE2,
+    VALUE3,
+  }
+
+  @JsonField(fieldName = ENUM_FIELD_NAME,
+      valueExtractFormatter = "EnumUUT.EnumType.valueOf(${parser_object}.getText())",
+      serializeCodeFormatter =
+          "${generator_object}.writeStringField(\"${json_fieldname}\", ${object_varname}.${field_varname}.toString())")
+  public EnumType enumField;
+}
diff --git a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/ExactMappingUUT.java b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/ExactMappingUUT.java
new file mode 100644
index 0000000..c0c1625
--- /dev/null
+++ b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/ExactMappingUUT.java
@@ -0,0 +1,59 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+import static com.instagram.common.json.annotation.JsonField.TypeMapping.*;
+
+/**
+ * UUT for testing the {@link JsonField.TypeMapping#EXACT} mapping.
+ */
+@JsonType
+public class ExactMappingUUT {
+  public static final String BOOLEAN_FIELD_NAME = "boolean";
+  public static final String BOOLEAN_OBJ_FIELD_NAME = "Boolean";
+  public static final String INT_FIELD_NAME = "int";
+  public static final String INTEGER_FIELD_NAME = "Integer";
+  public static final String LONG_FIELD_NAME = "long";
+  public static final String LONG_OBJ_FIELD_NAME = "Long";
+  public static final String FLOAT_FIELD_NAME = "float";
+  public static final String FLOAT_OBJ_FIELD_NAME = "Float";
+  public static final String DOUBLE_FIELD_NAME = "double";
+  public static final String DOUBLE_OBJ_FIELD_NAME = "Double";
+  public static final String STRING_FIELD_NAME = "String";
+
+  @JsonField(fieldName = BOOLEAN_FIELD_NAME, mapping = EXACT)
+  public boolean booleanField;
+
+  @JsonField(fieldName = BOOLEAN_OBJ_FIELD_NAME, mapping = EXACT)
+  public Boolean BooleanField;
+
+  @JsonField(fieldName = INT_FIELD_NAME, mapping = EXACT)
+  public int intField;
+
+  @JsonField(fieldName = INTEGER_FIELD_NAME, mapping = EXACT)
+  public Integer IntegerField;
+
+  @JsonField(fieldName = LONG_FIELD_NAME, mapping = EXACT)
+  public long longField;
+
+  @JsonField(fieldName = LONG_OBJ_FIELD_NAME, mapping = EXACT)
+  public Long LongField;
+
+  @JsonField(fieldName = FLOAT_FIELD_NAME, mapping = EXACT)
+  public float floatField;
+
+  @JsonField(fieldName = FLOAT_OBJ_FIELD_NAME, mapping = EXACT)
+  public Float FloatField;
+
+  @JsonField(fieldName = DOUBLE_FIELD_NAME, mapping = EXACT)
+  public double doubleField;
+
+  @JsonField(fieldName = DOUBLE_OBJ_FIELD_NAME, mapping = EXACT)
+  public Double DoubleField;
+
+  @JsonField(fieldName = STRING_FIELD_NAME, mapping = EXACT)
+  public String StringField;
+}
diff --git a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/FormatterUUT.java b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/FormatterUUT.java
new file mode 100644
index 0000000..7c534d3
--- /dev/null
+++ b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/FormatterUUT.java
@@ -0,0 +1,24 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+/**
+ * UUT for testing the overridden formatters.  See {@link JsonField#valueExtractFormatter()} and
+ * {@link JsonField#fieldAssignmentFormatter()}.
+ */
+@JsonType
+class FormatterUUT {
+  static final String VALUE_FORMATTER_FIELD_NAME = "value_formatter";
+  static final String FIELD_ASSIGNMENT_FIELD_NAME = "field_assignment";
+
+  @JsonField(fieldName = VALUE_FORMATTER_FIELD_NAME,
+      valueExtractFormatter = "${parser_object}.getIntValue() + 15")
+  int valueFormatter;
+
+  @JsonField(fieldName = FIELD_ASSIGNMENT_FIELD_NAME,
+      fieldAssignmentFormatter = "${object_varname}.${field_varname} = -${extracted_value}")
+  int fieldAssignmentFormatter;
+}
diff --git a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/PostprocessingUUT.java b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/PostprocessingUUT.java
new file mode 100644
index 0000000..302850d
--- /dev/null
+++ b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/PostprocessingUUT.java
@@ -0,0 +1,22 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+/**
+ * UUT to test the optional post-processing code.
+ */
+@JsonType(postprocessingEnabled = true)
+public class PostprocessingUUT {
+  static final String FIELD_NAME = "abcabc";
+
+  @JsonField(fieldName = FIELD_NAME)
+  int value;
+
+  PostprocessingUUT postprocess() {
+    value = value + 1;
+    return this;
+  }
+}
diff --git a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/SimpleParseUUT.java b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/SimpleParseUUT.java
new file mode 100644
index 0000000..0f6dab8
--- /dev/null
+++ b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/SimpleParseUUT.java
@@ -0,0 +1,54 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import java.util.List;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+/**
+ * Simple UUT for testing the most basic functionality.
+ */
+@JsonType
+public class SimpleParseUUT {
+  public static final String INT_FIELD_NAME = "int";
+  public static final String INTEGER_FIELD_NAME = "Integer";
+  public static final String FLOAT_FIELD_NAME = "float";
+  public static final String FLOAT_OBJ_FIELD_NAME = "Float";
+  public static final String STRING_FIELD_NAME = "String";
+  public static final String INTEGER_LIST_FIELD_NAME = "IntegerList";
+  public static final String SUBOBJECT_FIELD_NAME = "Subobject";
+
+  @JsonField(fieldName = INT_FIELD_NAME)
+  public int intField;
+
+  @JsonField(fieldName = INTEGER_FIELD_NAME)
+  public Integer integerField;
+
+  @JsonField(fieldName = FLOAT_FIELD_NAME)
+  public float floatField;
+
+  @JsonField(fieldName = FLOAT_OBJ_FIELD_NAME)
+  public Float FloatField;
+
+  @JsonField(fieldName = STRING_FIELD_NAME, mapping = JsonField.TypeMapping.EXACT)
+  public String stringField;
+
+  @JsonField(fieldName = INTEGER_LIST_FIELD_NAME)
+  public List<Integer> integerListField;
+
+  @JsonField(fieldName = SUBOBJECT_FIELD_NAME)
+  public SubobjectParseUUT subobjectField;
+
+  /**
+   * UUT for embedding a subobject.
+   */
+  @JsonType
+  public static class SubobjectParseUUT {
+    public static final String INT_FIELD_NAME = "int";
+
+    @JsonField(fieldName = INT_FIELD_NAME)
+    public int intField;
+  }
+}
diff --git a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/StrictListParseUUT.java b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/StrictListParseUUT.java
new file mode 100644
index 0000000..8c2458f
--- /dev/null
+++ b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/StrictListParseUUT.java
@@ -0,0 +1,34 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import java.util.List;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+/**
+ * Object with lists that request an {@link JsonField.TypeMapping#EXACT} mapping.
+ */
+@JsonType
+public class StrictListParseUUT {
+  public static final String INTEGER_LIST_FIELD_NAME = "IntegerList";
+  public static final String SUBOBJECT_LIST_FIELD_NAME = "SubobjectList";
+
+  @JsonField(fieldName = INTEGER_LIST_FIELD_NAME, mapping = JsonField.TypeMapping.EXACT)
+  public List<Integer> integerListField;
+
+  @JsonField(fieldName = SUBOBJECT_LIST_FIELD_NAME, mapping = JsonField.TypeMapping.EXACT)
+  public List<SubobjectParseUUT> subobjectListField;
+
+  /**
+   * UUT for embedding a subobject.
+   */
+  @JsonType
+  public static class SubobjectParseUUT {
+    public static final String INT_FIELD_NAME = "int";
+
+    @JsonField(fieldName = INT_FIELD_NAME)
+    public int intField;
+  }
+}
diff --git a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/StringInterfaceUUT.java b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/StringInterfaceUUT.java
new file mode 100644
index 0000000..fd3cab0
--- /dev/null
+++ b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/StringInterfaceUUT.java
@@ -0,0 +1,17 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+/**
+ * Simple UUT for testing the most basic functionality.
+ */
+@JsonType()
+public class StringInterfaceUUT {
+  public static final String INT_FIELD_NAME = "int";
+
+  @JsonField(fieldName = INT_FIELD_NAME)
+  public int intField;
+}
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 0000000..4a87f33
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,12 @@
+include 'javawriter'
+include 'util'
+include 'util:testprocessor'
+include 'util:testuut'
+include 'common'
+include 'processor'
+include 'processor:support'
+include 'processor:testuut'
+include 'processor:testuut:parent'
+include 'processor:testuut:dependent'
+include 'demo'
+include 'demo:igmodel'
diff --git a/util/build.gradle b/util/build.gradle
new file mode 100644
index 0000000..61b7953
--- /dev/null
+++ b/util/build.gradle
@@ -0,0 +1,12 @@
+apply plugin: 'java'
+
+repositories {
+  mavenCentral()
+}
+
+dependencies {
+  compile group: 'com.google.guava', name: 'guava', version: '10.0.1+'
+  testCompile group: 'junit', name: 'junit', version: '4.8.2+'
+  testCompile project(':util:testuut')
+}
+
diff --git a/util/src/main/java/com/instagram/common/json/annotation/util/Console.java b/util/src/main/java/com/instagram/common/json/annotation/util/Console.java
new file mode 100644
index 0000000..a414890
--- /dev/null
+++ b/util/src/main/java/com/instagram/common/json/annotation/util/Console.java
@@ -0,0 +1,56 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.util;
+
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.tools.Diagnostic;
+
+import java.util.Locale;
+
+import static javax.tools.Diagnostic.Kind.ERROR;
+import static javax.tools.Diagnostic.Kind.WARNING;
+
+/**
+ * Utility functions to write to the compiler log.
+ */
+public class Console {
+  public static void error(Messager messager, String message, Object... args) {
+    messager.printMessage(ERROR, String.format(Locale.US, message, args));
+  }
+
+  public static void error(Messager messager, Element element, String message, Object... args) {
+    messager.printMessage(ERROR, String.format(Locale.US, message, args), element);
+  }
+
+  public static void warning(Messager messager, String message, Object... args) {
+    messager.printMessage(WARNING, String.format(Locale.US, message, args));
+  }
+
+  /**
+   * Returns a messager that swallows all its output.
+   */
+  public static Messager getNullMessager() {
+    return new Messager() {
+      @Override
+      public void printMessage(Diagnostic.Kind kind, CharSequence msg) {
+      }
+
+      @Override
+      public void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e) {
+      }
+
+      @Override
+      public void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e,
+          AnnotationMirror a) {
+      }
+
+      @Override
+      public void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e,
+          AnnotationMirror a, AnnotationValue v) {
+      }
+    };
+  }
+}
diff --git a/util/src/main/java/com/instagram/common/json/annotation/util/ProcessorClassData.java b/util/src/main/java/com/instagram/common/json/annotation/util/ProcessorClassData.java
new file mode 100644
index 0000000..9d80d0f
--- /dev/null
+++ b/util/src/main/java/com/instagram/common/json/annotation/util/ProcessorClassData.java
@@ -0,0 +1,92 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.util;
+
+import com.google.common.collect.Maps;
+
+import javax.annotation.processing.Messager;
+import java.util.Iterator;
+import java.util.Map;
+
+/**
+ * The basic construct to hold the annotation data gathered about a class.  Data records are indexed
+ * by a key.  {@link ProcessorClassData} manages the set of data records, though creation of a
+ * record is delegated to a factory.
+ *
+ * When the gathering phase is complete, a class injector is asked to produce java source code to be
+ * written out.
+ */
+abstract public class ProcessorClassData<AnnotationKeyType, AnnotationRecordType> {
+
+  /**
+   * Factory to produce records.
+   */
+  public interface AnnotationRecordFactory<AnnotationKeyType, AnnotationRecordType> {
+
+    /**
+     * Creates a record for a given key.
+     */
+    public AnnotationRecordType createAnnotationRecord(AnnotationKeyType key);
+  }
+
+  protected final String mClassPackage;
+  protected final String mClassName;
+  protected final String mInjectedClassName;
+  private final AnnotationRecordFactory<AnnotationKeyType, AnnotationRecordType> mFactory;
+  private Map<AnnotationKeyType, AnnotationRecordType> mData;
+
+  /**
+   * Creates a ProcessorClassData.
+   * @param classPackage the package of the class being inspected.
+   * @param className the simple class name of the class being inspected.  See
+   * {@link Class#getSimpleName()}.
+   * @param injectedClassName the simple class name of the class this injector will write its
+   * generated code to.  See {@link Class#getSimpleName()}.
+   * @param factory creates data records.
+   */
+  protected ProcessorClassData(String classPackage, String className, String injectedClassName,
+      AnnotationRecordFactory<AnnotationKeyType, AnnotationRecordType> factory) {
+    mClassPackage = classPackage;
+    mClassName = className;
+    mInjectedClassName = injectedClassName;
+    mFactory = factory;
+    mData = Maps.newHashMap();
+  }
+
+  /**
+   * Retrieves the data record corresponding to a given key.  If the record does not exist, it is
+   * created.
+   */
+  public AnnotationRecordType getOrCreateRecord(AnnotationKeyType key) {
+    AnnotationRecordType record = mData.get(key);
+    if (record == null) {
+      record = mFactory.createAnnotationRecord(key);
+      mData.put(key, record);
+    }
+    return record;
+  }
+
+  /**
+   * Returns the fully-qualified class name of the class we're generating the source for.
+   */
+  public String getInjectedFqcn() {
+    return mClassPackage + '.' + mInjectedClassName;
+  }
+
+  /**
+   * Returns an iterator across all the records gathered by this injector.
+   */
+  protected Iterable<Map.Entry<AnnotationKeyType, AnnotationRecordType>> getIterator() {
+    return new Iterable<Map.Entry<AnnotationKeyType, AnnotationRecordType>>() {
+      @Override
+      public Iterator<Map.Entry<AnnotationKeyType, AnnotationRecordType>> iterator() {
+        return mData.entrySet().iterator();
+      }
+    };
+  }
+
+  /**
+   * Returns the java code generated.
+   */
+  abstract public String getJavaCode(Messager messager);
+}
diff --git a/util/src/main/java/com/instagram/common/json/annotation/util/TypeUtils.java b/util/src/main/java/com/instagram/common/json/annotation/util/TypeUtils.java
new file mode 100644
index 0000000..2d91bc5
--- /dev/null
+++ b/util/src/main/java/com/instagram/common/json/annotation/util/TypeUtils.java
@@ -0,0 +1,204 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.util;
+
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Utility functions to get the declared types of fields.
+ */
+public class TypeUtils {
+
+  public enum ParseType {
+    UNSUPPORTED,
+    BOOLEAN,
+    BOOLEAN_OBJECT,
+    INTEGER,
+    INTEGER_OBJECT,
+    LONG,
+    LONG_OBJECT,
+    FLOAT,
+    FLOAT_OBJECT,
+    DOUBLE,
+    DOUBLE_OBJECT,
+    STRING,
+    PARSABLE_OBJECT,
+    ENUM_OBJECT,
+  };
+
+  private static final String JAVA_LANG_STRING = "java.lang.String";
+  private static final String JAVA_LANG_BOOLEAN = "java.lang.Boolean";
+  private static final String JAVA_LANG_INTEGER = "java.lang.Integer";
+  private static final String JAVA_LANG_LONG = "java.lang.Long";
+  private static final String JAVA_LANG_FLOAT = "java.lang.Float";
+  private static final String JAVA_LANG_DOUBLE = "java.lang.Double";
+  private static final String JAVA_UTIL_LIST = "java.util.List<?>";
+  private static final String JAVA_UTIL_LIST_UNTYPED = "java.util.List";
+  private static final String JAVA_LANG_ENUM = "java.lang.Enum<?>";
+
+  private final Types mTypes;
+  private final Messager mMessager;
+
+  public TypeUtils(Types types, Messager messager) {
+    mTypes = types;
+    mMessager = messager;
+  }
+
+  public ParseType getParseType(
+      TypeMirror typeMirror, Class<? extends Annotation> typeAnnotationClass) {
+    if (typeMirror == null) {
+      return ParseType.UNSUPPORTED;
+    } else if (JAVA_LANG_STRING.equals(typeMirror.toString())) {
+      return ParseType.STRING;
+    } else if (typeMirror.getKind() == TypeKind.BOOLEAN) {
+      return ParseType.BOOLEAN;
+    } else if (JAVA_LANG_BOOLEAN.equals(typeMirror.toString())) {
+      return ParseType.BOOLEAN_OBJECT;
+    } else if (typeMirror.getKind() == TypeKind.INT) {
+      return ParseType.INTEGER;
+    } else if (JAVA_LANG_INTEGER.equals(typeMirror.toString())) {
+      return ParseType.INTEGER_OBJECT;
+    } else if (typeMirror.getKind() == TypeKind.LONG) {
+      return ParseType.LONG;
+    } else if (JAVA_LANG_LONG.equals(typeMirror.toString())) {
+      return ParseType.LONG_OBJECT;
+    } else if (typeMirror.getKind() == TypeKind.FLOAT) {
+      return ParseType.FLOAT;
+    } else if (JAVA_LANG_FLOAT.equals(typeMirror.toString())) {
+      return ParseType.FLOAT_OBJECT;
+    } else if (typeMirror.getKind() == TypeKind.DOUBLE) {
+      return ParseType.DOUBLE;
+    } else if (JAVA_LANG_DOUBLE.equals(typeMirror.toString())) {
+      return ParseType.DOUBLE_OBJECT;
+    } else if (typeMirror instanceof DeclaredType) {
+      DeclaredType type = (DeclaredType) typeMirror;
+      Element element = type.asElement();
+
+      Annotation annotation = element.getAnnotation(typeAnnotationClass);
+      if (annotation != null) {
+        return ParseType.PARSABLE_OBJECT;
+      }
+
+      // is it an enum?
+      if (element instanceof TypeElement) {
+        TypeElement typeElement = (TypeElement) element;
+        TypeMirror superclass = typeElement.getSuperclass();
+        if (superclass instanceof DeclaredType) {
+          DeclaredType superclassDeclaredType = (DeclaredType) superclass;
+
+          if (JAVA_LANG_ENUM.equals(getCanonicalTypeName(superclassDeclaredType))) {
+            return ParseType.ENUM_OBJECT;
+          }
+        }
+      }
+    }
+
+    return ParseType.UNSUPPORTED;
+  }
+
+  public boolean isListType(TypeMirror typeMirror) {
+    return JAVA_UTIL_LIST_UNTYPED.equals(mTypes.erasure(typeMirror).toString());
+  }
+
+  /**
+   * If {@code typeMirror} represents a list type ({@link java.util.List}), attempt to divine the
+   * type of the contents.
+   *
+   * Returns null if {@code typeMirror} does not represent a list type or if we cannot divine the
+   * type of the contents.
+   */
+  public TypeMirror getListParameterizedType(TypeMirror typeMirror) {
+    if (!(typeMirror instanceof DeclaredType)) {
+      return null;
+    }
+    DeclaredType declaredType = (DeclaredType) typeMirror;
+    Element element = declaredType.asElement();
+    if (!(element instanceof TypeElement)) {
+      return null;
+    }
+    TypeElement typeElement = (TypeElement) element;
+    List<? extends TypeParameterElement> typeParameterElements = typeElement.getTypeParameters();
+
+    if (JAVA_UTIL_LIST.equals(getCanonicalTypeName(declaredType))) {
+      // sanity check.
+      if (typeParameterElements.size() != 1) {
+        throw new IllegalStateException("java list is not expected generic type");
+      }
+
+      List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+
+      if (typeArguments.size() == 1) {
+        return typeArguments.get(0);
+      } else {
+        return null;
+      }
+    }
+
+    return null;
+  }
+
+  /**
+   * This returns the class name of the type as one would use to reference in code.  For most cases,
+   * this is pretty straightforward.  Inner classes are used with . notation, i.e., if class Y is an
+   * inner class of class X, then class Y's class name should be X.Y.
+   */
+  public String getClassName(TypeElement type, String packageName) {
+    int packageLen = packageName.length() + 1;
+    return type.getQualifiedName().toString().substring(packageLen);
+  }
+
+  /**
+   * This returns the prefix used to refer to the generated class.  This is different because we
+   * generate individual source files for each inner class.  For instance, if we have class X with
+   * inner classes Y and Z, then we generate three source files.
+   * <p/>
+   * To make this work, we replace the normal dot notation between an outer class and an inner class
+   * with a '_', i.e., the generated class for class X will be X_Y&lt;suffix&gt;.
+   */
+  public String getPrefixForGeneratedClass(TypeElement type, String packageName) {
+    int packageLen = packageName.length() + 1;
+    return type.getQualifiedName().toString().substring(packageLen).replace('.', '_');
+  }
+
+  public String getPackageName(Elements elements, TypeElement type) {
+    return elements.getPackageOf(type).getQualifiedName().toString();
+  }
+
+  /**
+   * Returns a string with type parameters replaced with wildcards.  This is slightly different from
+   * {@link Types#erasure(javax.lang.model.type.TypeMirror)}, which removes all type parameter data.
+   *
+   * For instance, if there is a field with type List&lt;String&gt;, this returns a string
+   * List&lt;?&gt;.
+   */
+  private String getCanonicalTypeName(DeclaredType declaredType) {
+    List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+    if (!typeArguments.isEmpty()) {
+      StringBuilder typeString = new StringBuilder(declaredType.asElement().toString());
+      typeString.append('<');
+      for (int i = 0; i < typeArguments.size(); i++) {
+        if (i > 0) {
+          typeString.append(',');
+        }
+        typeString.append('?');
+      }
+      typeString.append('>');
+
+      return typeString.toString();
+    } else {
+      return declaredType.toString();
+    }
+  }
+}
diff --git a/util/src/test/java/com/instagram/common/json/annotation/util/TypeUtilsTest.java b/util/src/test/java/com/instagram/common/json/annotation/util/TypeUtilsTest.java
new file mode 100644
index 0000000..9f28283
--- /dev/null
+++ b/util/src/test/java/com/instagram/common/json/annotation/util/TypeUtilsTest.java
@@ -0,0 +1,127 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.util;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Verifies that we can correctly identify the declared type of fields.
+ */
+public class TypeUtilsTest {
+
+  @Test
+  public void testTypeIdentification() {
+    TypeInspectionUUT object = new TypeInspectionUUT();
+    TypeInspectionUUT__Test.injectTypeData(object);
+
+    verifyBaseClass(object);
+  }
+
+  @Test
+  public void testSubclassTypeIdentification() {
+    SubclassUUT object = new SubclassUUT();
+    SubclassUUT__Test.injectTypeData(object);
+
+    assertFalse(object.subclassInteger__IsList);
+    assertEquals(object.subclassInteger__ParseType, TypeUtils.ParseType.INTEGER.toString());
+
+    verifyBaseClass(object);
+  }
+
+  private void verifyBaseClass(TypeInspectionUUT object) {
+    assertFalse(object.primitiveBoolean__IsList);
+    assertEquals(object.primitiveBoolean__ParseType, TypeUtils.ParseType.BOOLEAN.toString());
+    assertNull(object.primitiveBoolean__ParseTypeGeneratedClass);
+
+    assertFalse(object.boxedBoolean__IsList);
+    assertEquals(object.boxedBoolean__ParseType, TypeUtils.ParseType.BOOLEAN_OBJECT.toString());
+    assertNull(object.boxedBoolean__ParseTypeGeneratedClass);
+
+    assertFalse(object.primitiveInteger__IsList);
+    assertEquals(object.primitiveInteger__ParseType, TypeUtils.ParseType.INTEGER.toString());
+    assertNull(object.primitiveInteger__ParseTypeGeneratedClass);
+
+    assertFalse(object.boxedInteger__IsList);
+    assertEquals(object.boxedInteger__ParseType, TypeUtils.ParseType.INTEGER_OBJECT.toString());
+    assertNull(object.boxedInteger__ParseTypeGeneratedClass);
+
+    assertFalse(object.primitiveLong__IsList);
+    assertEquals(object.primitiveLong__ParseType, TypeUtils.ParseType.LONG.toString());
+    assertNull(object.primitiveLong__ParseTypeGeneratedClass);
+
+    assertFalse(object.boxedLong__IsList);
+    assertEquals(object.boxedLong__ParseType, TypeUtils.ParseType.LONG_OBJECT.toString());
+    assertNull(object.boxedLong__ParseTypeGeneratedClass);
+
+    assertFalse(object.primitiveFloat__IsList);
+    assertEquals(object.primitiveFloat__ParseType, TypeUtils.ParseType.FLOAT.toString());
+    assertNull(object.primitiveFloat__ParseTypeGeneratedClass);
+
+    assertFalse(object.boxedFloat__IsList);
+    assertEquals(object.boxedFloat__ParseType, TypeUtils.ParseType.FLOAT_OBJECT.toString());
+    assertNull(object.boxedFloat__ParseTypeGeneratedClass);
+
+    assertFalse(object.primitiveDouble__IsList);
+    assertEquals(object.primitiveDouble__ParseType, TypeUtils.ParseType.DOUBLE.toString());
+    assertNull(object.primitiveDouble__ParseTypeGeneratedClass);
+
+    assertFalse(object.boxedDouble__IsList);
+    assertEquals(object.boxedDouble__ParseType, TypeUtils.ParseType.DOUBLE_OBJECT.toString());
+    assertNull(object.boxedDouble__ParseTypeGeneratedClass);
+
+    assertFalse(object.enumInstance__IsList);
+    assertEquals(object.enumInstance__ParseType, TypeUtils.ParseType.ENUM_OBJECT.toString());
+    assertNull(object.enumInstance__ParseTypeGeneratedClass);
+
+    assertFalse(object.string__IsList);
+    assertEquals(object.string__ParseType, TypeUtils.ParseType.STRING.toString());
+    assertNull(object.string__ParseTypeGeneratedClass);
+
+    assertTrue(object.integerList__IsList);
+    assertEquals(object.integerList__ParseType, TypeUtils.ParseType.INTEGER_OBJECT.toString());
+    assertNull(object.integerList__ParseTypeGeneratedClass);
+
+    assertFalse(object.integerInheritedList__IsList);
+    assertEquals(object.integerInheritedList__ParseType,
+        TypeUtils.ParseType.UNSUPPORTED.toString());
+    assertNull(object.integerInheritedList__ParseTypeGeneratedClass);
+
+    assertFalse(object.unspecifiedInheritedList__IsList);
+    assertEquals(object.unspecifiedInheritedList__ParseType,
+        TypeUtils.ParseType.UNSUPPORTED.toString());
+    assertNull(object.unspecifiedInheritedList__ParseTypeGeneratedClass);
+
+    assertFalse(object.nestedData__IsList);
+    assertEquals(object.nestedData__ParseType, TypeInspectionUUT.class.getCanonicalName());
+    assertEquals(object.nestedData__ParseTypeGeneratedClass,
+        transformName(TypeInspectionUUT.class.getName()));
+
+    assertFalse(object.nestedInnerClassData__IsList);
+    assertEquals(object.nestedInnerClassData__ParseType,
+        TypeInspectionUUT.InnerClassUUT.class.getCanonicalName());
+    assertEquals(object.nestedInnerClassData__ParseTypeGeneratedClass,
+        transformName(TypeInspectionUUT.InnerClassUUT.class.getName()));
+
+    assertTrue(object.nestedDataList__IsList);
+    assertEquals(object.nestedDataList__ParseType, TypeInspectionUUT.class.getCanonicalName());
+    assertEquals(object.nestedDataList__ParseTypeGeneratedClass,
+        transformName(TypeInspectionUUT.class.getName()));
+
+    assertTrue(object.nestedInnerClassDataList__IsList);
+    assertEquals(object.nestedInnerClassDataList__ParseType,
+        TypeInspectionUUT.InnerClassUUT.class.getCanonicalName());
+    assertEquals(object.nestedInnerClassDataList__ParseTypeGeneratedClass,
+        transformName(TypeInspectionUUT.InnerClassUUT.class.getName()));
+
+  }
+
+  /**
+   * Inner classes are represented in java as OUTER_CLASS$INNER_CLASS.  Since we want to avoid the
+   * usage of $ in the generated class names, we replace the $ with a _.
+   */
+  private String transformName(String stringName) {
+    return stringName.replace('$', '_');
+  }
+}
diff --git a/util/testprocessor/build.gradle b/util/testprocessor/build.gradle
new file mode 100644
index 0000000..0afb606
--- /dev/null
+++ b/util/testprocessor/build.gradle
@@ -0,0 +1,7 @@
+apply plugin: 'java'
+
+dependencies {
+  compile group: 'com.google.guava', name: 'guava', version: '10.0.1+'
+  compile project(':util')
+  compile project(':javawriter')
+}
diff --git a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/FieldData.java b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/FieldData.java
new file mode 100644
index 0000000..c67528b
--- /dev/null
+++ b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/FieldData.java
@@ -0,0 +1,14 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.util;
+
+/**
+ * Records the data we gathered about each field.
+ */
+class FieldData {
+
+  boolean mIsList;
+  TypeUtils.ParseType mParseType;
+  String mParsableType;
+  String mParsableTypeGeneratedClass;
+}
diff --git a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/MarkedTypes.java b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/MarkedTypes.java
new file mode 100644
index 0000000..038bd2d
--- /dev/null
+++ b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/MarkedTypes.java
@@ -0,0 +1,16 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.util;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.CLASS;
+
+/**
+ * Annotation we apply to classes we want to run the test annotation processor on.
+ */
+@Retention(CLASS) @Target(TYPE)
+@interface MarkedTypes {
+}
diff --git a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TestAnnotationProcessor.java b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TestAnnotationProcessor.java
new file mode 100644
index 0000000..0bfbeaa
--- /dev/null
+++ b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TestAnnotationProcessor.java
@@ -0,0 +1,259 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.util;
+
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+
+import javax.annotation.processing.*;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.JavaFileObject;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.lang.annotation.Annotation;
+import java.util.Map;
+import java.util.Set;
+
+import static javax.lang.model.element.ElementKind.CLASS;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+/**
+ * This annotation processor generates a class that traverses the fields of a class and records
+ * information about the declared types of the fields.
+ */
+public class TestAnnotationProcessor extends AbstractProcessor {
+
+  public static final String TYPE_DATA_SUFFIX = "__Test";
+
+  private Elements mElements;
+  private Types mTypes;
+  private Filer mFiler;
+  private TypeUtils mTypeUtils;
+  private static class State {
+    private Map<TypeElement, TypeGathererClassData> mClassElementToInjectorMap;
+
+    State() {
+      mClassElementToInjectorMap = Maps.newHashMap();
+    }
+  }
+  private State mState;
+
+  @Override
+  public synchronized void init(ProcessingEnvironment env) {
+    super.init(env);
+
+    mElements = env.getElementUtils();
+    mTypes = env.getTypeUtils();
+    mFiler = env.getFiler();
+    mTypeUtils = new TypeUtils(mTypes, /*Console.getNullMessager()*/ env.getMessager());
+  }
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    Set<String> supportTypes = Sets.newLinkedHashSet();
+    supportTypes.add(TypeTesting.class.getCanonicalName());
+    supportTypes.add(MarkedTypes.class.getCanonicalName());
+
+    return supportTypes;
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
+    try {
+      // each round of processing requires a clean state.
+      mState = new State();
+
+      gatherClassAnnotations(env);
+      gatherFieldAnnotations(env);
+
+      for (Map.Entry<TypeElement, TypeGathererClassData> entry :
+          mState.mClassElementToInjectorMap.entrySet()) {
+        TypeElement typeElement = entry.getKey();
+        TypeGathererClassData injector = entry.getValue();
+
+        try {
+          JavaFileObject jfo = mFiler.createSourceFile(injector.getInjectedFqcn(), typeElement);
+          Writer writer = jfo.openWriter();
+          writer.write(injector.getJavaCode(Console.getNullMessager()));
+          writer.flush();
+          writer.close();
+        } catch (IOException e) {
+          error(typeElement, "Unable to write injector for type %s: %s",
+              typeElement, e.getMessage());
+        }
+      }
+
+      return true;
+    } catch (Throwable ex) {
+      error("exception: %s cause: %s", ex.toString(), ex.getCause());
+      return false;
+    }
+  }
+
+  private void gatherClassAnnotations(RoundEnvironment env) {
+    // Process each @TypeTesting elements.
+    for (Element element : env.getElementsAnnotatedWith(MarkedTypes.class)) {
+      try {
+        processClassAnnotation(element);
+      } catch (Exception e) {
+        StringWriter stackTrace = new StringWriter();
+        e.printStackTrace(new PrintWriter(stackTrace));
+
+        error(element, "Unable to generate view injector for @TypeTesting.\n\n%s",
+            stackTrace.toString());
+      }
+    }
+
+    for (Map.Entry<TypeElement, TypeGathererClassData> entry :
+        mState.mClassElementToInjectorMap.entrySet()) {
+      TypeMirror superclass = entry.getKey().getSuperclass();
+
+      // walk up the superclass hierarchy until we find another class we know about.
+      while (superclass.getKind() != TypeKind.NONE) {
+        TypeElement element = (TypeElement) mTypes.asElement(superclass);
+
+        TypeGathererClassData injector = mState.mClassElementToInjectorMap.get(element);
+        if (injector != null) {
+          entry.getValue().setParentClassData(injector);
+          break;
+        }
+
+        superclass = element.getSuperclass();
+      }
+    }
+  }
+
+  private void processClassAnnotation(Element element) {
+    TypeElement typeElement = (TypeElement) element;
+
+    // Verify containing class visibility is not private.
+    if (element.getModifiers().contains(PRIVATE)) {
+      error(element, "@%s %s may not be applied to private classes. (%s.%s)",
+          MarkedTypes.class.getSimpleName(), typeElement.getQualifiedName(),
+          element.getSimpleName());
+      return;
+    }
+
+    TypeGathererClassData injector = mState.mClassElementToInjectorMap.get(typeElement);
+    if (injector == null) {
+      String packageName = mTypeUtils.getPackageName(mElements, typeElement);
+      injector = new TypeGathererClassData(
+          packageName,
+          typeElement.getQualifiedName().toString(),
+          mTypeUtils.getPrefixForGeneratedClass(typeElement, packageName) + TYPE_DATA_SUFFIX,
+          new ProcessorClassData.AnnotationRecordFactory<String, FieldData>() {
+
+            @Override
+            public FieldData createAnnotationRecord(String key) {
+              return new FieldData();
+            }
+          });
+      mState.mClassElementToInjectorMap.put(typeElement, injector);
+    }
+  }
+
+  private void gatherFieldAnnotations(RoundEnvironment env) {
+    // Process each @TypeTesting elements.
+    for (Element element : env.getElementsAnnotatedWith(TypeTesting.class)) {
+      try {
+        processFieldAnnotation(element);
+      } catch (Exception e) {
+        StringWriter stackTrace = new StringWriter();
+        e.printStackTrace(new PrintWriter(stackTrace));
+
+        error(element, "Unable to generate view injector for @TypeTesting.\n\n%s",
+            stackTrace.toString());
+      }
+    }
+  }
+
+  private void processFieldAnnotation(Element element) {
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify common generated code restrictions.
+    if (!isFieldAnnotationValid(TypeTesting.class, element)) {
+      return;
+    }
+
+    TypeMirror type = element.asType();
+
+    TypeGathererClassData injector = mState.mClassElementToInjectorMap.get(enclosingElement);
+
+    FieldData data = injector.getOrCreateRecord(element.getSimpleName().toString());
+    if (data.mIsList = mTypeUtils.isListType(type)) {
+      // inspect the inner type.
+      type = mTypeUtils.getListParameterizedType(type);
+    }
+
+    data.mParseType = mTypeUtils.getParseType(type, MarkedTypes.class);
+    if (data.mParseType == TypeUtils.ParseType.PARSABLE_OBJECT) {
+      TypeMirror erasedType = mTypes.erasure(type);
+      DeclaredType declaredType = (DeclaredType) erasedType;
+      TypeElement typeElement = (TypeElement) declaredType.asElement();
+
+      String packageName = mTypeUtils.getPackageName(mElements, typeElement);
+      String className = mTypeUtils.getClassName(typeElement, packageName);
+      String parserClassName = mTypeUtils.getPrefixForGeneratedClass(typeElement, packageName);
+
+      data.mParsableType = packageName + "." + className;
+      data.mParsableTypeGeneratedClass = packageName + "." + parserClassName;
+    }
+  }
+
+  private boolean isFieldAnnotationValid(Class<? extends Annotation> annotationClass,
+      Element element) {
+    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
+
+    // Verify containing type.
+    if (enclosingElement.getKind() != CLASS) {
+      error(enclosingElement, "@%s field may only be contained in classes. (%s.%s)",
+          annotationClass.getSimpleName(), enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      return false;
+    }
+
+    Annotation annotation = enclosingElement.getAnnotation(MarkedTypes.class);
+    if (annotation == null) {
+      error(enclosingElement,
+          "@%s field may only be contained in classes annotated with @%s (%s.%s)",
+          annotationClass.getSimpleName(),
+          MarkedTypes.class.toString(),
+          enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      return false;
+    }
+
+    // Verify containing class visibility is not private.
+    if (enclosingElement.getModifiers().contains(PRIVATE)) {
+      error(enclosingElement, "@%s %s may not be contained in private classes. (%s.%s)",
+          annotationClass.getSimpleName(),
+          enclosingElement.getQualifiedName(),
+          element.getSimpleName());
+      return false;
+    }
+
+    return true;
+  }
+
+  private void error(String message, Object... args) {
+    Console.error(processingEnv.getMessager(), message, args);
+  }
+
+  private void error(Element element, String message, Object... args) {
+    Console.error(processingEnv.getMessager(), element, message, args);
+  }
+}
diff --git a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeGathererClassData.java b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeGathererClassData.java
new file mode 100644
index 0000000..fa98393
--- /dev/null
+++ b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeGathererClassData.java
@@ -0,0 +1,105 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.util;
+
+import javax.annotation.processing.Messager;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.Map;
+
+import com.squareup.javawriter.JavaWriter;
+
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+/**
+ * This gathers data about the declared types of annotated fields and writes code to mutate fields
+ * to record that information.
+ * <p/>
+ * If a field's name is XXX, then it generates code to write:
+ * <ul>
+ *    <li>XXX__IsList - whether a field is a list or a scalar.</li>
+ *    <li>XXX__ParseType - the {@link TypeUtils.ParseType} that best matches the field.</li>
+ * </ul>
+ *
+ * As an example, a field declared as <code>int foo;</code>
+ * Will generate the following code:<pre>
+ *    foo__IsList = false;
+ *    foo__ParseType = "INTEGER";
+ * </pre>
+ */
+public class TypeGathererClassData extends ProcessorClassData<String, FieldData> {
+  private TypeGathererClassData mParentClassData;
+
+  public TypeGathererClassData(String classPackage, String className, String injectedClassName,
+      AnnotationRecordFactory<String, FieldData> factory) {
+    super(classPackage, className, injectedClassName, factory);
+  }
+
+  @Override
+  public String getJavaCode(Messager messager) {
+    StringWriter sw = new StringWriter();
+    JavaWriter writer = new JavaWriter(sw);
+
+    try {
+      writer.emitPackage(mClassPackage)
+          .beginType(mInjectedClassName, "class", EnumSet.of(PUBLIC, FINAL))
+            .beginMethod("void", "injectTypeData", EnumSet.of(PUBLIC, FINAL, STATIC),
+                mClassName, "instance")
+              .emitWithGenerator(new JavaWriter.JavaGenerator() {
+                @Override
+                public void emitJava(JavaWriter writer) throws IOException {
+                  TypeGathererClassData classWalker = TypeGathererClassData.this;
+                  while (classWalker != null) {
+                    classWalker.writeFields(writer);
+                    classWalker = classWalker.getParentClassData();
+                  }
+                }
+              })
+            .endMethod()
+          .endType();
+    } catch (IOException ex) {
+      Console.error(messager, "IOException while generating %s: %s",
+          mInjectedClassName, ex.toString());
+    }
+
+    return sw.toString();
+  }
+
+  protected void writeFields(JavaWriter writer) throws IOException {
+    for (Map.Entry<String, FieldData> entry : getIterator()) {
+      writer.emitStatement("instance.%s__IsList = %s", entry.getKey(), entry.getValue().mIsList);
+
+      String parseTypeString;
+      if (entry.getValue().mParseType == TypeUtils.ParseType.PARSABLE_OBJECT) {
+        parseTypeString = entry.getValue().mParsableType;
+      } else {
+        parseTypeString = entry.getValue().mParseType.toString();
+      }
+      writer.emitStatement("instance.%s__ParseType = \"%s\"", entry.getKey(), parseTypeString);
+
+      String parseTypeGeneratedClass = entry.getValue().mParsableTypeGeneratedClass;
+      writer.emitStatement("instance.%s__ParseTypeGeneratedClass = %s",
+          entry.getKey(),
+          parseTypeGeneratedClass == null ? null : '\"' + parseTypeGeneratedClass + '\"');
+    }
+  }
+
+  /**
+   * Sets the class data structure for the parent class.
+   */
+  void setParentClassData(TypeGathererClassData parentClassData) {
+    mParentClassData = parentClassData;
+  }
+
+  /**
+   * Retrieves the class data structure for the parent class.
+   * @return
+   */
+  private TypeGathererClassData getParentClassData() {
+    return mParentClassData;
+  }
+}
diff --git a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeTesting.java b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeTesting.java
new file mode 100644
index 0000000..213b7c0
--- /dev/null
+++ b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeTesting.java
@@ -0,0 +1,16 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.util;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.CLASS;
+
+/**
+ * Applied to each field we want the annotation processor to understand.
+ */
+@Retention(CLASS) @Target(FIELD)
+@interface TypeTesting {
+}
diff --git a/util/testuut/build.gradle b/util/testuut/build.gradle
new file mode 100644
index 0000000..7628375
--- /dev/null
+++ b/util/testuut/build.gradle
@@ -0,0 +1,12 @@
+apply plugin: 'java'
+
+compileJava {
+  options.compilerArgs += [
+                       '-processor',
+                       'com.instagram.common.json.annotation.util.TestAnnotationProcessor'
+  ]
+}
+dependencies {
+  compile group: 'com.google.guava', name: 'guava', version: '10.0.1+'
+  compile project(':util:testprocessor')
+}
diff --git a/util/testuut/src/main/java/com/instagram/common/json/annotation/util/SubclassUUT.java b/util/testuut/src/main/java/com/instagram/common/json/annotation/util/SubclassUUT.java
new file mode 100644
index 0000000..23b4aad
--- /dev/null
+++ b/util/testuut/src/main/java/com/instagram/common/json/annotation/util/SubclassUUT.java
@@ -0,0 +1,18 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.util;
+
+/**
+ * Subclass of the type inspection unit under test.  This allows us to verify that we can traverse
+ * the type hierarchy correctly.
+ */
+@MarkedTypes
+class SubclassUUT extends TypeInspectionUUT {
+
+  @TypeTesting
+  int subclassInteger;
+
+  boolean subclassInteger__IsList;
+  String subclassInteger__ParseType;
+  String subclassInteger__ParseTypeGeneratedClass;
+}
diff --git a/util/testuut/src/main/java/com/instagram/common/json/annotation/util/TypeInspectionUUT.java b/util/testuut/src/main/java/com/instagram/common/json/annotation/util/TypeInspectionUUT.java
new file mode 100644
index 0000000..08cbd26
--- /dev/null
+++ b/util/testuut/src/main/java/com/instagram/common/json/annotation/util/TypeInspectionUUT.java
@@ -0,0 +1,172 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.util;
+
+import java.util.List;
+
+/**
+ * Basic class that contains all the supported types.
+ */
+@MarkedTypes
+class TypeInspectionUUT {
+
+  //////
+  // primitives and their boxed counterparts.
+  @TypeTesting
+  boolean primitiveBoolean;
+
+  boolean primitiveBoolean__IsList;
+  String primitiveBoolean__ParseType;
+  String primitiveBoolean__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  Boolean boxedBoolean;
+
+  boolean boxedBoolean__IsList;
+  String boxedBoolean__ParseType;
+  String boxedBoolean__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  int primitiveInteger;
+
+  boolean primitiveInteger__IsList;
+  String primitiveInteger__ParseType;
+  String primitiveInteger__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  Integer boxedInteger;
+
+  boolean boxedInteger__IsList;
+  String boxedInteger__ParseType;
+  String boxedInteger__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  long primitiveLong;
+
+  boolean primitiveLong__IsList;
+  String primitiveLong__ParseType;
+  String primitiveLong__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  Long boxedLong;
+
+  boolean boxedLong__IsList;
+  String boxedLong__ParseType;
+  String boxedLong__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  float primitiveFloat;
+
+  boolean primitiveFloat__IsList;
+  String primitiveFloat__ParseType;
+  String primitiveFloat__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  Float boxedFloat;
+
+  boolean boxedFloat__IsList;
+  String boxedFloat__ParseType;
+  String boxedFloat__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  double primitiveDouble;
+
+  boolean primitiveDouble__IsList;
+  String primitiveDouble__ParseType;
+  String primitiveDouble__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  Double boxedDouble;
+
+  boolean boxedDouble__IsList;
+  String boxedDouble__ParseType;
+  String boxedDouble__ParseTypeGeneratedClass;
+
+  enum Foo {
+    VALUE0,
+    VALUE1,
+  };
+
+  @TypeTesting
+  Foo enumInstance;
+
+  boolean enumInstance__IsList;
+  String enumInstance__ParseType;
+  String enumInstance__ParseTypeGeneratedClass;
+
+  //////
+  // strings.
+  @TypeTesting
+  String string;
+
+  boolean string__IsList;
+  String string__ParseType;
+  String string__ParseTypeGeneratedClass;
+
+  //////
+  // collection types.
+  @TypeTesting
+  List<Integer> integerList;
+
+  boolean integerList__IsList;
+  String integerList__ParseType;
+  String integerList__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  InheritedExtendsSpecifiesType integerInheritedList;
+
+  boolean integerInheritedList__IsList;
+  String integerInheritedList__ParseType;
+  String integerInheritedList__ParseTypeGeneratedClass;
+
+  private abstract static class InheritedExtendsSpecifiesType implements List<Integer> {}
+
+  @TypeTesting
+  InheritedExtendsNoType unspecifiedInheritedList;
+
+  boolean unspecifiedInheritedList__IsList;
+  String unspecifiedInheritedList__ParseType;
+  String unspecifiedInheritedList__ParseTypeGeneratedClass;
+
+  private abstract static class InheritedExtendsNoType implements List {}
+
+  //////
+  // nesting
+  @TypeTesting
+  TypeInspectionUUT nestedData;
+
+  boolean nestedData__IsList;
+  String nestedData__ParseType;
+  String nestedData__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  InnerClassUUT nestedInnerClassData;
+
+  boolean nestedInnerClassData__IsList;
+  String nestedInnerClassData__ParseType;
+  String nestedInnerClassData__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  List<TypeInspectionUUT> nestedDataList;
+
+  boolean nestedDataList__IsList;
+  String nestedDataList__ParseType;
+  String nestedDataList__ParseTypeGeneratedClass;
+
+  @TypeTesting
+  List<InnerClassUUT> nestedInnerClassDataList;
+
+  boolean nestedInnerClassDataList__IsList;
+  String nestedInnerClassDataList__ParseType;
+  String nestedInnerClassDataList__ParseTypeGeneratedClass;
+
+  @MarkedTypes
+  public static class InnerClassUUT {
+    @TypeTesting
+    String string;
+
+    boolean string__IsList;
+    String string__ParseType;
+    String string__ParseTypeGeneratedClass;
+  }
+}

commit 50147d096080183a33b35be8f7a306e1331011ad
Author: Tony Tung <tonytung@merly.org>
Date:   Fri Sep 5 21:23:51 2014 -0700

    Sync from repo as of d5952274397e
    
    Properly handle abstract classes.
    Container classes can be Lists or Queues.

diff --git a/common/src/main/java/com/instagram/common/json/annotation/JsonField.java b/common/src/main/java/com/instagram/common/json/annotation/JsonField.java
index 2d7e349..a6fe545 100644
--- a/common/src/main/java/com/instagram/common/json/annotation/JsonField.java
+++ b/common/src/main/java/com/instagram/common/json/annotation/JsonField.java
@@ -24,7 +24,7 @@ public @interface JsonField {
    * If a {@link TypeMapping#COERCED} mapping is requested, we will do our best to coerce it into
    * the proper type.
    */
-  public enum TypeMapping { EXACT, COERCED };
+  public enum TypeMapping { EXACT, COERCED }
 
   /**
    * This is the field name in json.
diff --git a/processor/build.gradle b/processor/build.gradle
index 0d32f54..f333aa8 100644
--- a/processor/build.gradle
+++ b/processor/build.gradle
@@ -9,6 +9,7 @@ dependencies {
   compile project(':javawriter')
   compile project(':util')
   compile project(':common')
+  testCompile group: 'com.google.guava', name: 'guava', version: '12.0.1+'
   testCompile group: 'junit', name: 'junit', version: '4.8.2+'
   testCompile project(':processor:support')
   testCompile project(':processor:testuut')
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonAnnotationProcessor.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonAnnotationProcessor.java
index bafe6e9..63cf290 100644
--- a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonAnnotationProcessor.java
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonAnnotationProcessor.java
@@ -22,6 +22,7 @@ import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.io.Writer;
 import java.lang.annotation.Annotation;
+import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
@@ -33,11 +34,8 @@ import com.instagram.common.json.annotation.util.Console;
 import com.instagram.common.json.annotation.util.ProcessorClassData;
 import com.instagram.common.json.annotation.util.TypeUtils;
 
-import com.google.common.base.Strings;
-import com.google.common.collect.Maps;
-
 import static javax.lang.model.element.ElementKind.CLASS;
-import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.*;
 
 /**
  * This annotation processor is run at compile time to find classes annotated with {@link JsonType}.
@@ -53,7 +51,7 @@ public class JsonAnnotationProcessor extends AbstractProcessor {
     private Map<TypeElement, JsonParserClassData> mClassElementToInjectorMap;
 
     State() {
-      mClassElementToInjectorMap = Maps.newHashMap();
+      mClassElementToInjectorMap = new HashMap<TypeElement, JsonParserClassData>();
     }
   }
   private State mState;
@@ -141,6 +139,7 @@ public class JsonAnnotationProcessor extends AbstractProcessor {
    * class is public and creates an {@link ProcessorClassData} for it.
    */
   private void processClassAnnotation(Element element) {
+    boolean abstractClass = false;
     TypeElement typeElement = (TypeElement) element;
 
     // Verify containing class visibility is not private.
@@ -150,6 +149,9 @@ public class JsonAnnotationProcessor extends AbstractProcessor {
           element.getSimpleName());
       return;
     }
+    if (element.getModifiers().contains(ABSTRACT)) {
+      abstractClass = true;
+    }
 
     JsonParserClassData injector = mState.mClassElementToInjectorMap.get(typeElement);
     if (injector == null) {
@@ -187,6 +189,7 @@ public class JsonAnnotationProcessor extends AbstractProcessor {
               return new TypeData();
             }
           },
+          abstractClass,
           annotation.postprocessingEnabled(),
           parentGeneratedClassName);
       mState.mClassElementToInjectorMap.put(typeElement, injector);
@@ -236,11 +239,12 @@ public class JsonAnnotationProcessor extends AbstractProcessor {
     data.setValueExtractFormatter(annotation.valueExtractFormatter());
     data.setAssignmentFormatter(annotation.fieldAssignmentFormatter());
     data.setSerializeCodeFormatter(annotation.serializeCodeFormatter());
+    TypeUtils.CollectionType collectionType = mTypeUtils.getCollectionType(type);
+    data.setCollectionType(collectionType);
 
-    if (mTypeUtils.isListType(type)) {
+    if (collectionType != TypeUtils.CollectionType.NOT_A_COLLECTION) {
       // inspect the inner type.
-      data.setInCollection(true);
-      type = mTypeUtils.getListParameterizedType(type);
+      type = mTypeUtils.getCollectionParameterizedType(type);
     }
 
     data.setParseType(mTypeUtils.getParseType(type, JsonType.class));
@@ -257,8 +261,8 @@ public class JsonAnnotationProcessor extends AbstractProcessor {
       data.setParsableTypeParserClass(packageName + "." + parserClassName);
     } else if (data.getParseType() == TypeUtils.ParseType.ENUM_OBJECT) {
       // verify that we have value extract and serializer formatters.
-      if (Strings.isNullOrEmpty(annotation.valueExtractFormatter()) ||
-          Strings.isNullOrEmpty(annotation.serializeCodeFormatter())) {
+      if (StringUtil.isNullOrEmpty(annotation.valueExtractFormatter()) ||
+          StringUtil.isNullOrEmpty(annotation.serializeCodeFormatter())) {
         error(element,
             "%s: enums must have both value extract formatters and serialize code formatters",
             enclosingElement);
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java
index d6cdd5d..cb41d7d 100644
--- a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java
@@ -8,6 +8,7 @@ import java.io.IOException;
 import java.io.StringWriter;
 import java.util.Arrays;
 import java.util.EnumSet;
+import java.util.HashMap;
 import java.util.Map;
 
 import com.instagram.common.json.JsonAnnotationProcessorConstants;
@@ -17,8 +18,6 @@ import com.instagram.common.json.annotation.util.Console;
 import com.instagram.common.json.annotation.util.ProcessorClassData;
 import com.instagram.common.json.annotation.util.TypeUtils;
 
-import com.google.common.base.Strings;
-import com.google.common.collect.Maps;
 import com.squareup.javawriter.JavaWriter;
 
 import static javax.lang.model.element.Modifier.*;
@@ -29,15 +28,18 @@ import static javax.lang.model.element.Modifier.*;
  */
 public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
 
+  private final boolean mAbstractClass;
   private final boolean mPostprocessingEnabled;
   private final String mParentInjectedClassName;
 
   public JsonParserClassData(
       String classPackage, String className, String injectedClassName,
       AnnotationRecordFactory<String, TypeData> factory,
+      boolean abstractClass,
       boolean postprocessingEnabled,
       String parentInjectedClassName) {
     super(classPackage, className, injectedClassName, factory);
+    mAbstractClass = abstractClass;
     mPostprocessingEnabled = postprocessingEnabled;
     mParentInjectedClassName = parentInjectedClassName;
   }
@@ -53,8 +55,10 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
       writer.emitImports(
           "java.io.IOException",
           "java.io.StringWriter",
+          "java.util.ArrayDeque",
           "java.util.ArrayList",
           "java.util.List",
+          "java.util.Queue",
           "com.fasterxml.jackson.core.JsonGenerator",
           "com.fasterxml.jackson.core.JsonParser",
           "com.fasterxml.jackson.core.JsonToken",
@@ -66,31 +70,33 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
       String returnValue = mPostprocessingEnabled ?
           ("instance." + JsonType.POSTPROCESSING_METHOD_NAME + "()") : "instance";
 
-      writer
-            .beginMethod(
-                mClassName,
-                "parseFromJson",
-                EnumSet.of(PUBLIC, STATIC, FINAL),
-                Arrays.asList("JsonParser", "jp"),
-                Arrays.asList("IOException"))
-              .emitStatement("%s instance = new %s()", mClassName, mClassName)
-              .emitSingleLineComment("validate that we're on the right token")
-              .beginControlFlow("if (jp.getCurrentToken() != JsonToken.START_OBJECT)")
-                .emitStatement("jp.skipChildren()")
-                .emitStatement("return null")
-              .endControlFlow()
-              .beginControlFlow("while (jp.nextToken() != JsonToken.END_OBJECT)")
-                .emitStatement("String fieldName = jp.getCurrentName()")
-                .emitStatement("jp.nextToken()")
-                .emitStatement("processSingleField(instance, fieldName, jp)")
-                // always skip children.  if we expected an array or an object, we would have
-                // consumed the START_ARRAY or START_OBJECT.  therefore, we would only skip forward
-                // if we're seeing something unexpected.
-                .emitStatement("jp.skipChildren()")
-              .endControlFlow()
-              .emitStatement("return %s", returnValue)
-            .endMethod()
-            .emitEmptyLine();
+      if (!mAbstractClass) {
+        writer
+              .beginMethod(
+                  mClassName,
+                  "parseFromJson",
+                  EnumSet.of(PUBLIC, STATIC, FINAL),
+                  Arrays.asList("JsonParser", "jp"),
+                  Arrays.asList("IOException"))
+                .emitStatement("%s instance = new %s()", mClassName, mClassName)
+                .emitSingleLineComment("validate that we're on the right token")
+                .beginControlFlow("if (jp.getCurrentToken() != JsonToken.START_OBJECT)")
+                  .emitStatement("jp.skipChildren()")
+                  .emitStatement("return null")
+                .endControlFlow()
+                .beginControlFlow("while (jp.nextToken() != JsonToken.END_OBJECT)")
+                  .emitStatement("String fieldName = jp.getCurrentName()")
+                  .emitStatement("jp.nextToken()")
+                  .emitStatement("processSingleField(instance, fieldName, jp)")
+                  // always skip children.  if we expected an array or an object, we would have
+                  // consumed the START_ARRAY or START_OBJECT.  therefore, we would only skip
+                  // forward if we're seeing something unexpected.
+                  .emitStatement("jp.skipChildren()")
+                .endControlFlow()
+                .emitStatement("return %s", returnValue)
+              .endMethod()
+              .emitEmptyLine();
+      }
 
       writer
           .beginMethod(
@@ -118,19 +124,21 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
           .endMethod()
           .emitEmptyLine();
 
-      writer
-          .beginMethod(
-              mClassName,
-              "parseFromJson",
-              EnumSet.of(PUBLIC, STATIC, FINAL),
-              Arrays.asList("String", "inputString"),
-              Arrays.asList("IOException"))
-            .emitStatement(
-                "JsonParser jp = JsonFactoryHolder.APP_FACTORY.createParser(inputString)")
-            .emitStatement("jp.nextToken()")
-            .emitStatement("return parseFromJson(jp)")
-          .endMethod()
-          .emitEmptyLine();
+      if (!mAbstractClass) {
+        writer
+              .beginMethod(
+                  mClassName,
+                  "parseFromJson",
+                  EnumSet.of(PUBLIC, STATIC, FINAL),
+                  Arrays.asList("String", "inputString"),
+                  Arrays.asList("IOException"))
+              .emitStatement(
+                  "JsonParser jp = JsonFactoryHolder.APP_FACTORY.createParser(inputString)")
+              .emitStatement("jp.nextToken()")
+              .emitStatement("return parseFromJson(jp)")
+              .endMethod()
+              .emitEmptyLine();
+      }
 
       writer
             .beginMethod(
@@ -150,8 +158,7 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
                     public void emitJava(JavaWriter writer) throws IOException {
                       JsonParserClassData.this.writeSerializeCalls(messager, writer);
 
-                      // if we reached here, we need to call the superclasses processSingleField
-                      // method.
+                      // if we have a superclass, we need to call its serialize method.
                       if (mParentInjectedClassName != null) {
                         writer.emitStatement(mParentInjectedClassName +
                                 ".serializeToJson(generator, object, false)");
@@ -165,22 +172,24 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
             .endMethod()
             .emitEmptyLine();
 
-      writer
-          .beginMethod(
-              "String",
-              "serializeToJson",
-              EnumSet.of(PUBLIC, STATIC, FINAL),
-              Arrays.asList(mClassName, "object"),
-              Arrays.asList("IOException"))
-          .emitStatement("StringWriter stringWriter = new StringWriter()")
-          .emitStatement(
-              "JsonGenerator generator = " +
-                  "JsonFactoryHolder.APP_FACTORY.createGenerator(stringWriter)")
-          .emitStatement("serializeToJson(generator, object, true)")
-          .emitStatement("generator.close()")
-          .emitStatement("return stringWriter.toString()")
-          .endMethod()
-          .emitEmptyLine();
+      if (!mAbstractClass) {
+        writer
+            .beginMethod(
+                "String",
+                "serializeToJson",
+                EnumSet.of(PUBLIC, STATIC, FINAL),
+                Arrays.asList(mClassName, "object"),
+                Arrays.asList("IOException"))
+            .emitStatement("StringWriter stringWriter = new StringWriter()")
+            .emitStatement(
+                "JsonGenerator generator = " +
+                    "JsonFactoryHolder.APP_FACTORY.createGenerator(stringWriter)")
+            .emitStatement("serializeToJson(generator, object, true)")
+            .emitStatement("generator.close()")
+            .emitStatement("return stringWriter.toString()")
+            .endMethod()
+            .emitEmptyLine();
+      }
 
       writer.endType();
     } catch (IOException ex) {
@@ -209,10 +218,10 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
         writer.nextControlFlow("else if (\"" + data.getFieldName() + "\".equals(fieldName))");
       }
 
-      if (data.isInCollection()) {
+      if (data.getCollectionType() != TypeUtils.CollectionType.NOT_A_COLLECTION) {
         generateArrayParser(messager, writer, data);
         String assignmentFormatter = data.getAssignmentFormatter();
-        if (Strings.isNullOrEmpty(assignmentFormatter)) {
+        if (StringUtil.isNullOrEmpty(assignmentFormatter)) {
           assignmentFormatter = DEFAULT_ASSIGNMENT_FORMATTER;
         }
         writer.emitStatement(
@@ -224,7 +233,7 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
       } else {
         String rValue = generateExtractRvalue(data);
         String assignmentFormatter = data.getAssignmentFormatter();
-        if (Strings.isNullOrEmpty(assignmentFormatter)) {
+        if (StringUtil.isNullOrEmpty(assignmentFormatter)) {
           assignmentFormatter = DEFAULT_ASSIGNMENT_FORMATTER;
         }
         writer.emitStatement(
@@ -251,9 +260,12 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
   private void generateArrayParser(Messager messager, JavaWriter writer, TypeData data)
       throws IOException {
     String innerType = getJavaType(messager, data);
-    writer.emitStatement("List<%s> results = null", innerType)
+    String interfaceType = mapCollectionTypeToInterfaceType(data.getCollectionType());
+    String concreteType = mapCollectionTypeToConcreteType(data.getCollectionType());
+
+    writer.emitStatement("%s<%s> results = null", interfaceType, innerType)
           .beginControlFlow("if (jp.getCurrentToken() == JsonToken.START_ARRAY)")
-            .emitStatement("results = new ArrayList<%s>()", innerType)
+            .emitStatement("results = new %s<%s>()", concreteType, innerType)
             .beginControlFlow("while (jp.nextToken() != JsonToken.END_ARRAY)")
               .emitStatement("%s parsed = %s", innerType, generateExtractRvalue(data))
               .beginControlFlow("if (parsed != null)")
@@ -269,7 +281,7 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
    */
   private String generateExtractRvalue(TypeData data) {
     String valueExtractFormatter = data.getValueExtractFormatter();
-    if (Strings.isNullOrEmpty(valueExtractFormatter)) {
+    if (StringUtil.isNullOrEmpty(valueExtractFormatter)) {
       if (data.getParseType() == TypeUtils.ParseType.PARSABLE_OBJECT) {
         valueExtractFormatter = PARSABLE_OBJECT_VALUE_EXTRACT_FORMATTER;
       } else {
@@ -309,9 +321,13 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
   private static String PARSABLE_OBJECT_VALUE_EXTRACT_FORMATTER =
       "${subobject_helper_class}.parseFromJson(${parser_object})";
 
-  private static Map<TypeUtils.ParseType, String> sExactFormatters = Maps.newHashMap();
-  private static Map<TypeUtils.ParseType, String> sCoercedFormatters = Maps.newHashMap();
-  private static Map<TypeUtils.ParseType, String> sJavaTypes = Maps.newHashMap();
+  private static Map<TypeUtils.ParseType, String> sExactFormatters =
+      new HashMap<TypeUtils.ParseType, String>();
+  private static Map<TypeUtils.ParseType, String> sCoercedFormatters =
+      new HashMap<TypeUtils.ParseType, String>();
+  private static Map<TypeUtils.ParseType, String> sJavaTypes =
+      new HashMap<TypeUtils.ParseType, String>();
+
   static {
     sExactFormatters.put(TypeUtils.ParseType.BOOLEAN, "${parser_object}.getBooleanValue()");
     sExactFormatters.put(TypeUtils.ParseType.BOOLEAN_OBJECT,
@@ -355,7 +371,8 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
     sCoercedFormatters.put(TypeUtils.ParseType.DOUBLE, "${parser_object}.getValueAsDouble()");
     sCoercedFormatters.put(
         TypeUtils.ParseType.DOUBLE_OBJECT, "Double.valueOf(${parser_object}.getValueAsDouble())");
-    sCoercedFormatters.put(TypeUtils.ParseType.STRING, "${parser_object}.getText()");
+    sCoercedFormatters.put(TypeUtils.ParseType.STRING,
+        "(${parser_object}.getCurrentToken() == JsonToken.VALUE_NULL ? null : ${parser_object}.getText())");
 
     sJavaTypes.put(TypeUtils.ParseType.BOOLEAN_OBJECT, "Boolean");
     sJavaTypes.put(TypeUtils.ParseType.INTEGER_OBJECT, "Integer");
@@ -373,8 +390,8 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
       TypeData data = entry.getValue();
       String serializeCode = data.getSerializeCodeFormatter();
 
-      if (data.isInCollection()) {
-        if (Strings.isNullOrEmpty(serializeCode)) {
+      if (data.getCollectionType() != TypeUtils.CollectionType.NOT_A_COLLECTION) {
+        if (StringUtil.isNullOrEmpty(serializeCode)) {
           if (data.getParseType() == TypeUtils.ParseType.PARSABLE_OBJECT) {
             serializeCode = PARSABLE_OBJECT_ARRAY_SERIALIZE_CALL;
           } else {
@@ -382,6 +399,8 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
           }
         }
 
+        // needed to do a typecast for erased types
+        String interfaceType = mapCollectionTypeToInterfaceType(data.getCollectionType());
         String listType = getJavaType(messager, entry.getValue());
 
         writer
@@ -389,7 +408,8 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
               .emitStatement("generator.writeFieldName(\"%s\")", data.getFieldName())
               .emitStatement("generator.writeStartArray()")
               .beginControlFlow("for (" + listType +
-                  " element : (List<" + listType + ">) object." + entry.getKey() + ")")
+                  " element : (" + interfaceType + "<" + listType + ">)" +
+                  "object." + entry.getKey() + ")")
                 .beginControlFlow("if (element != null)")
                   .emitStatement(
                       StrFormat.createStringFormatter(serializeCode)
@@ -405,7 +425,7 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
             .endControlFlow();
       } else {
         if (data.getParseType() == TypeUtils.ParseType.PARSABLE_OBJECT) {
-          if (Strings.isNullOrEmpty(serializeCode)) {
+          if (StringUtil.isNullOrEmpty(serializeCode)) {
             serializeCode = PARSABLE_OBJECT_SERIALIZE_CALL;
           }
           writer
@@ -422,7 +442,7 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
                         .format())
               .endControlFlow();
         } else {
-          if (Strings.isNullOrEmpty(serializeCode)) {
+          if (StringUtil.isNullOrEmpty(serializeCode)) {
             serializeCode = mScalarSerializeCalls.get(data.getParseType());
           }
 
@@ -462,8 +482,10 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
   private static final String PARSABLE_OBJECT_ARRAY_SERIALIZE_CALL =
       "${subobject_helper_class}.serializeToJson(${generator_object}, ${iterator}, true)";
 
-  private static Map<TypeUtils.ParseType, String> mScalarSerializeCalls = Maps.newHashMap();
-  private static Map<TypeUtils.ParseType, String> mArraySerializeCalls = Maps.newHashMap();
+  private static Map<TypeUtils.ParseType, String> mScalarSerializeCalls =
+      new HashMap<TypeUtils.ParseType, String>();
+  private static Map<TypeUtils.ParseType, String> mArraySerializeCalls =
+      new HashMap<TypeUtils.ParseType, String>();
   static {
     mScalarSerializeCalls.put(TypeUtils.ParseType.BOOLEAN,
         "${generator_object}.writeBooleanField(\"${json_fieldname}\", ${object_varname}.${field_varname})");
@@ -512,4 +534,24 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
         "${generator_object}.writeString(${iterator})");
 
   }
+
+  private String mapCollectionTypeToInterfaceType(TypeUtils.CollectionType collectionType) {
+    switch (collectionType) {
+      case LIST:
+        return "List";
+      case QUEUE:
+        return "Queue";
+    }
+    throw new IllegalStateException("unknown collection type");
+  }
+
+  private String mapCollectionTypeToConcreteType(TypeUtils.CollectionType collectionType) {
+    switch (collectionType) {
+      case LIST:
+        return "ArrayList";
+      case QUEUE:
+        return "ArrayDeque";
+    }
+    throw new IllegalStateException("unknown collection type");
+  }
 }
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/StrFormat.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/StrFormat.java
index 50c8919..3cea068 100644
--- a/processor/src/main/java/com/instagram/common/json/annotation/processor/StrFormat.java
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/StrFormat.java
@@ -2,9 +2,9 @@
 
 package com.instagram.common.json.annotation.processor;
 
+import java.util.HashMap;
 import java.util.Map;
 
-import com.google.common.collect.Maps;
 import org.apache.commons.lang3.text.StrSubstitutor;
 
 /**
@@ -16,7 +16,7 @@ class StrFormat {
 
   StrFormat(String formatString) {
     mFormatString = formatString;
-    mInternalMap = Maps.newHashMap();
+    mInternalMap = new HashMap<String, String>();
   }
 
   StrFormat addParam(String variableName, String replacementText) {
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/TypeData.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/TypeData.java
index 8e9f656..f8ff1c7 100644
--- a/processor/src/main/java/com/instagram/common/json/annotation/processor/TypeData.java
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/TypeData.java
@@ -14,7 +14,7 @@ class TypeData {
   private String mValueExtractFormatter;
   private String mAssignmentFormatter;
   private String mSerializeCodeFormatter;
-  private boolean mInCollection;
+  private TypeUtils.CollectionType mCollectionType;
   private TypeUtils.ParseType mParseType;
   private String mParsableType;
   private String mParsableTypeParserClass;
@@ -59,12 +59,12 @@ class TypeData {
     mSerializeCodeFormatter = serializeCodeFormatter;
   }
 
-  boolean isInCollection() {
-    return mInCollection;
+  TypeUtils.CollectionType getCollectionType() {
+    return mCollectionType;
   }
 
-  void setInCollection(boolean inCollection) {
-    mInCollection = inCollection;
+  void setCollectionType(TypeUtils.CollectionType collectionType) {
+    mCollectionType = collectionType;
   }
 
   TypeUtils.ParseType getParseType() {
diff --git a/processor/src/test/java/com/instagram/common/json/annotation/processor/DeserializeTest.java b/processor/src/test/java/com/instagram/common/json/annotation/processor/DeserializeTest.java
index 087ae51..7f5ed51 100644
--- a/processor/src/test/java/com/instagram/common/json/annotation/processor/DeserializeTest.java
+++ b/processor/src/test/java/com/instagram/common/json/annotation/processor/DeserializeTest.java
@@ -4,7 +4,9 @@ package com.instagram.common.json.annotation.processor;
 
 import java.io.IOException;
 import java.io.StringWriter;
+import java.util.Arrays;
 import java.util.List;
+import java.util.Queue;
 
 import com.instagram.common.json.annotation.processor.support.ExtensibleJSONWriter;
 
@@ -12,6 +14,7 @@ import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.core.JsonParseException;
 import com.fasterxml.jackson.core.JsonParser;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
 import org.json.JSONException;
 import org.json.JSONWriter;
 import org.junit.Test;
@@ -30,6 +33,7 @@ public class DeserializeTest {
     final float floatObjValue = 2.0f;
     final String stringValue = "hello world\r\n\'\"";
     final List<Integer> integerList = Lists.newArrayList(1, 2, 3, 4);
+    final Queue<Integer> integerQueue = Queues.newArrayDeque(Arrays.asList(1, 2, 3, 4));
     final int subIntValue = 30;
 
     StringWriter stringWriter = new StringWriter();
@@ -52,6 +56,17 @@ public class DeserializeTest {
             }
           })
           .endArray()
+        .key(SimpleParseUUT.INTEGER_QUEUE_FIELD_NAME)
+        .array()
+        .extend(new ExtensibleJSONWriter.Extender() {
+          @Override
+          public void extend(ExtensibleJSONWriter writer) throws JSONException {
+            for (Integer integer : integerQueue) {
+              writer.value(integer);
+            }
+          }
+        })
+        .endArray()
         .key(SimpleParseUUT.SUBOBJECT_FIELD_NAME)
           .object()
             .key(SimpleParseUUT.SubobjectParseUUT.INT_FIELD_NAME).value(subIntValue)
@@ -69,6 +84,9 @@ public class DeserializeTest {
     assertEquals(Float.valueOf(floatObjValue), uut.FloatField);
     assertEquals(stringValue, uut.stringField);
     assertEquals(integerList, uut.integerListField);
+    // NOTE: this is because ArrayDeque hilariously does not implement .equals()/.hashcode().
+    assertEquals(Lists.newArrayList(integerQueue),
+        Lists.newArrayList(uut.integerQueueField));
     assertSame(subIntValue, uut.subobjectField.intField);
   }
 
@@ -335,4 +353,22 @@ public class DeserializeTest {
     assertEquals(3, uut.integerListField.get(1).intValue());
     assertEquals(4, uut.integerListField.get(2).intValue());
   }
+
+  @Test
+  public void nullString() throws IOException, JSONException {
+    StringWriter stringWriter = new StringWriter();
+    ExtensibleJSONWriter writer = new ExtensibleJSONWriter(stringWriter);
+
+    writer.object()
+        .key(SimpleParseUUT.STRING_FIELD_NAME)
+        .value(null)
+        .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    SimpleParseUUT uut = SimpleParseUUT__JsonHelper.parseFromJson(jp);
+
+    assertNull(uut.stringField);
+  }
 }
diff --git a/processor/src/test/java/com/instagram/common/json/annotation/processor/InterModuleTest.java b/processor/src/test/java/com/instagram/common/json/annotation/processor/InterModuleTest.java
index 87c01d4..32bf8df 100644
--- a/processor/src/test/java/com/instagram/common/json/annotation/processor/InterModuleTest.java
+++ b/processor/src/test/java/com/instagram/common/json/annotation/processor/InterModuleTest.java
@@ -6,6 +6,8 @@ import java.io.IOException;
 
 import com.instagram.common.json.annotation.processor.dependent.SubclassUUT;
 import com.instagram.common.json.annotation.processor.dependent.SubclassUUT__JsonHelper;
+import com.instagram.common.json.annotation.processor.dependent.SubclassWithAbstractParentUUT;
+import com.instagram.common.json.annotation.processor.dependent.SubclassWithAbstractParentUUT__JsonHelper;
 import com.instagram.common.json.annotation.processor.dependent.WrapperClassUUT;
 import com.instagram.common.json.annotation.processor.dependent.WrapperClassUUT__JsonHelper;
 import com.instagram.common.json.annotation.processor.parent.ParentUUT;
@@ -45,6 +47,31 @@ public class InterModuleTest {
   }
 
   /**
+   * Subclasses an abstract java object in a different class.
+   */
+  @Test
+  public void abstractSubclassingTest() throws IOException, JSONException {
+    final int intValue = 25;
+    final String stringValue = "hello world\r\n\'\"";
+    final int subIntValue = 30;
+
+    SubclassWithAbstractParentUUT uut = new SubclassWithAbstractParentUUT();
+    uut.parentInt = intValue;
+    uut.subclassInt = subIntValue;
+    uut.parentString = stringValue;
+
+    // serialize it
+    String serialized = SubclassWithAbstractParentUUT__JsonHelper.serializeToJson(uut);
+
+    SubclassWithAbstractParentUUT parsed =
+        SubclassWithAbstractParentUUT__JsonHelper.parseFromJson(serialized);
+
+    assertEquals(uut.parentInt, parsed.parentInt);
+    assertEquals(uut.parentString, parsed.parentString);
+    assertEquals(uut.subclassInt, parsed.subclassInt);
+  }
+
+  /**
    * Includes a java object in a different class.
    */
   @Test
diff --git a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/SimpleParseUUT.java b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/SimpleParseUUT.java
index 0f6dab8..8fe6998 100644
--- a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/SimpleParseUUT.java
+++ b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/SimpleParseUUT.java
@@ -3,6 +3,7 @@
 package com.instagram.common.json.annotation.processor;
 
 import java.util.List;
+import java.util.Queue;
 
 import com.instagram.common.json.annotation.JsonField;
 import com.instagram.common.json.annotation.JsonType;
@@ -18,6 +19,7 @@ public class SimpleParseUUT {
   public static final String FLOAT_OBJ_FIELD_NAME = "Float";
   public static final String STRING_FIELD_NAME = "String";
   public static final String INTEGER_LIST_FIELD_NAME = "IntegerList";
+  public static final String INTEGER_QUEUE_FIELD_NAME = "IntegerQueue";
   public static final String SUBOBJECT_FIELD_NAME = "Subobject";
 
   @JsonField(fieldName = INT_FIELD_NAME)
@@ -38,6 +40,9 @@ public class SimpleParseUUT {
   @JsonField(fieldName = INTEGER_LIST_FIELD_NAME)
   public List<Integer> integerListField;
 
+  @JsonField(fieldName = INTEGER_QUEUE_FIELD_NAME)
+  public Queue<Integer> integerQueueField;
+
   @JsonField(fieldName = SUBOBJECT_FIELD_NAME)
   public SubobjectParseUUT subobjectField;
 
diff --git a/util/build.gradle b/util/build.gradle
index 61b7953..e6405a3 100644
--- a/util/build.gradle
+++ b/util/build.gradle
@@ -5,7 +5,7 @@ repositories {
 }
 
 dependencies {
-  compile group: 'com.google.guava', name: 'guava', version: '10.0.1+'
+  compile group: 'com.google.guava', name: 'guava', version: '12.0.1+'
   testCompile group: 'junit', name: 'junit', version: '4.8.2+'
   testCompile project(':util:testuut')
 }
diff --git a/util/src/main/java/com/instagram/common/json/annotation/util/ProcessorClassData.java b/util/src/main/java/com/instagram/common/json/annotation/util/ProcessorClassData.java
index 9d80d0f..708ff54 100644
--- a/util/src/main/java/com/instagram/common/json/annotation/util/ProcessorClassData.java
+++ b/util/src/main/java/com/instagram/common/json/annotation/util/ProcessorClassData.java
@@ -2,9 +2,9 @@
 
 package com.instagram.common.json.annotation.util;
 
-import com.google.common.collect.Maps;
-
 import javax.annotation.processing.Messager;
+
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
@@ -50,7 +50,7 @@ abstract public class ProcessorClassData<AnnotationKeyType, AnnotationRecordType
     mClassName = className;
     mInjectedClassName = injectedClassName;
     mFactory = factory;
-    mData = Maps.newHashMap();
+    mData = new HashMap<AnnotationKeyType, AnnotationRecordType>();
   }
 
   /**
diff --git a/util/src/main/java/com/instagram/common/json/annotation/util/TypeUtils.java b/util/src/main/java/com/instagram/common/json/annotation/util/TypeUtils.java
index 2d91bc5..9cfc1da 100644
--- a/util/src/main/java/com/instagram/common/json/annotation/util/TypeUtils.java
+++ b/util/src/main/java/com/instagram/common/json/annotation/util/TypeUtils.java
@@ -38,6 +38,12 @@ public class TypeUtils {
     ENUM_OBJECT,
   };
 
+  public enum CollectionType {
+    NOT_A_COLLECTION,
+    LIST,
+    QUEUE,
+  }
+
   private static final String JAVA_LANG_STRING = "java.lang.String";
   private static final String JAVA_LANG_BOOLEAN = "java.lang.Boolean";
   private static final String JAVA_LANG_INTEGER = "java.lang.Integer";
@@ -46,6 +52,8 @@ public class TypeUtils {
   private static final String JAVA_LANG_DOUBLE = "java.lang.Double";
   private static final String JAVA_UTIL_LIST = "java.util.List<?>";
   private static final String JAVA_UTIL_LIST_UNTYPED = "java.util.List";
+  private static final String JAVA_UTIL_QUEUE = "java.util.Queue<?>";
+  private static final String JAVA_UTIL_QUEUE_UNTYPED = "java.util.Queue";
   private static final String JAVA_LANG_ENUM = "java.lang.Enum<?>";
 
   private final Types mTypes;
@@ -108,8 +116,14 @@ public class TypeUtils {
     return ParseType.UNSUPPORTED;
   }
 
-  public boolean isListType(TypeMirror typeMirror) {
-    return JAVA_UTIL_LIST_UNTYPED.equals(mTypes.erasure(typeMirror).toString());
+  public CollectionType getCollectionType(TypeMirror typeMirror) {
+    String erasedType = mTypes.erasure(typeMirror).toString();
+    if (JAVA_UTIL_LIST_UNTYPED.equals(erasedType)) {
+      return CollectionType.LIST;
+    } else if (JAVA_UTIL_QUEUE_UNTYPED.equals(erasedType)) {
+      return CollectionType.QUEUE;
+    }
+    return CollectionType.NOT_A_COLLECTION;
   }
 
   /**
@@ -119,7 +133,7 @@ public class TypeUtils {
    * Returns null if {@code typeMirror} does not represent a list type or if we cannot divine the
    * type of the contents.
    */
-  public TypeMirror getListParameterizedType(TypeMirror typeMirror) {
+  public TypeMirror getCollectionParameterizedType(TypeMirror typeMirror) {
     if (!(typeMirror instanceof DeclaredType)) {
       return null;
     }
@@ -131,10 +145,11 @@ public class TypeUtils {
     TypeElement typeElement = (TypeElement) element;
     List<? extends TypeParameterElement> typeParameterElements = typeElement.getTypeParameters();
 
-    if (JAVA_UTIL_LIST.equals(getCanonicalTypeName(declaredType))) {
+    if (JAVA_UTIL_QUEUE.equals(getCanonicalTypeName(declaredType)) ||
+        JAVA_UTIL_LIST.equals(getCanonicalTypeName(declaredType))) {
       // sanity check.
       if (typeParameterElements.size() != 1) {
-        throw new IllegalStateException("java list is not expected generic type");
+        throw new IllegalStateException("java list/queue is not expected generic type");
       }
 
       List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
diff --git a/util/testprocessor/build.gradle b/util/testprocessor/build.gradle
index 0afb606..55f1f7a 100644
--- a/util/testprocessor/build.gradle
+++ b/util/testprocessor/build.gradle
@@ -1,7 +1,7 @@
 apply plugin: 'java'
 
 dependencies {
-  compile group: 'com.google.guava', name: 'guava', version: '10.0.1+'
+  compile group: 'com.google.guava', name: 'guava', version: '12.0.1+'
   compile project(':util')
   compile project(':javawriter')
 }
diff --git a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TestAnnotationProcessor.java b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TestAnnotationProcessor.java
index 0bfbeaa..9e082d1 100644
--- a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TestAnnotationProcessor.java
+++ b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TestAnnotationProcessor.java
@@ -194,9 +194,10 @@ public class TestAnnotationProcessor extends AbstractProcessor {
     TypeGathererClassData injector = mState.mClassElementToInjectorMap.get(enclosingElement);
 
     FieldData data = injector.getOrCreateRecord(element.getSimpleName().toString());
-    if (data.mIsList = mTypeUtils.isListType(type)) {
+    if (data.mIsList =
+        (mTypeUtils.getCollectionType(type) != TypeUtils.CollectionType.NOT_A_COLLECTION)) {
       // inspect the inner type.
-      type = mTypeUtils.getListParameterizedType(type);
+      type = mTypeUtils.getCollectionParameterizedType(type);
     }
 
     data.mParseType = mTypeUtils.getParseType(type, MarkedTypes.class);
diff --git a/util/testuut/build.gradle b/util/testuut/build.gradle
index 7628375..e1a2089 100644
--- a/util/testuut/build.gradle
+++ b/util/testuut/build.gradle
@@ -7,6 +7,6 @@ compileJava {
   ]
 }
 dependencies {
-  compile group: 'com.google.guava', name: 'guava', version: '10.0.1+'
+  compile group: 'com.google.guava', name: 'guava', version: '12.0.1+'
   compile project(':util:testprocessor')
 }
diff --git a/util/testuut/src/main/java/com/instagram/common/json/annotation/util/TypeInspectionUUT.java b/util/testuut/src/main/java/com/instagram/common/json/annotation/util/TypeInspectionUUT.java
index 08cbd26..971327f 100644
--- a/util/testuut/src/main/java/com/instagram/common/json/annotation/util/TypeInspectionUUT.java
+++ b/util/testuut/src/main/java/com/instagram/common/json/annotation/util/TypeInspectionUUT.java
@@ -3,6 +3,7 @@
 package com.instagram.common.json.annotation.util;
 
 import java.util.List;
+import java.util.Queue;
 
 /**
  * Basic class that contains all the supported types.
@@ -113,6 +114,13 @@ class TypeInspectionUUT {
   String integerList__ParseTypeGeneratedClass;
 
   @TypeTesting
+  Queue<Integer> integerQueue;
+
+  boolean integerQueue__IsList;
+  String integerQueue__ParseType;
+  String integerQueue__ParseTypeGeneratedClass;
+
+  @TypeTesting
   InheritedExtendsSpecifiesType integerInheritedList;
 
   boolean integerInheritedList__IsList;

commit 2af031c9eb42310f539e17f9db97a4dab622b12e
Author: Tony Tung <tonytung@merly.org>
Date:   Sat Sep 6 22:22:42 2014 -0700

    updated README

diff --git a/README.md b/README.md
index 06cdc2b..f77f879 100644
--- a/README.md
+++ b/README.md
@@ -2,3 +2,65 @@ ig-json-parser
 ==============
 
 Fast JSON parser for java projects
+
+
+Getting started
+===============
+
+The easiest way to get started is to look at the unit tests or the demo.
+
+Requirements for model classes
+------------------------------
+
+There should be a package-visible no-argument constructor for each of your
+model classes.  The fields also need to be package-visible.
+
+Each class that needs a serializer/deserializer generated should be
+annotated with `@JsonType`.  Each field that needs to be mapped to/from
+JSON should be annotated with `@JsonField`.  The `@JsonField` annotation
+has one mandatory argument, which is the fieldname for the field in the
+JSON.
+
+The following is an example of a very simple model class:
+
+    @JsonType
+    class Dessert {
+      @JsonField(fieldName="type")
+      String type;
+
+      @JsonField(fieldName="rating")
+      float rating;
+    }
+
+Supported data types
+--------------------
+
+The following scalar types are supported:
+* String
+* boolean/Boolean
+* int/Integer
+* long/Long
+* float/Float
+* double/Double
+
+If a json field is another dictionary, it can be represented by another
+model class.  That model class must also have the `@JsonType` annotation.
+
+Lists of objects are supported either as Java Lists or Queues.
+
+Advanced features
+=================
+
+Postprocessing
+--------------
+
+TODO: Document this.  See the documentation in
+common/src/main/java/com/instagram/common/json/annotation/JsonType.java in
+the meanwhile.
+
+Customized parsing code
+-----------------------
+
+TODO: Document this.  See the documentation in
+common/src/main/java/com/instagram/common/json/annotation/JsonField.java
+in the meanwhile.

commit 9eb16f37ad6d78a2d656bd48029da43cff9a2c0e
Author: Tony Tung <tonytung@merly.org>
Date:   Tue Sep 9 23:24:31 2014 -0700

    produce 4 types of jars: annotation processor, runtime, sources, and javadoc

diff --git a/build.gradle b/build.gradle
index 94b4bcc..b7c725a 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,15 +2,49 @@ buildscript {
 }
 
 apply plugin: 'groovy'
-jar {
+
+subprojects {
+  repositories {
+    mavenCentral()
+  }
+}
+
+task processorJar(type: Jar, dependsOn: classes) {
     from files( { project(':javawriter').sourceSets.main.output.classesDir } )
     from files( { project(':common').sourceSets.main.output.classesDir } )
     from files( { project(':util').sourceSets.main.output.classesDir } )
     from files( { project(':processor').sourceSets.main.output.classesDir } )
+    baseName 'processor'
 }
 
-subprojects {
-  repositories {
-    mavenCentral()
-  }
+task runtimeJar(type: Jar, dependsOn: classes) {
+    from files( { project(':common').sourceSets.main.output.classesDir } )
+    baseName 'runtime'
+}
+
+task sourcesJar(type: Jar, dependsOn: classes) {
+    classifier = 'sources'
+    from files( { project(':javawriter').sourceSets.main.allSource } )
+    from files( { project(':common').sourceSets.main.allSource } )
+    from files( { project(':util').sourceSets.main.allSource } )
+    from files( { project(':processor').sourceSets.main.allSource } )
+}
+
+task myJavadocs(type: Javadoc) {
+    source files( { project(':javawriter').sourceSets.main.allSource } )
+    source files( { project(':common').sourceSets.main.allSource } )
+    source files( { project(':util').sourceSets.main.allSource } )
+    source files( { project(':processor').sourceSets.main.allSource } )
+}
+
+task javadocJar(type: Jar, dependsOn: myJavadocs) {
+    classifier = 'javadoc'
+    from javadoc.destinationDir
+}
+
+artifacts {
+    archives processorJar
+    archives runtimeJar
+    archives sourcesJar
+    archives javadocJar
 }
diff --git a/common/build.gradle b/common/build.gradle
index 0034129..e053e10 100644
--- a/common/build.gradle
+++ b/common/build.gradle
@@ -3,4 +3,3 @@ apply plugin: 'java'
 dependencies {
   compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.2.3+'
 }
-

commit 0bc0ac5e3b40bde3ffc2db26a90e7e3de7c0bfb4
Author: Jake Wharton <jw@squareup.com>
Date:   Wed Sep 10 11:29:19 2014 -0700

    Flip executable bit on gradlew.

diff --git a/gradlew b/gradlew
old mode 100644
new mode 100755

commit 34665568dc6341c074c28fe7e51ceb98329e5b54
Merge: 9eb16f3 0bc0ac5
Author: ttung <ttung@fb.com>
Date:   Wed Sep 10 12:16:10 2014 -0700

    Merge pull request #1 from JakeWharton/jw/chmod
    
    Flip executable bit on gradlew.

commit c06084405c545f96263c28b1efb29befd19ad143
Author: Tony Tung <tonytung@merly.org>
Date:   Wed Sep 10 12:16:27 2014 -0700

    add new files

diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/StringUtil.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/StringUtil.java
new file mode 100644
index 0000000..b76db4a
--- /dev/null
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/StringUtil.java
@@ -0,0 +1,13 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+public class StringUtil {
+
+  /**
+   * We don't want to pull in guava strings just for this one function.
+   */
+  /*package*/ static boolean isNullOrEmpty(String string) {
+    return string == null || string.isEmpty();
+  }
+}
diff --git a/processor/testuut/dependent/src/main/java/com/instagram/common/json/annotation/processor/SubclassWithAbstractParentUUT.java b/processor/testuut/dependent/src/main/java/com/instagram/common/json/annotation/processor/SubclassWithAbstractParentUUT.java
new file mode 100644
index 0000000..8f64928
--- /dev/null
+++ b/processor/testuut/dependent/src/main/java/com/instagram/common/json/annotation/processor/SubclassWithAbstractParentUUT.java
@@ -0,0 +1,18 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor.dependent;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+import com.instagram.common.json.annotation.processor.parent.AbstractParentUUT;
+
+/**
+ * UUT with abstract superclass.
+ */
+@JsonType
+public class SubclassWithAbstractParentUUT extends AbstractParentUUT {
+  public static final String SUBCLASS_INT_KEY = "subclass_int";
+
+  @JsonField(fieldName = SUBCLASS_INT_KEY)
+  public int subclassInt;
+}
diff --git a/processor/testuut/parent/src/main/java/com/instagram/common/json/annotation/processor/AbstractParentUUT.java b/processor/testuut/parent/src/main/java/com/instagram/common/json/annotation/processor/AbstractParentUUT.java
new file mode 100644
index 0000000..c8be239
--- /dev/null
+++ b/processor/testuut/parent/src/main/java/com/instagram/common/json/annotation/processor/AbstractParentUUT.java
@@ -0,0 +1,21 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor.parent;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+/**
+ * Abstract parent class to test that abstract parent classes are processed properly.
+ */
+@JsonType
+public abstract class AbstractParentUUT {
+  public static final String PARENT_STRING_KEY = "parent_string";
+  public static final String PARENT_INT_KEY = "parent_int";
+
+  @JsonField(fieldName = PARENT_STRING_KEY)
+  public String parentString;
+
+  @JsonField(fieldName = PARENT_INT_KEY)
+  public int parentInt;
+}

commit 0064b7739f73dc4f7d38c619362a77b4d8724e16
Author: Tony Tung <tonytung@merly.org>
Date:   Mon Sep 15 00:30:33 2014 -0700

    bump android plugin version to 0.12.0 because 0.9.0 is not compatible with
    android studio.

diff --git a/demo/build.gradle b/demo/build.gradle
index ed8cf2b..a57f2fd 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -4,7 +4,7 @@ buildscript {
   }
 
   dependencies {
-    classpath group: 'com.android.tools.build', name: 'gradle', version: '0.9.0+'
+    classpath group: 'com.android.tools.build', name: 'gradle', version: '0.12.0+'
   }
 }
 

commit 23886842fd04cef076f984009c7e7513ffd43f4f
Author: Tony Tung <tonytung@merly.org>
Date:   Mon Sep 15 17:12:25 2014 -0700

    testing jdk17 compatibility

diff --git a/common/build.gradle b/common/build.gradle
index e053e10..bec31a4 100644
--- a/common/build.gradle
+++ b/common/build.gradle
@@ -1,5 +1,8 @@
 apply plugin: 'java'
 
+sourceCompatibility = 1.7
+targetCompatibility = 1.7
+
 dependencies {
   compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.2.3+'
 }
diff --git a/demo/build.gradle b/demo/build.gradle
index a57f2fd..8776bb0 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -25,6 +25,11 @@ android {
     targetSdkVersion 19
   }
 
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_7
+    targetCompatibility JavaVersion.VERSION_1_7
+  }
+
   sourceSets {
     main {
       manifest {
diff --git a/demo/igmodel/build.gradle b/demo/igmodel/build.gradle
index 17a0b52..4549e11 100644
--- a/demo/igmodel/build.gradle
+++ b/demo/igmodel/build.gradle
@@ -1,5 +1,8 @@
 apply plugin: 'java'
 
+sourceCompatibility = 1.7
+targetCompatibility = 1.7
+
 compileJava {
   options.compilerArgs += [
                        '-processor',
diff --git a/javawriter/build.gradle b/javawriter/build.gradle
index 544652f..8ca34d3 100644
--- a/javawriter/build.gradle
+++ b/javawriter/build.gradle
@@ -1,5 +1,8 @@
 apply plugin: 'java'
 
+sourceCompatibility = 1.7
+targetCompatibility = 1.7
+
 repositories {
   mavenCentral()
 }
diff --git a/processor/build.gradle b/processor/build.gradle
index f333aa8..f606cbf 100644
--- a/processor/build.gradle
+++ b/processor/build.gradle
@@ -1,5 +1,8 @@
 apply plugin: 'java'
 
+sourceCompatibility = 1.7
+targetCompatibility = 1.7
+
 repositories {
   mavenCentral()
 }
diff --git a/processor/support/build.gradle b/processor/support/build.gradle
index e758d62..5e9886e 100644
--- a/processor/support/build.gradle
+++ b/processor/support/build.gradle
@@ -1,5 +1,8 @@
 apply plugin: 'java'
 
+sourceCompatibility = 1.7
+targetCompatibility = 1.7
+
 dependencies {
   compile group: 'org.json', name: 'json', version: '20090211'
 }
diff --git a/util/build.gradle b/util/build.gradle
index e6405a3..3b1f6bb 100644
--- a/util/build.gradle
+++ b/util/build.gradle
@@ -1,5 +1,8 @@
 apply plugin: 'java'
 
+sourceCompatibility = 1.7
+targetCompatibility = 1.7
+
 repositories {
   mavenCentral()
 }

commit 6045e73b4039ea507f6c3ad2160d296ef6be6b30
Merge: 0064b77 2388684
Author: ttung <ttung@fb.com>
Date:   Mon Sep 15 21:01:56 2014 -0700

    Merge pull request #7 from Instagram/jdk17
    
    jdk17 compatibility

commit 0a822b38c6d241c5c56381dc51c6ba0604cca56a
Author: Tony Tung <tonytung@merly.org>
Date:   Tue Sep 16 11:27:42 2014 -0700

    place the generated sources in a directory that android studio can see.

diff --git a/.gitignore b/.gitignore
index f8b92c3..28989c3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,3 @@
 .gradle
 build
+gen-src
diff --git a/demo/igmodel/build.gradle b/demo/igmodel/build.gradle
index 4549e11..c0b25a0 100644
--- a/demo/igmodel/build.gradle
+++ b/demo/igmodel/build.gradle
@@ -3,10 +3,29 @@ apply plugin: 'java'
 sourceCompatibility = 1.7
 targetCompatibility = 1.7
 
+ext {
+  generatedSourcesDir = file("gen-src/main/java")
+}
+
+sourceSets {
+  main {
+    java {
+      srcDir 'src/main/java'
+      srcDir 'gen-src/main/java'
+    }
+  }
+}
+
 compileJava {
+  doFirst {
+    // Directory should exists before compilation started.
+    generatedSourcesDir.mkdirs()
+  }
   options.compilerArgs += [
                        '-processor',
-                       'com.instagram.common.json.annotation.processor.JsonAnnotationProcessor'
+                       'com.instagram.common.json.annotation.processor.JsonAnnotationProcessor',
+                       '-s',
+                       generatedSourcesDir
   ]
 }
 dependencies {

commit d2670b3bd5fe8c45bb70ca95556fe4b721dce0f9
Author: Tony Tung <tonytung@merly.org>
Date:   Tue Sep 16 11:28:01 2014 -0700

    generate the artifacts needed to upload to maven.

diff --git a/build.gradle b/build.gradle
index b7c725a..3047710 100644
--- a/build.gradle
+++ b/build.gradle
@@ -9,7 +9,8 @@ subprojects {
   }
 }
 
-task processorJar(type: Jar, dependsOn: classes) {
+task processorJar(type: Jar,
+        dependsOn:["javawriter:build","common:build","util:build","processor:build"]) {
     from files( { project(':javawriter').sourceSets.main.output.classesDir } )
     from files( { project(':common').sourceSets.main.output.classesDir } )
     from files( { project(':util').sourceSets.main.output.classesDir } )
@@ -17,34 +18,57 @@ task processorJar(type: Jar, dependsOn: classes) {
     baseName 'processor'
 }
 
-task runtimeJar(type: Jar, dependsOn: classes) {
+task runtimeJar(type: Jar,
+        dependsOn: "common:build") {
     from files( { project(':common').sourceSets.main.output.classesDir } )
     baseName 'runtime'
 }
 
-task sourcesJar(type: Jar, dependsOn: classes) {
+task runtimeSourcesJar(type: Jar) {
     classifier = 'sources'
+    baseName 'runtime'
+    from files( { project(':common').sourceSets.main.allSource } )
+}
+
+task processorSourcesJar(type: Jar) {
+    classifier = 'sources'
+    baseName 'processor'
     from files( { project(':javawriter').sourceSets.main.allSource } )
     from files( { project(':common').sourceSets.main.allSource } )
     from files( { project(':util').sourceSets.main.allSource } )
     from files( { project(':processor').sourceSets.main.allSource } )
 }
 
-task myJavadocs(type: Javadoc) {
+task runtimeJavadoc(type: Javadoc) {
+    source files( { project(':common').sourceSets.main.allSource } )
+    destinationDir = new File("${project.docsDir}", "runtime-javadoc")
+}
+
+task runtimeJavadocJar(type: Jar, dependsOn: runtimeJavadoc) {
+    classifier = 'javadoc'
+    baseName 'runtime'
+    from runtimeJavadoc.destinationDir
+}
+
+task processorJavadoc(type: Javadoc) {
     source files( { project(':javawriter').sourceSets.main.allSource } )
     source files( { project(':common').sourceSets.main.allSource } )
     source files( { project(':util').sourceSets.main.allSource } )
     source files( { project(':processor').sourceSets.main.allSource } )
+    destinationDir = new File("${project.docsDir}", "processor-javadoc")
 }
 
-task javadocJar(type: Jar, dependsOn: myJavadocs) {
+task processorJavadocJar(type: Jar, dependsOn: processorJavadoc) {
     classifier = 'javadoc'
-    from javadoc.destinationDir
+    baseName 'processor'
+    from processorJavadoc.destinationDir
 }
 
 artifacts {
     archives processorJar
     archives runtimeJar
-    archives sourcesJar
-    archives javadocJar
+    archives runtimeSourcesJar
+    archives processorSourcesJar
+    archives runtimeJavadocJar
+    archives processorJavadocJar
 }

commit 27f804827b4680603e705f3b962ce8f857950c83
Author: Tony Tung <tonytung@merly.org>
Date:   Wed Sep 17 11:29:32 2014 -0700

    demo using maven.

diff --git a/maven-example/Dessert.java b/maven-example/Dessert.java
new file mode 100644
index 0000000..ae64f7f
--- /dev/null
+++ b/maven-example/Dessert.java
@@ -0,0 +1,8 @@
+@JsonType
+class Dessert {
+  @JsonField(fieldName="type")
+  String type;
+
+  @JsonField(fieldName="rating")
+  float rating;
+}
diff --git a/maven-example/build.gradle b/maven-example/build.gradle
new file mode 100644
index 0000000..4b5a8f7
--- /dev/null
+++ b/maven-example/build.gradle
@@ -0,0 +1,41 @@
+apply plugin: 'java'
+
+sourceCompatibility = 1.7
+targetCompatibility = 1.7
+
+ext {
+  generatedSourcesDir = file("gen-src/main/java")
+}
+
+repositories {
+  mavenCentral()
+}
+
+sourceSets {
+  main {
+    java {
+      srcDir 'src/main/java'
+    }
+  }
+  gensrc {
+    java {
+      srcDir 'gen-src/main/java'
+    }
+  }
+}
+
+compileJava {
+  doFirst {
+    // Directory should exists before compilation started.
+    generatedSourcesDir.mkdirs()
+  }
+  options.compilerArgs += [
+                       '-processor',
+                       'com.instagram.common.json.annotation.processor.JsonAnnotationProcessor',
+                       '-s',
+                       generatedSourcesDir
+  ]
+}
+dependencies {
+  compile group: 'com.instagram', name: 'ig-json-parser-processor', version: '0.0.3+'
+}
diff --git a/maven-example/src/main/java/com/instagram/Consumer.java b/maven-example/src/main/java/com/instagram/Consumer.java
new file mode 100644
index 0000000..40522c0
--- /dev/null
+++ b/maven-example/src/main/java/com/instagram/Consumer.java
@@ -0,0 +1,16 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram;
+
+import java.io.IOException;
+
+public class Consumer {
+  public static void main(String[] args) {
+    try {
+      Dessert parsed = Dessert__JsonHelper.parseFromJson("{\"type\": \"macaron\"}");
+      System.out.println("dessert type: " + parsed.type);
+    } catch (IOException ex) {
+      System.out.println("fatal: " + ex);
+    }
+  }
+}
diff --git a/maven-example/src/main/java/com/instagram/Dessert.java b/maven-example/src/main/java/com/instagram/Dessert.java
new file mode 100644
index 0000000..e8dcea7
--- /dev/null
+++ b/maven-example/src/main/java/com/instagram/Dessert.java
@@ -0,0 +1,15 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+class Dessert {
+  @JsonField(fieldName="type")
+  String type;
+
+  @JsonField(fieldName="rating")
+  float rating;
+}

commit a5da469c51c491152327b4428a67a22c55500103
Author: Tony Tung <tonytung@merly.org>
Date:   Wed Sep 17 11:29:46 2014 -0700

    update gitignore.

diff --git a/.gitignore b/.gitignore
index 28989c3..6bce8ff 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,5 @@
 .gradle
+.idea
 build
 gen-src
+*.iml

commit 4e7df42f62a4dc8c2aa21836b4654a4b58ba4df5
Author: Tony Tung <tonytung@merly.org>
Date:   Wed Sep 17 11:29:54 2014 -0700

    two separate trees to avoid the generated file being re-included in the
    command line.

diff --git a/README.md b/README.md
index f77f879..cc2f892 100644
--- a/README.md
+++ b/README.md
@@ -7,7 +7,52 @@ Fast JSON parser for java projects
 Getting started
 ===============
 
-The easiest way to get started is to look at the unit tests or the demo.
+The easiest way to get started is to look at maven-example.  For more
+comprehensive examples, check out the unit tests or the demo.
+
+
+Maven
+-----
+
+To use this library, add this to your build.gradle file:
+
+    ext {
+      generatedSourcesDir = file("gen-src/main/java")
+    }
+    
+    repositories {
+      mavenCentral()
+    }
+    
+    sourceSets {
+      main {
+        java {
+          srcDir 'src/main/java'
+        }
+      }
+      gensrc {
+        java {
+          srcDir 'gen-src/main/java'
+        }
+      }
+    }
+    
+    compileJava {
+      doFirst {
+        // Directory should exists before compilation started.
+        generatedSourcesDir.mkdirs()
+      }
+      options.compilerArgs += [
+                           '-processor',
+                           'com.instagram.common.json.annotation.processor.JsonAnnotationProcessor',
+                           '-s',
+                           generatedSourcesDir
+      ]
+    }
+    dependencies {
+      compile group: 'com.instagram', name: 'ig-json-parser-processor', version: '0.0.3+'
+    }
+
 
 Requirements for model classes
 ------------------------------
@@ -32,6 +77,23 @@ The following is an example of a very simple model class:
       float rating;
     }
 
+
+Serializer/deserializer
+-----------------------
+
+Compiling your model classes with the annotations will automatically
+generate the serializer and deserializer.  They will be in a generated
+class with the same name as your class, except with the suffix
+`__JsonHelper`.  For example, to deserialize the `Dessert` class above,
+simply run the code:
+
+    Dessert parsed = Dessert__JsonHelper.parseFromJson(inputJsonString);
+
+To serialize a class, run:
+
+    String serialized = Dessert__JsonHelper.serializeToJson(dessertObject);
+
+
 Supported data types
 --------------------
 
diff --git a/demo/igmodel/build.gradle b/demo/igmodel/build.gradle
index c0b25a0..9b22732 100644
--- a/demo/igmodel/build.gradle
+++ b/demo/igmodel/build.gradle
@@ -11,6 +11,10 @@ sourceSets {
   main {
     java {
       srcDir 'src/main/java'
+    }
+  }
+  gensrc {
+    java {
       srcDir 'gen-src/main/java'
     }
   }

commit fd72d000160d6b3cacf4ba95a506856a10bdb85b
Author: Tommy Visic <tommy@tastemade>
Date:   Thu Sep 18 16:47:48 2014 -0500

    Added some notes regarding Proguard compatability to README.md

diff --git a/README.md b/README.md
index cc2f892..05a5e09 100644
--- a/README.md
+++ b/README.md
@@ -19,11 +19,11 @@ To use this library, add this to your build.gradle file:
     ext {
       generatedSourcesDir = file("gen-src/main/java")
     }
-    
+
     repositories {
       mavenCentral()
     }
-    
+
     sourceSets {
       main {
         java {
@@ -36,7 +36,7 @@ To use this library, add this to your build.gradle file:
         }
       }
     }
-    
+
     compileJava {
       doFirst {
         // Directory should exists before compilation started.
@@ -110,6 +110,14 @@ model class.  That model class must also have the `@JsonType` annotation.
 
 Lists of objects are supported either as Java Lists or Queues.
 
+Proguard
+===============
+
+Add the following lines to your proguard-rules file:
+
+    -dontwarn sun.misc.Unsafe
+    -dontwarn javax.annotation.**
+
 Advanced features
 =================
 

commit 916c561e9aeeace7d91b4bed07788f26a75ded8c
Merge: 4e7df42 fd72d00
Author: ttung <ttung@fb.com>
Date:   Thu Sep 18 15:07:29 2014 -0700

    Merge pull request #13 from TommyVisic/master
    
    Added some notes regarding Proguard compatability to README.md

commit 1aaad6bb56a880e7c27914652b7e1686d5478fb7
Author: Tony Tung <tonytung@merly.org>
Date:   Thu Sep 25 21:25:17 2014 -0700

    1) alternate json field name for the same java field.
    2) support for json lists to be parsed into a set.
    3) prettier generated code.
    4) improved internal documentation.

diff --git a/common/src/main/java/com/instagram/common/json/annotation/JsonField.java b/common/src/main/java/com/instagram/common/json/annotation/JsonField.java
index a6fe545..b64cc13 100644
--- a/common/src/main/java/com/instagram/common/json/annotation/JsonField.java
+++ b/common/src/main/java/com/instagram/common/json/annotation/JsonField.java
@@ -32,6 +32,12 @@ public @interface JsonField {
   String fieldName();
 
   /**
+   * Alternate field names which should be parsed to the same field. Only used during
+   * deserialization.
+   */
+  String [] alternateFieldNames() default {};
+
+  /**
    * This controls how we deal with type mismatches.  Note that this is ignored if
    * {@link #valueExtractFormatter()} is specified.
    * @see TypeMapping
diff --git a/demo/proguard.cfg b/demo/proguard.cfg
new file mode 100644
index 0000000..bc783e7
--- /dev/null
+++ b/demo/proguard.cfg
@@ -0,0 +1,4 @@
+-dontwarn com.fasterxml.jackson.databind.ext.DOMSerializer
+-dontwarn com.google.common.primitives.UnsignedBytes*
+-dontwarn com.instagram.common.json.**
+-dontwarn com.squareup.javawriter.JavaWriter
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonAnnotationProcessor.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonAnnotationProcessor.java
index 63cf290..79e3580 100644
--- a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonAnnotationProcessor.java
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonAnnotationProcessor.java
@@ -180,6 +180,7 @@ public class JsonAnnotationProcessor extends AbstractProcessor {
       injector = new JsonParserClassData(
           packageName,
           typeElement.getQualifiedName().toString(),
+          mTypeUtils.getClassName(typeElement, packageName),
           mTypeUtils.getPrefixForGeneratedClass(typeElement, packageName) +
               JsonAnnotationProcessorConstants.HELPER_CLASS_SUFFIX,
           new ProcessorClassData.AnnotationRecordFactory<String, TypeData>() {
@@ -235,6 +236,7 @@ public class JsonAnnotationProcessor extends AbstractProcessor {
     JsonField annotation = element.getAnnotation(JsonField.class);
 
     data.setFieldName(annotation.fieldName());
+    data.setAlternateFieldNames(annotation.alternateFieldNames());
     data.setMapping(annotation.mapping());
     data.setValueExtractFormatter(annotation.valueExtractFormatter());
     data.setAssignmentFormatter(annotation.fieldAssignmentFormatter());
@@ -254,11 +256,11 @@ public class JsonAnnotationProcessor extends AbstractProcessor {
       TypeElement typeElement = (TypeElement) declaredType.asElement();
 
       String packageName = mTypeUtils.getPackageName(mElements, typeElement);
-      String className = mTypeUtils.getClassName(typeElement, packageName);
-      String parserClassName = mTypeUtils.getPrefixForGeneratedClass(typeElement, packageName);
 
-      data.setParsableType(packageName + "." + className);
-      data.setParsableTypeParserClass(packageName + "." + parserClassName);
+      data.setPackageName(packageName);
+      data.setParsableType(mTypeUtils.getClassName(typeElement, packageName));
+      data.setParsableTypeParserClass(
+          mTypeUtils.getPrefixForGeneratedClass(typeElement, packageName));
     } else if (data.getParseType() == TypeUtils.ParseType.ENUM_OBJECT) {
       // verify that we have value extract and serializer formatters.
       if (StringUtil.isNullOrEmpty(annotation.valueExtractFormatter()) ||
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java
index cb41d7d..15fcdc2 100644
--- a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java
@@ -6,18 +6,28 @@ import javax.annotation.processing.Messager;
 
 import java.io.IOException;
 import java.io.StringWriter;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.EnumSet;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
+import java.util.Queue;
+import java.util.Set;
 
 import com.instagram.common.json.JsonAnnotationProcessorConstants;
+import com.instagram.common.json.JsonFactoryHolder;
 import com.instagram.common.json.annotation.JsonField;
 import com.instagram.common.json.annotation.JsonType;
 import com.instagram.common.json.annotation.util.Console;
 import com.instagram.common.json.annotation.util.ProcessorClassData;
 import com.instagram.common.json.annotation.util.TypeUtils;
 
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
 import com.squareup.javawriter.JavaWriter;
 
 import static javax.lang.model.element.Modifier.*;
@@ -33,12 +43,15 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
   private final String mParentInjectedClassName;
 
   public JsonParserClassData(
-      String classPackage, String className, String injectedClassName,
+      String classPackage,
+      String qualifiedClassName,
+      String simpleClassName,
+      String injectedClassName,
       AnnotationRecordFactory<String, TypeData> factory,
       boolean abstractClass,
       boolean postprocessingEnabled,
       String parentInjectedClassName) {
-    super(classPackage, className, injectedClassName, factory);
+    super(classPackage, qualifiedClassName, simpleClassName, injectedClassName, factory);
     mAbstractClass = abstractClass;
     mPostprocessingEnabled = postprocessingEnabled;
     mParentInjectedClassName = parentInjectedClassName;
@@ -53,19 +66,43 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
       writer.emitPackage(mClassPackage);
 
       writer.emitImports(
-          "java.io.IOException",
-          "java.io.StringWriter",
-          "java.util.ArrayDeque",
-          "java.util.ArrayList",
-          "java.util.List",
-          "java.util.Queue",
-          "com.fasterxml.jackson.core.JsonGenerator",
-          "com.fasterxml.jackson.core.JsonParser",
-          "com.fasterxml.jackson.core.JsonToken",
-          "com.instagram.common.json.JsonFactoryHolder"
-      );
+          IOException.class,
+          StringWriter.class,
+          ArrayList.class,
+          ArrayDeque.class,
+          HashSet.class,
+          List.class,
+          Queue.class,
+          Set.class,
+          JsonGenerator.class,
+          JsonParser.class,
+          JsonToken.class,
+          JsonFactoryHolder.class);
+
+      // Generate the set of imports from the parsable objects referenced.
+      Set<String> typeImports = new HashSet<String>();
+      for (Map.Entry<String, TypeData> entry : getIterator()) {
+        TypeData typeData = entry.getValue();
+        if (typeData.getCollectionType() != TypeUtils.CollectionType.NOT_A_COLLECTION) {
+          if (typeData.getParseType() == TypeUtils.ParseType.PARSABLE_OBJECT &&
+              !typeData.getPackageName().equals(mClassPackage)) {
+            typeImports.add(typeData.getPackageName() + "." + typeData.getParsableType());
+            typeImports.add(
+                typeData.getPackageName() + "." + typeData.getParsableTypeParserClass() +
+                    JsonAnnotationProcessorConstants.HELPER_CLASS_SUFFIX);
+          }
+        } else if (typeData.getParseType() == TypeUtils.ParseType.PARSABLE_OBJECT &&
+            !typeData.getPackageName().equals(mClassPackage)) {
+          typeImports.add(
+              typeData.getPackageName() + "." + typeData.getParsableTypeParserClass() +
+                  JsonAnnotationProcessorConstants.HELPER_CLASS_SUFFIX);
+        }
+      }
+      writer.emitImports(typeImports);
+      writer.emitEmptyLine();
 
       writer.beginType(mInjectedClassName, "class", EnumSet.of(PUBLIC, FINAL));
+      writer.emitEmptyLine();
 
       String returnValue = mPostprocessingEnabled ?
           ("instance." + JsonType.POSTPROCESSING_METHOD_NAME + "()") : "instance";
@@ -73,17 +110,19 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
       if (!mAbstractClass) {
         writer
               .beginMethod(
-                  mClassName,
+                  mSimpleClassName,
                   "parseFromJson",
-                  EnumSet.of(PUBLIC, STATIC, FINAL),
+                  EnumSet.of(PUBLIC, STATIC),
                   Arrays.asList("JsonParser", "jp"),
                   Arrays.asList("IOException"))
-                .emitStatement("%s instance = new %s()", mClassName, mClassName)
+                .emitStatement("%s instance = new %s()", mSimpleClassName, mSimpleClassName)
+                .emitEmptyLine()
                 .emitSingleLineComment("validate that we're on the right token")
                 .beginControlFlow("if (jp.getCurrentToken() != JsonToken.START_OBJECT)")
                   .emitStatement("jp.skipChildren()")
                   .emitStatement("return null")
                 .endControlFlow()
+                .emitEmptyLine()
                 .beginControlFlow("while (jp.nextToken() != JsonToken.END_OBJECT)")
                   .emitStatement("String fieldName = jp.getCurrentName()")
                   .emitStatement("jp.nextToken()")
@@ -93,6 +132,7 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
                   // forward if we're seeing something unexpected.
                   .emitStatement("jp.skipChildren()")
                 .endControlFlow()
+                .emitEmptyLine()
                 .emitStatement("return %s", returnValue)
               .endMethod()
               .emitEmptyLine();
@@ -102,8 +142,8 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
           .beginMethod(
               "boolean",
               "processSingleField",
-              EnumSet.of(PUBLIC, STATIC, FINAL),
-              Arrays.asList(mClassName, "instance", "String", "fieldName", "JsonParser", "jp"),
+              EnumSet.of(PUBLIC, STATIC),
+              Arrays.asList(mSimpleClassName, "instance", "String", "fieldName", "JsonParser", "jp"),
               Arrays.asList("IOException"))
           .emitWithGenerator(
               new JavaWriter.JavaGenerator() {
@@ -127,9 +167,9 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
       if (!mAbstractClass) {
         writer
               .beginMethod(
-                  mClassName,
+                  mSimpleClassName,
                   "parseFromJson",
-                  EnumSet.of(PUBLIC, STATIC, FINAL),
+                  EnumSet.of(PUBLIC, STATIC),
                   Arrays.asList("String", "inputString"),
                   Arrays.asList("IOException"))
               .emitStatement(
@@ -144,9 +184,9 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
             .beginMethod(
                 "void",
                 "serializeToJson",
-                EnumSet.of(PUBLIC, STATIC, FINAL),
+                EnumSet.of(PUBLIC, STATIC),
                 Arrays.asList("JsonGenerator", "generator",
-                    mClassName, "object",
+                    mSimpleClassName, "object",
                     "boolean", "writeStartAndEnd"),
                 Arrays.asList("IOException"))
               .beginControlFlow("if (writeStartAndEnd)")
@@ -177,8 +217,8 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
             .beginMethod(
                 "String",
                 "serializeToJson",
-                EnumSet.of(PUBLIC, STATIC, FINAL),
-                Arrays.asList(mClassName, "object"),
+                EnumSet.of(PUBLIC, STATIC),
+                Arrays.asList(mSimpleClassName, "object"),
                 Arrays.asList("IOException"))
             .emitStatement("StringWriter stringWriter = new StringWriter()")
             .emitStatement(
@@ -212,10 +252,16 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
     for (Map.Entry<String, TypeData> entry : getIterator()) {
       TypeData data = entry.getValue();
 
+      String condition = "\"" + data.getFieldName() + "\".equals(fieldName)";
+
+      for (String alternateFieldName : data.getAlternateFieldNames()) {
+        condition += "|| \"" + alternateFieldName + "\".equals(fieldName)";
+      }
+
       if (firstEntry) {
-        writer.beginControlFlow("if (\"" + data.getFieldName() + "\".equals(fieldName))");
+        writer.beginControlFlow("if (" + condition + ")");
       } else {
-        writer.nextControlFlow("else if (\"" + data.getFieldName() + "\".equals(fieldName))");
+        writer.nextControlFlow("else if (" + condition + ")");
       }
 
       if (data.getCollectionType() != TypeUtils.CollectionType.NOT_A_COLLECTION) {
@@ -312,7 +358,8 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
     }
 
     throw new IllegalStateException(
-        "Could not divine java type for " + type.getFieldName() + " in class " + mClassName);
+        "Could not divine java type for " + type.getFieldName() + " in class " +
+            mQualifiedClassName);
   }
 
   // These are all the default formatters.
@@ -541,6 +588,8 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
         return "List";
       case QUEUE:
         return "Queue";
+      case SET:
+        return "Set";
     }
     throw new IllegalStateException("unknown collection type");
   }
@@ -551,6 +600,8 @@ public class JsonParserClassData extends ProcessorClassData<String, TypeData> {
         return "ArrayList";
       case QUEUE:
         return "ArrayDeque";
+      case SET:
+        return "HashSet";
     }
     throw new IllegalStateException("unknown collection type");
   }
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/TypeData.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/TypeData.java
index f8ff1c7..8a92815 100644
--- a/processor/src/main/java/com/instagram/common/json/annotation/processor/TypeData.java
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/TypeData.java
@@ -3,20 +3,74 @@
 package com.instagram.common.json.annotation.processor;
 
 import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
 import com.instagram.common.json.annotation.util.TypeUtils;
 
 /**
- * Represents the data needed to serialize and deserialize a field.
+ * Represents the data needed to serialize and deserialize a field. These roughly correspond
+ * to the attributes of the JsonField annotation.
  */
 class TypeData {
+
+  /**
+   * {@link JsonField#fieldName()}
+   */
   private String mFieldName;
+
+  /**
+   * {@link JsonField#alternateFieldNames()}
+   */
+  private String[] mAlternateFieldNames;
+
+  /**
+   * {@link JsonField#mapping()}
+   */
   private JsonField.TypeMapping mMapping;
+
+  /**
+   * {@link JsonField#valueExtractFormatter()}
+   */
   private String mValueExtractFormatter;
+
+  /**
+   * {@link JsonField#fieldAssignmentFormatter()}
+   */
   private String mAssignmentFormatter;
+
+  /**
+   * {@link JsonField#serializeCodeFormatter()}
+   */
   private String mSerializeCodeFormatter;
+
+  /**
+   * The collection type of the field, if the field is a collection, otherwise it is set to
+   * {@link TypeUtils.CollectionType#NOT_A_COLLECTION}
+   */
   private TypeUtils.CollectionType mCollectionType;
+
+  /**
+   * The parse type of the field. This is either the
+   * <p>
+   * 1) the generic type if the field is a collection<br/>
+   * 2) an internal type that we know how to parse<br/>
+   * 3) parsable object, if it refers to an object that is annotated with {@link JsonType}
+   *
+   */
   private TypeUtils.ParseType mParseType;
+
+  /**
+   * If this is a parsable object, the package name for this field's class.
+   */
+  private String mPackageName;
+
+  /**
+   * If this is a parsable object, the name of this field's class.
+   */
   private String mParsableType;
+
+  /**
+   * If this is a parsable object, the name of this field's parser class.
+   */
   private String mParsableTypeParserClass;
 
   String getFieldName() {
@@ -27,6 +81,14 @@ class TypeData {
     this.mFieldName = fieldName;
   }
 
+  public String[] getAlternateFieldNames() {
+    return mAlternateFieldNames;
+  }
+
+  public void setAlternateFieldNames(String[] alternateFieldNames) {
+    mAlternateFieldNames = alternateFieldNames;
+  }
+
   JsonField.TypeMapping getMapping() {
     return mMapping;
   }
@@ -75,6 +137,14 @@ class TypeData {
     mParseType = parseType;
   }
 
+  public String getPackageName() {
+    return mPackageName;
+  }
+
+  public void setPackageName(String packageName) {
+    mPackageName = packageName;
+  }
+
   String getParsableType() {
     return mParsableType;
   }
diff --git a/processor/src/test/java/com/instagram/common/json/annotation/processor/DeserializeTest.java b/processor/src/test/java/com/instagram/common/json/annotation/processor/DeserializeTest.java
index 7f5ed51..1db5ae1 100644
--- a/processor/src/test/java/com/instagram/common/json/annotation/processor/DeserializeTest.java
+++ b/processor/src/test/java/com/instagram/common/json/annotation/processor/DeserializeTest.java
@@ -7,6 +7,7 @@ import java.io.StringWriter;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Queue;
+import java.util.Set;
 
 import com.instagram.common.json.annotation.processor.support.ExtensibleJSONWriter;
 
@@ -15,6 +16,7 @@ import com.fasterxml.jackson.core.JsonParseException;
 import com.fasterxml.jackson.core.JsonParser;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 import org.json.JSONException;
 import org.json.JSONWriter;
 import org.junit.Test;
@@ -34,6 +36,7 @@ public class DeserializeTest {
     final String stringValue = "hello world\r\n\'\"";
     final List<Integer> integerList = Lists.newArrayList(1, 2, 3, 4);
     final Queue<Integer> integerQueue = Queues.newArrayDeque(Arrays.asList(1, 2, 3, 4));
+    final Set<Integer> integerSet = Sets.newHashSet(1, 2, 3, 4);
     final int subIntValue = 30;
 
     StringWriter stringWriter = new StringWriter();
@@ -67,6 +70,17 @@ public class DeserializeTest {
           }
         })
         .endArray()
+        .key(SimpleParseUUT.INTEGER_SET_FIELD_NAME)
+        .array()
+        .extend(new ExtensibleJSONWriter.Extender() {
+          @Override
+          public void extend(ExtensibleJSONWriter writer) throws JSONException {
+            for (Integer integer : integerSet) {
+              writer.value(integer);
+            }
+          }
+        })
+        .endArray()
         .key(SimpleParseUUT.SUBOBJECT_FIELD_NAME)
           .object()
             .key(SimpleParseUUT.SubobjectParseUUT.INT_FIELD_NAME).value(subIntValue)
@@ -87,6 +101,7 @@ public class DeserializeTest {
     // NOTE: this is because ArrayDeque hilariously does not implement .equals()/.hashcode().
     assertEquals(Lists.newArrayList(integerQueue),
         Lists.newArrayList(uut.integerQueueField));
+    assertEquals(integerSet, uut.integerSetField);
     assertSame(subIntValue, uut.subobjectField.intField);
   }
 
@@ -355,6 +370,30 @@ public class DeserializeTest {
   }
 
   @Test
+  public void testAlternateFieldNames() throws Exception {
+    testAlternateFieldNameHelper(AlternateFieldUUT.FIELD_NAME, "value1");
+    testAlternateFieldNameHelper(AlternateFieldUUT.ALTERNATE_FIELD_NAME_1, "value2");
+    testAlternateFieldNameHelper(AlternateFieldUUT.ALTERNATE_FIELD_NAME_2, "value3");
+  }
+
+  private void testAlternateFieldNameHelper(String fieldName, String value) throws Exception {
+    StringWriter stringWriter = new StringWriter();
+    ExtensibleJSONWriter writer = new ExtensibleJSONWriter(stringWriter);
+
+    writer.object()
+        .key(fieldName)
+        .value(value)
+        .endObject();
+
+    String inputString = stringWriter.toString();
+    JsonParser jp = new JsonFactory().createParser(inputString);
+    jp.nextToken();
+    AlternateFieldUUT uut = AlternateFieldUUT__JsonHelper.parseFromJson(jp);
+
+    assertEquals(value, uut.nameField);
+  }
+
+  @Test
   public void nullString() throws IOException, JSONException {
     StringWriter stringWriter = new StringWriter();
     ExtensibleJSONWriter writer = new ExtensibleJSONWriter(stringWriter);
diff --git a/processor/src/test/java/com/instagram/common/json/annotation/processor/SerializeTest.java b/processor/src/test/java/com/instagram/common/json/annotation/processor/SerializeTest.java
index 9b674f0..21ea66e 100644
--- a/processor/src/test/java/com/instagram/common/json/annotation/processor/SerializeTest.java
+++ b/processor/src/test/java/com/instagram/common/json/annotation/processor/SerializeTest.java
@@ -4,12 +4,17 @@ package com.instagram.common.json.annotation.processor;
 
 import java.io.IOException;
 import java.io.StringWriter;
+import java.util.Arrays;
 import java.util.List;
+import java.util.Queue;
+import java.util.Set;
 
 import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.core.JsonParser;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 import org.json.JSONException;
 import org.junit.Test;
 
@@ -27,6 +32,8 @@ public class SerializeTest {
     final int integerValue = 37;
     final String stringValue = "hello world\r\n\'\"";
     final List<Integer> integerList = Lists.newArrayList(1, 2, 3, 4);
+    final Queue<Integer> integerQueue = Queues.newArrayDeque(Arrays.asList(1, 2, 3, 4));
+    final Set<Integer> integerSet = Sets.newHashSet(1, 2, 3, 4);
     final int subIntValue = 30;
 
     SimpleParseUUT source = new SimpleParseUUT();
@@ -34,6 +41,8 @@ public class SerializeTest {
     source.integerField = integerValue;
     source.stringField = stringValue;
     source.integerListField = integerList;
+    source.integerQueueField = integerQueue;
+    source.integerSetField = integerSet;
     source.subobjectField = new SimpleParseUUT.SubobjectParseUUT();
     source.subobjectField.intField = subIntValue;
 
@@ -52,6 +61,10 @@ public class SerializeTest {
     assertEquals(source.integerField, parsed.integerField);
     assertEquals(source.stringField, parsed.stringField);
     assertEquals(source.integerListField, parsed.integerListField);
+    // NOTE: this is because ArrayDeque hilariously does not implement .equals()/.hashcode().
+    assertEquals(Lists.newArrayList(source.integerQueueField),
+        Lists.newArrayList(parsed.integerQueueField));
+    assertEquals(source.integerSetField, parsed.integerSetField);
     assertSame(source.subobjectField.intField, parsed.subobjectField.intField);
   }
 
@@ -61,6 +74,8 @@ public class SerializeTest {
     final int integerValue = 37;
     final String stringValue = "hello world\r\n\'\"";
     final List<Integer> integerList = Lists.newArrayList(1, 2, 3, 4);
+    final Queue<Integer> integerQueue = Queues.newArrayDeque(Arrays.asList(1, 2, 3, 4));
+    final Set<Integer> integerSet = Sets.newHashSet(1, 2, 3, 4);
     final int subIntValue = 30;
 
     SimpleParseUUT source = new SimpleParseUUT();
@@ -68,6 +83,8 @@ public class SerializeTest {
     source.integerField = integerValue;
     source.stringField = stringValue;
     source.integerListField = integerList;
+    source.integerQueueField = integerQueue;
+    source.integerSetField = integerSet;
     source.subobjectField = new SimpleParseUUT.SubobjectParseUUT();
     source.subobjectField.intField = subIntValue;
 
@@ -78,6 +95,10 @@ public class SerializeTest {
     assertEquals(source.integerField, parsed.integerField);
     assertEquals(source.stringField, parsed.stringField);
     assertEquals(source.integerListField, parsed.integerListField);
+    // NOTE: this is because ArrayDeque hilariously does not implement .equals()/.hashcode().
+    assertEquals(Lists.newArrayList(source.integerQueueField),
+        Lists.newArrayList(parsed.integerQueueField));
+    assertEquals(source.integerSetField, parsed.integerSetField);
     assertSame(source.subobjectField.intField, parsed.subobjectField.intField);
   }
 
diff --git a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/AlternateFieldUUT.java b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/AlternateFieldUUT.java
new file mode 100644
index 0000000..cd2fa51
--- /dev/null
+++ b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/AlternateFieldUUT.java
@@ -0,0 +1,19 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.instagram.common.json.annotation.processor;
+
+import com.instagram.common.json.annotation.JsonField;
+import com.instagram.common.json.annotation.JsonType;
+
+@JsonType
+public class AlternateFieldUUT {
+
+  public static final String FIELD_NAME = "tyler";
+  public static final String ALTERNATE_FIELD_NAME_1 = "josh";
+  public static final String ALTERNATE_FIELD_NAME_2 = "kang";
+
+  @JsonField(fieldName = FIELD_NAME,
+      alternateFieldNames = {ALTERNATE_FIELD_NAME_1, ALTERNATE_FIELD_NAME_2})
+  String nameField;
+
+}
diff --git a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/SimpleParseUUT.java b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/SimpleParseUUT.java
index 8fe6998..2ddc5a8 100644
--- a/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/SimpleParseUUT.java
+++ b/processor/testuut/src/main/java/com/instagram/common/json/annotation/processor/SimpleParseUUT.java
@@ -4,6 +4,7 @@ package com.instagram.common.json.annotation.processor;
 
 import java.util.List;
 import java.util.Queue;
+import java.util.Set;
 
 import com.instagram.common.json.annotation.JsonField;
 import com.instagram.common.json.annotation.JsonType;
@@ -20,6 +21,7 @@ public class SimpleParseUUT {
   public static final String STRING_FIELD_NAME = "String";
   public static final String INTEGER_LIST_FIELD_NAME = "IntegerList";
   public static final String INTEGER_QUEUE_FIELD_NAME = "IntegerQueue";
+  public static final String INTEGER_SET_FIELD_NAME = "IntegerSet";
   public static final String SUBOBJECT_FIELD_NAME = "Subobject";
 
   @JsonField(fieldName = INT_FIELD_NAME)
@@ -43,6 +45,9 @@ public class SimpleParseUUT {
   @JsonField(fieldName = INTEGER_QUEUE_FIELD_NAME)
   public Queue<Integer> integerQueueField;
 
+  @JsonField(fieldName = INTEGER_SET_FIELD_NAME)
+  public Set<Integer> integerSetField;
+
   @JsonField(fieldName = SUBOBJECT_FIELD_NAME)
   public SubobjectParseUUT subobjectField;
 
diff --git a/util/src/main/java/com/instagram/common/json/annotation/util/ProcessorClassData.java b/util/src/main/java/com/instagram/common/json/annotation/util/ProcessorClassData.java
index 708ff54..541591b 100644
--- a/util/src/main/java/com/instagram/common/json/annotation/util/ProcessorClassData.java
+++ b/util/src/main/java/com/instagram/common/json/annotation/util/ProcessorClassData.java
@@ -30,7 +30,8 @@ abstract public class ProcessorClassData<AnnotationKeyType, AnnotationRecordType
   }
 
   protected final String mClassPackage;
-  protected final String mClassName;
+  protected final String mQualifiedClassName;
+  protected final String mSimpleClassName;
   protected final String mInjectedClassName;
   private final AnnotationRecordFactory<AnnotationKeyType, AnnotationRecordType> mFactory;
   private Map<AnnotationKeyType, AnnotationRecordType> mData;
@@ -38,16 +39,24 @@ abstract public class ProcessorClassData<AnnotationKeyType, AnnotationRecordType
   /**
    * Creates a ProcessorClassData.
    * @param classPackage the package of the class being inspected.
-   * @param className the simple class name of the class being inspected.  See
-   * {@link Class#getSimpleName()}.
+   * @param qualifiedClassName the fully-qualified class name of the class being inspected.  See
+   * {@link Class#getQualifiedName()}.
+   * @param simpleClassName the simple class name of the class being inspected. See
+   * {@link Class#getSimpleName()}. This may be a partially-qualified name if the class is an
+   * inner class.
    * @param injectedClassName the simple class name of the class this injector will write its
    * generated code to.  See {@link Class#getSimpleName()}.
    * @param factory creates data records.
    */
-  protected ProcessorClassData(String classPackage, String className, String injectedClassName,
+  protected ProcessorClassData(
+      String classPackage,
+      String qualifiedClassName,
+      String simpleClassName,
+      String injectedClassName,
       AnnotationRecordFactory<AnnotationKeyType, AnnotationRecordType> factory) {
     mClassPackage = classPackage;
-    mClassName = className;
+    mQualifiedClassName = qualifiedClassName;
+    mSimpleClassName = simpleClassName;
     mInjectedClassName = injectedClassName;
     mFactory = factory;
     mData = new HashMap<AnnotationKeyType, AnnotationRecordType>();
diff --git a/util/src/main/java/com/instagram/common/json/annotation/util/TypeUtils.java b/util/src/main/java/com/instagram/common/json/annotation/util/TypeUtils.java
index 9cfc1da..ac384eb 100644
--- a/util/src/main/java/com/instagram/common/json/annotation/util/TypeUtils.java
+++ b/util/src/main/java/com/instagram/common/json/annotation/util/TypeUtils.java
@@ -36,12 +36,13 @@ public class TypeUtils {
     STRING,
     PARSABLE_OBJECT,
     ENUM_OBJECT,
-  };
+  }
 
   public enum CollectionType {
     NOT_A_COLLECTION,
     LIST,
     QUEUE,
+    SET,
   }
 
   private static final String JAVA_LANG_STRING = "java.lang.String";
@@ -54,6 +55,8 @@ public class TypeUtils {
   private static final String JAVA_UTIL_LIST_UNTYPED = "java.util.List";
   private static final String JAVA_UTIL_QUEUE = "java.util.Queue<?>";
   private static final String JAVA_UTIL_QUEUE_UNTYPED = "java.util.Queue";
+  private static final String JAVA_UTIL_SET = "java.util.Set<?>";
+  private static final String JAVA_UTIL_SET_UNTYPED = "java.util.Set";
   private static final String JAVA_LANG_ENUM = "java.lang.Enum<?>";
 
   private final Types mTypes;
@@ -122,6 +125,8 @@ public class TypeUtils {
       return CollectionType.LIST;
     } else if (JAVA_UTIL_QUEUE_UNTYPED.equals(erasedType)) {
       return CollectionType.QUEUE;
+    } else if (JAVA_UTIL_SET_UNTYPED.equals(erasedType)) {
+      return CollectionType.SET;
     }
     return CollectionType.NOT_A_COLLECTION;
   }
@@ -146,10 +151,12 @@ public class TypeUtils {
     List<? extends TypeParameterElement> typeParameterElements = typeElement.getTypeParameters();
 
     if (JAVA_UTIL_QUEUE.equals(getCanonicalTypeName(declaredType)) ||
-        JAVA_UTIL_LIST.equals(getCanonicalTypeName(declaredType))) {
+        JAVA_UTIL_LIST.equals(getCanonicalTypeName(declaredType)) ||
+        JAVA_UTIL_SET.equals(getCanonicalTypeName(declaredType))) {
       // sanity check.
       if (typeParameterElements.size() != 1) {
-        throw new IllegalStateException("java list/queue is not expected generic type");
+        throw new IllegalStateException(
+            String.format("%s is not expected generic type", declaredType));
       }
 
       List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
diff --git a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TestAnnotationProcessor.java b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TestAnnotationProcessor.java
index 9e082d1..e14069a 100644
--- a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TestAnnotationProcessor.java
+++ b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TestAnnotationProcessor.java
@@ -154,6 +154,7 @@ public class TestAnnotationProcessor extends AbstractProcessor {
       injector = new TypeGathererClassData(
           packageName,
           typeElement.getQualifiedName().toString(),
+          mTypeUtils.getClassName(typeElement, packageName),
           mTypeUtils.getPrefixForGeneratedClass(typeElement, packageName) + TYPE_DATA_SUFFIX,
           new ProcessorClassData.AnnotationRecordFactory<String, FieldData>() {
 
diff --git a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeGathererClassData.java b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeGathererClassData.java
index fa98393..5bea3d8 100644
--- a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeGathererClassData.java
+++ b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeGathererClassData.java
@@ -34,9 +34,13 @@ import static javax.lang.model.element.Modifier.STATIC;
 public class TypeGathererClassData extends ProcessorClassData<String, FieldData> {
   private TypeGathererClassData mParentClassData;
 
-  public TypeGathererClassData(String classPackage, String className, String injectedClassName,
+  public TypeGathererClassData(
+      String classPackage,
+      String qualifiedClassName,
+      String simpleClassName,
+      String injectedClassName,
       AnnotationRecordFactory<String, FieldData> factory) {
-    super(classPackage, className, injectedClassName, factory);
+    super(classPackage, qualifiedClassName, simpleClassName, injectedClassName, factory);
   }
 
   @Override
@@ -48,7 +52,7 @@ public class TypeGathererClassData extends ProcessorClassData<String, FieldData>
       writer.emitPackage(mClassPackage)
           .beginType(mInjectedClassName, "class", EnumSet.of(PUBLIC, FINAL))
             .beginMethod("void", "injectTypeData", EnumSet.of(PUBLIC, FINAL, STATIC),
-                mClassName, "instance")
+                mSimpleClassName, "instance")
               .emitWithGenerator(new JavaWriter.JavaGenerator() {
                 @Override
                 public void emitJava(JavaWriter writer) throws IOException {

commit 29a594bde083f9a0144e43fc74ecc55177f1ace4
Author: Tony Tung <tonytung@merly.org>
Date:   Thu Sep 25 22:55:29 2014 -0700

    update LICENSE and PATENTS

diff --git a/LICENSE b/LICENSE
index 3ca18f4..dfbfd9c 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,23 +1,30 @@
-Copyright (c) 2014, Instagram
-All rights reserved.
+BSD License
 
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
+For ig-json-parser
 
-* Redistributions of source code must retain the above copyright notice, this
-  list of conditions and the following disclaimer.
+Copyright (c) 2014, Facebook, Inc. All rights reserved.
 
-* Redistributions in binary form must reproduce the above copyright notice,
-  this list of conditions and the following disclaimer in the documentation
-  and/or other materials provided with the distribution.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\ No newline at end of file
+ * Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+ * Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+ * Neither the name Facebook nor the names of its contributors may be used to
+   endorse or promote products derived from this software without specific
+   prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/PATENTS b/PATENTS
new file mode 100644
index 0000000..4be7b80
--- /dev/null
+++ b/PATENTS
@@ -0,0 +1,23 @@
+Additional Grant of Patent Rights
+
+"Software" means the ig-json-parser software distributed by Facebook, Inc.
+
+Facebook hereby grants you a perpetual, worldwide, royalty-free, non-exclusive,
+irrevocable (subject to the termination provision below) license under any
+rights in any patent claims owned by Facebook, to make, have made, use, sell,
+offer to sell, import, and otherwise transfer the Software. For avoidance of
+doubt, no license is granted under Facebooks rights in any patent claims that
+are infringed by (i) modifications to the Software made by you or a third party,
+or (ii) the Software in combination with any software or other technology
+provided by you or a third party.
+
+The license granted hereunder will terminate, automatically and without notice,
+for anyone that makes any claim (including by filing any lawsuit, assertion or
+other action) alleging (a) direct, indirect, or contributory infringement or
+inducement to infringe any patent: (i) by Facebook or any of its subsidiaries or
+affiliates, whether or not such claim is related to the Software, (ii) by any
+party if such claim arises in whole or in part from any software, product or
+service of Facebook or any of its subsidiaries or affiliates, whether or not
+such claim is related to the Software, or (iii) by any party relating to the
+Software; or (b) that any right in any patent claim of Facebook is invalid or
+unenforceable.

commit 4d6c69b5704a5caff88a71eafc3abac5a5c866d6
Author: Tony Tung <tonytung@merly.org>
Date:   Fri Sep 26 12:06:09 2014 -0700

    moved javawriter to a different package to avoid conflict with square's
    version.
    
    removed one instance of static final

diff --git a/javawriter/src/main/java/com/instagram/javawriter/JavaWriter.java b/javawriter/src/main/java/com/instagram/javawriter/JavaWriter.java
new file mode 100644
index 0000000..2c364b3
--- /dev/null
+++ b/javawriter/src/main/java/com/instagram/javawriter/JavaWriter.java
@@ -0,0 +1,856 @@
+// Copyright 2013 Square, Inc.
+package com.instagram.javawriter;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.Writer;
+import java.lang.annotation.Annotation;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.EnumSet;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.lang.model.element.Modifier;
+
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+/** A utility class which aids in generating Java source files. */
+public class JavaWriter implements Closeable {
+  public interface JavaGenerator {
+    public void emitJava(JavaWriter writer) throws IOException;
+  }
+
+  private static final Pattern TYPE_PATTERN = Pattern.compile("(?:[\\w$]+\\.)*([\\w\\.*$]+)");
+  private static final int MAX_SINGLE_LINE_ATTRIBUTES = 3;
+  private static final String INDENT = "  ";
+
+  /** Map fully qualified type names to their short names. */
+  private final Map<String, String> importedTypes = new LinkedHashMap<String, String>();
+
+  private String packagePrefix;
+  private final Deque<Scope> scopes = new ArrayDeque<Scope>();
+  private final Deque<String> types = new ArrayDeque<String>();
+  private final Writer out;
+  private boolean isCompressingTypes = true;
+  private String indent = INDENT;
+
+  /**
+   * @param out the stream to which Java source will be written. This should be a buffered stream.
+   */
+  public JavaWriter(Writer out) {
+    this.out = out;
+  }
+
+  public void setCompressingTypes(boolean isCompressingTypes) {
+    this.isCompressingTypes = isCompressingTypes;
+  }
+
+  public boolean isCompressingTypes() {
+    return isCompressingTypes;
+  }
+
+  public void setIndent(String indent) {
+    this.indent = indent;
+  }
+
+  public String getIndent() {
+    return indent;
+  }
+
+  public JavaWriter emitWithGenerator(JavaGenerator generator) throws IOException {
+    generator.emitJava(this);
+    return this;
+  }
+
+  /** Emit a package declaration and empty line. */
+  public JavaWriter emitPackage(String packageName) throws IOException {
+    if (this.packagePrefix != null) {
+      throw new IllegalStateException();
+    }
+    if (packageName.isEmpty()) {
+      this.packagePrefix = "";
+    } else {
+      out.write("package ");
+      out.write(packageName);
+      out.write(";\n\n");
+      this.packagePrefix = packageName + ".";
+    }
+    return this;
+  }
+
+  /**
+   * Emit an import for each {@code type} provided. For the duration of the file, all references to
+   * these classes will be automatically shortened.
+   */
+  public JavaWriter emitImports(String... types) throws IOException {
+    return emitImports(Arrays.asList(types));
+  }
+
+  /**
+   * Emit an import for each {@code type} provided. For the duration of the file, all references to
+   * these classes will be automatically shortened.
+   */
+  public JavaWriter emitImports(Class<?>... types) throws IOException {
+    List<String> classNames = new ArrayList<String>(types.length);
+    for (Class<?> classToImport : types) {
+      classNames.add(classToImport.getName());
+    }
+    return emitImports(classNames);
+  }
+
+  /**
+   * Emit an import for each {@code type} in the provided {@code Collection}. For the duration of
+   * the file, all references to these classes will be automatically shortened.
+   */
+  public JavaWriter emitImports(Collection<String> types) throws IOException {
+    for (String type : new TreeSet<String>(types)) {
+      Matcher matcher = TYPE_PATTERN.matcher(type);
+      if (!matcher.matches()) {
+        throw new IllegalArgumentException(type);
+      }
+      if (importedTypes.put(type, matcher.group(1)) != null) {
+        throw new IllegalArgumentException(type);
+      }
+      out.write("import ");
+      out.write(type);
+      out.write(";\n");
+    }
+    return this;
+  }
+
+  /**
+   * Emit a static import for each {@code type} provided. For the duration of the file,
+   * all references to these classes will be automatically shortened.
+   */
+  public JavaWriter emitStaticImports(String... types) throws IOException {
+    return emitStaticImports(Arrays.asList(types));
+  }
+
+  /**
+   * Emit a static import for each {@code type} in the provided {@code Collection}. For the
+   * duration of the file, all references to these classes will be automatically shortened.
+   */
+  public JavaWriter emitStaticImports(Collection<String> types) throws IOException {
+    for (String type : new TreeSet<String>(types)) {
+      Matcher matcher = TYPE_PATTERN.matcher(type);
+      if (!matcher.matches()) {
+        throw new IllegalArgumentException(type);
+      }
+      if (importedTypes.put(type, matcher.group(1)) != null) {
+        throw new IllegalArgumentException(type);
+      }
+      out.write("import static ");
+      out.write(type);
+      out.write(";\n");
+    }
+    return this;
+  }
+
+  /**
+   * Emits a name like {@code java.lang.String} or {@code java.util.List<java.lang.String>},
+   * compressing it with imports if possible. Type compression will only be enabled if
+   * {@link #isCompressingTypes} is true.
+   */
+  private JavaWriter emitCompressedType(String type) throws IOException {
+    if (isCompressingTypes) {
+      out.write(compressType(type));
+    } else {
+      out.write(type);
+    }
+    return this;
+  }
+
+  /** Try to compress a fully-qualified class name to only the class name. */
+  public String compressType(String type) {
+    StringBuilder sb = new StringBuilder();
+    if (this.packagePrefix == null) {
+      throw new IllegalStateException();
+    }
+
+    Matcher m = TYPE_PATTERN.matcher(type);
+    int pos = 0;
+    while (true) {
+      boolean found = m.find(pos);
+
+      // Copy non-matching characters like "<".
+      int typeStart = found ? m.start() : type.length();
+      sb.append(type, pos, typeStart);
+
+      if (!found) {
+        break;
+      }
+
+      // Copy a single class name, shortening it if possible.
+      String name = m.group(0);
+      String imported = importedTypes.get(name);
+      if (imported != null) {
+        sb.append(imported);
+      } else if (isClassInPackage(name, packagePrefix)) {
+        String compressed = name.substring(packagePrefix.length());
+        if (isAmbiguous(compressed)) {
+          sb.append(name);
+        } else {
+          sb.append(compressed);
+        }
+      } else if (isClassInPackage(name, "java.lang.")) {
+        sb.append(name.substring("java.lang.".length()));
+      } else {
+        sb.append(name);
+      }
+      pos = m.end();
+    }
+    return sb.toString();
+  }
+
+  private static boolean isClassInPackage(String name, String packagePrefix) {
+    if (name.startsWith(packagePrefix)) {
+      if (name.indexOf('.', packagePrefix.length()) == -1) {
+        return true;
+      }
+      // check to see if the part after the package looks like a class
+      if (Character.isUpperCase(name.charAt(packagePrefix.length()))) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Returns true if the imports contain a class with same simple name as {@code compressed}.
+   *
+   * @param compressed simple name of the type
+   */
+  private boolean isAmbiguous(String compressed) {
+    return importedTypes.values().contains(compressed);
+  }
+
+  /**
+   * Emits an initializer declaration.
+   *
+   * @param isStatic true if it should be an static initializer, false for an instance initializer.
+   */
+  public JavaWriter beginInitializer(boolean isStatic) throws IOException {
+    indent();
+    if (isStatic) {
+      out.write("static");
+      out.write(" {\n");
+    } else {
+      out.write("{\n");
+    }
+    scopes.push(Scope.INITIALIZER);
+    return this;
+  }
+
+  /** Ends the current initializer declaration. */
+  public JavaWriter endInitializer() throws IOException {
+    popScope(Scope.INITIALIZER);
+    indent();
+    out.write("}\n");
+    return this;
+  }
+
+ /**
+  * Emits a type declaration.
+  *
+  * @param kind such as "class", "interface" or "enum".
+  */
+  public JavaWriter beginType(String type, String kind) throws IOException {
+    return beginType(type, kind, EnumSet.noneOf(Modifier.class), null);
+  }
+
+  /**
+   * Emits a type declaration.
+   *
+   * @param kind such as "class", "interface" or "enum".
+   */
+  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers)
+      throws IOException {
+    return beginType(type, kind, modifiers, null);
+  }
+
+  /**
+   * Emits a type declaration.
+   *
+   * @param kind such as "class", "interface" or "enum".
+   * @param extendsType the class to extend, or null for no extends clause.
+   */
+  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers, String extendsType,
+      String... implementsTypes) throws IOException {
+    indent();
+    emitModifiers(modifiers);
+    out.write(kind);
+    out.write(" ");
+    emitCompressedType(type);
+    if (extendsType != null) {
+      out.write(" extends ");
+      emitCompressedType(extendsType);
+    }
+    if (implementsTypes.length > 0) {
+      out.write("\n");
+      indent();
+      out.write("    implements ");
+      for (int i = 0; i < implementsTypes.length; i++) {
+        if (i != 0) {
+          out.write(", ");
+        }
+        emitCompressedType(implementsTypes[i]);
+      }
+    }
+    out.write(" {\n");
+    scopes.push(Scope.TYPE_DECLARATION);
+    types.push(type);
+    return this;
+  }
+
+  /** Completes the current type declaration. */
+  public JavaWriter endType() throws IOException {
+    popScope(Scope.TYPE_DECLARATION);
+    types.pop();
+    indent();
+    out.write("}\n");
+    return this;
+  }
+
+  /** Emits a field declaration. */
+  public JavaWriter emitField(String type, String name) throws IOException {
+    return emitField(type, name, EnumSet.noneOf(Modifier.class), null);
+  }
+
+  /** Emits a field declaration. */
+  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers)
+      throws IOException {
+    return emitField(type, name, modifiers, null);
+  }
+
+  /** Emits a field declaration. */
+  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers,
+      String initialValue) throws IOException {
+    indent();
+    emitModifiers(modifiers);
+    emitCompressedType(type);
+    out.write(" ");
+    out.write(name);
+
+    if (initialValue != null) {
+      out.write(" = ");
+
+      String[] lines = initialValue.split("\n", -1);
+      out.write(lines[0]);
+      for (int i = 1; i < lines.length; i++) {
+        out.write("\n");
+        hangingIndent();
+        out.write(lines[i]);
+      }
+    }
+    out.write(";\n");
+    return this;
+  }
+
+  /**
+   * Emit a method declaration.
+   *
+   * <p>A {@code null} return type may be used to indicate a constructor, but
+   * {@link #beginConstructor(Set, String...)} should be preferred. This behavior may be removed in
+   * a future release.
+   *
+   * @param returnType the method's return type, or null for constructors
+   * @param name the method name, or the fully qualified class name for constructors.
+   * @param modifiers the set of modifiers to be applied to the method
+   * @param parameters alternating parameter types and names.
+   */
+  public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers,
+      String... parameters) throws IOException {
+    return beginMethod(returnType, name, modifiers, Arrays.asList(parameters), null);
+  }
+
+  /**
+   * Emit a method declaration.
+   *
+   * <p>A {@code null} return type may be used to indicate a constructor, but
+   * {@link #beginConstructor(Set, List, List)} should be preferred. This behavior may be removed in
+   * a future release.
+   *
+   * @param returnType the method's return type, or null for constructors.
+   * @param name the method name, or the fully qualified class name for constructors.
+   * @param modifiers the set of modifiers to be applied to the method
+   * @param parameters alternating parameter types and names.
+   * @param throwsTypes the classes to throw, or null for no throws clause.
+   */
+  public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers,
+      List<String> parameters, List<String> throwsTypes) throws IOException {
+    indent();
+    emitModifiers(modifiers);
+    if (returnType != null) {
+      emitCompressedType(returnType);
+      out.write(" ");
+      out.write(name);
+    } else {
+      emitCompressedType(name);
+    }
+    out.write("(");
+    if (parameters != null) {
+      for (int p = 0; p < parameters.size();) {
+        if (p != 0) {
+          out.write(", ");
+        }
+        emitCompressedType(parameters.get(p++));
+        out.write(" ");
+        emitCompressedType(parameters.get(p++));
+      }
+    }
+    out.write(")");
+    if (throwsTypes != null && throwsTypes.size() > 0) {
+      out.write("\n");
+      indent();
+      out.write("    throws ");
+      for (int i = 0; i < throwsTypes.size(); i++) {
+        if (i != 0) {
+          out.write(", ");
+        }
+        emitCompressedType(throwsTypes.get(i));
+      }
+    }
+    if (modifiers.contains(ABSTRACT)) {
+      out.write(";\n");
+      scopes.push(Scope.ABSTRACT_METHOD);
+    } else {
+      out.write(" {\n");
+      scopes.push(returnType == null ? Scope.CONSTRUCTOR : Scope.NON_ABSTRACT_METHOD);
+    }
+    return this;
+  }
+
+  public JavaWriter beginConstructor(Set<Modifier> modifiers, String... parameters)
+      throws IOException {
+    beginMethod(null, types.peekFirst(), modifiers, parameters);
+    return this;
+  }
+
+  public JavaWriter beginConstructor(Set<Modifier> modifiers,
+      List<String> parameters, List<String> throwsTypes)
+      throws IOException {
+    beginMethod(null, types.peekFirst(), modifiers, parameters, throwsTypes);
+    return this;
+  }
+
+  /** Emits some Javadoc comments with line separated by {@code \n}. */
+  public JavaWriter emitJavadoc(String javadoc, Object... params) throws IOException {
+    String formatted = String.format(javadoc, params);
+
+    indent();
+    out.write("/**\n");
+    for (String line : formatted.split("\n")) {
+      indent();
+      out.write(" *");
+      if (!line.isEmpty()) {
+        out.write(" ");
+        out.write(line);
+      }
+      out.write("\n");
+    }
+    indent();
+    out.write(" */\n");
+    return this;
+  }
+
+  /** Emits a single line comment. */
+  public JavaWriter emitSingleLineComment(String comment, Object... args) throws IOException {
+    indent();
+    out.write("// ");
+    out.write(String.format(comment, args));
+    out.write("\n");
+    return this;
+  }
+
+  public JavaWriter emitEmptyLine() throws IOException {
+    out.write("\n");
+    return this;
+  }
+
+  public JavaWriter emitEnumValue(String name) throws IOException {
+    indent();
+    out.write(name);
+    out.write(",\n");
+    return this;
+  }
+
+  /**
+   * A simple switch to emit the proper enum depending if its last causing it to be terminated
+   * by a semi-colon ({@code ;}).
+   */
+  public JavaWriter emitEnumValue(String name, boolean isLast) throws IOException {
+    return isLast ? emitLastEnumValue(name) : emitEnumValue(name);
+  }
+
+  private JavaWriter emitLastEnumValue(String name) throws IOException {
+    indent();
+    out.write(name);
+    out.write(";\n");
+    return this;
+  }
+
+  /** Emit a list of enum values followed by a semi-colon ({@code ;}). */
+  public JavaWriter emitEnumValues(Iterable<String> names) throws IOException {
+    Iterator<String> iterator = names.iterator();
+
+    while (iterator.hasNext()) {
+      String name = iterator.next();
+      if (iterator.hasNext()) {
+        emitEnumValue(name);
+      } else {
+        emitLastEnumValue(name);
+      }
+    }
+
+    return this;
+  }
+
+  /** Equivalent to {@code annotation(annotation, emptyMap())}. */
+  public JavaWriter emitAnnotation(String annotation) throws IOException {
+    return emitAnnotation(annotation, Collections.<String, Object>emptyMap());
+  }
+
+  /** Equivalent to {@code annotation(annotationType.getName(), emptyMap())}. */
+  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType) throws IOException {
+    return emitAnnotation(type(annotationType), Collections.<String, Object>emptyMap());
+  }
+
+  /**
+   * Annotates the next element with {@code annotationType} and a {@code value}.
+   *
+   * @param value an object used as the default (value) parameter of the annotation. The value will
+   *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object
+   *     arrays are written one element per line.
+   */
+  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType, Object value)
+      throws IOException {
+    return emitAnnotation(type(annotationType), value);
+  }
+
+  /**
+   * Annotates the next element with {@code annotation} and a {@code value}.
+   *
+   * @param value an object used as the default (value) parameter of the annotation. The value will
+   *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object
+   *     arrays are written one element per line.
+   */
+  public JavaWriter emitAnnotation(String annotation, Object value) throws IOException {
+    indent();
+    out.write("@");
+    emitCompressedType(annotation);
+    out.write("(");
+    emitAnnotationValue(value);
+    out.write(")");
+    out.write("\n");
+    return this;
+  }
+
+  /** Equivalent to {@code annotation(annotationType.getName(), attributes)}. */
+  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType,
+      Map<String, ?> attributes) throws IOException {
+    return emitAnnotation(type(annotationType), attributes);
+  }
+
+  /**
+   * Annotates the next element with {@code annotation} and {@code attributes}.
+   *
+   * @param attributes a map from annotation attribute names to their values. Values are encoded
+   *     using Object.toString(); use {@link #stringLiteral} for String values. Object arrays are
+   *     written one element per line.
+   */
+  public JavaWriter emitAnnotation(String annotation, Map<String, ?> attributes)
+      throws IOException {
+    indent();
+    out.write("@");
+    emitCompressedType(annotation);
+    switch (attributes.size()) {
+      case 0:
+        break;
+      case 1:
+        Entry<String, ?> onlyEntry = attributes.entrySet().iterator().next();
+        out.write("(");
+        if (!"value".equals(onlyEntry.getKey())) {
+          out.write(onlyEntry.getKey());
+          out.write(" = ");
+        }
+        emitAnnotationValue(onlyEntry.getValue());
+        out.write(")");
+        break;
+      default:
+        boolean split = attributes.size() > MAX_SINGLE_LINE_ATTRIBUTES
+            || containsArray(attributes.values());
+        out.write("(");
+        scopes.push(Scope.ANNOTATION_ATTRIBUTE);
+        String separator = split ? "\n" : "";
+        for (Map.Entry<String, ?> entry : attributes.entrySet()) {
+          out.write(separator);
+          separator = split ? ",\n" : ", ";
+          if (split) {
+            indent();
+          }
+          out.write(entry.getKey());
+          out.write(" = ");
+          Object value = entry.getValue();
+          emitAnnotationValue(value);
+        }
+        popScope(Scope.ANNOTATION_ATTRIBUTE);
+        if (split) {
+          out.write("\n");
+          indent();
+        }
+        out.write(")");
+        break;
+    }
+    out.write("\n");
+    return this;
+  }
+
+  private boolean containsArray(Collection<?> values) {
+    for (Object value : values) {
+      if (value instanceof Object[]) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Writes a single annotation value. If the value is an array, each element in the array will be
+   * written to its own line.
+   */
+  private JavaWriter emitAnnotationValue(Object value) throws IOException {
+    if (value instanceof Object[]) {
+      out.write("{");
+      boolean firstValue = true;
+      scopes.push(Scope.ANNOTATION_ARRAY_VALUE);
+      for (Object o : ((Object[]) value)) {
+        if (firstValue) {
+          firstValue = false;
+          out.write("\n");
+        } else {
+          out.write(",\n");
+        }
+        indent();
+        out.write(o.toString());
+      }
+      popScope(Scope.ANNOTATION_ARRAY_VALUE);
+      out.write("\n");
+      indent();
+      out.write("}");
+    } else {
+      out.write(value.toString());
+    }
+    return this;
+  }
+
+  /**
+   * @param pattern a code pattern like "int i = %s". Newlines will be further indented. Should not
+   *     contain trailing semicolon.
+   */
+  public JavaWriter emitStatement(String pattern, Object... args) throws IOException {
+    checkInMethod();
+    String[] lines = String.format(pattern, args).split("\n", -1);
+    indent();
+    out.write(lines[0]);
+    for (int i = 1; i < lines.length; i++) {
+      out.write("\n");
+      hangingIndent();
+      out.write(lines[i]);
+    }
+    out.write(";\n");
+    return this;
+  }
+
+  /**
+   * @param controlFlow the control flow construct and its code, such as "if (foo == 5)". Shouldn't
+   *     contain braces or newline characters.
+   */
+  public JavaWriter beginControlFlow(String controlFlow) throws IOException {
+    checkInMethod();
+    indent();
+    out.write(controlFlow);
+    out.write(" {\n");
+    scopes.push(Scope.CONTROL_FLOW);
+    return this;
+  }
+
+  /**
+   * @param controlFlow the control flow construct and its code, such as "else if (foo == 10)".
+   *     Shouldn't contain braces or newline characters.
+   */
+  public JavaWriter nextControlFlow(String controlFlow) throws IOException {
+    popScope(Scope.CONTROL_FLOW);
+    indent();
+    scopes.push(Scope.CONTROL_FLOW);
+    out.write("} ");
+    out.write(controlFlow);
+    out.write(" {\n");
+    return this;
+  }
+
+  public JavaWriter endControlFlow() throws IOException {
+    return endControlFlow(null);
+  }
+
+  /**
+   * @param controlFlow the optional control flow construct and its code, such as
+   *     "while(foo == 20)". Only used for "do/while" control flows.
+   */
+  public JavaWriter endControlFlow(String controlFlow) throws IOException {
+    popScope(Scope.CONTROL_FLOW);
+    indent();
+    if (controlFlow != null) {
+      out.write("} ");
+      out.write(controlFlow);
+      out.write(";\n");
+    } else {
+      out.write("}\n");
+    }
+    return this;
+  }
+
+  /** Completes the current method declaration. */
+  public JavaWriter endMethod() throws IOException {
+    Scope popped = scopes.pop();
+    // support calling a constructor a "method" to support the legacy code
+    if (popped == Scope.NON_ABSTRACT_METHOD || popped == Scope.CONSTRUCTOR) {
+      indent();
+      out.write("}\n");
+    } else if (popped != Scope.ABSTRACT_METHOD) {
+      throw new IllegalStateException();
+    }
+    return this;
+  }
+
+  /** Completes the current constructor declaration. */
+  public JavaWriter endConstructor() throws IOException {
+    popScope(Scope.CONSTRUCTOR);
+    indent();
+    out.write("}\n");
+    return this;
+  }
+
+  /** Returns the string literal representing {@code data}, including wrapping quotes. */
+  public static String stringLiteral(String data) {
+    StringBuilder result = new StringBuilder();
+    result.append('"');
+    for (int i = 0; i < data.length(); i++) {
+      char c = data.charAt(i);
+      switch (c) {
+        case '"':
+          result.append("\\\"");
+          break;
+        case '\\':
+          result.append("\\\\");
+          break;
+        case '\b':
+          result.append("\\b");
+          break;
+        case '\t':
+          result.append("\\t");
+          break;
+        case '\n':
+          result.append("\\n");
+          break;
+        case '\f':
+          result.append("\\f");
+          break;
+        case '\r':
+          result.append("\\r");
+          break;
+        default:
+          if (Character.isISOControl(c)) {
+            result.append(String.format("\\u%04x", (int) c));
+          } else {
+            result.append(c);
+          }
+      }
+    }
+    result.append('"');
+    return result.toString();
+  }
+
+  /** Build a string representation of a type and optionally its generic type arguments. */
+  public static String type(Class<?> raw, String... parameters) {
+    if (parameters.length == 0) {
+      return raw.getCanonicalName();
+    }
+    if (raw.getTypeParameters().length != parameters.length) {
+      throw new IllegalArgumentException();
+    }
+    StringBuilder result = new StringBuilder();
+    result.append(raw.getCanonicalName());
+    result.append("<");
+    result.append(parameters[0]);
+    for (int i = 1; i < parameters.length; i++) {
+      result.append(", ");
+      result.append(parameters[i]);
+    }
+    result.append(">");
+    return result.toString();
+  }
+
+  @Override public void close() throws IOException {
+    out.close();
+  }
+
+  /** Emits the modifiers to the writer. */
+  private void emitModifiers(Set<Modifier> modifiers) throws IOException {
+    // Use an EnumSet to ensure the proper ordering
+    if (!(modifiers instanceof EnumSet)) {
+      modifiers = EnumSet.copyOf(modifiers);
+    }
+    for (Modifier modifier : modifiers) {
+      out.append(modifier.toString()).append(' ');
+    }
+  }
+
+  private void indent() throws IOException {
+    for (int i = 0, count = scopes.size(); i < count; i++) {
+      out.write(indent);
+    }
+  }
+
+  private void hangingIndent() throws IOException {
+    for (int i = 0, count = scopes.size() + 2; i < count; i++) {
+      out.write(indent);
+    }
+  }
+
+  private static final EnumSet<Scope> METHOD_SCOPES = EnumSet.of(
+      Scope.NON_ABSTRACT_METHOD, Scope.CONSTRUCTOR, Scope.CONTROL_FLOW, Scope.INITIALIZER);
+
+  private void checkInMethod() {
+    if (!METHOD_SCOPES.contains(scopes.peekFirst())) {
+      throw new IllegalArgumentException();
+    }
+  }
+
+  private void popScope(Scope expected) {
+    if (scopes.pop() != expected) {
+      throw new IllegalStateException();
+    }
+  }
+
+  private enum Scope {
+    TYPE_DECLARATION,
+    ABSTRACT_METHOD,
+    NON_ABSTRACT_METHOD,
+    CONSTRUCTOR,
+    CONTROL_FLOW,
+    ANNOTATION_ATTRIBUTE,
+    ANNOTATION_ARRAY_VALUE,
+    INITIALIZER
+  }
+}
diff --git a/javawriter/src/main/java/com/squareup/javawriter/JavaWriter.java b/javawriter/src/main/java/com/squareup/javawriter/JavaWriter.java
deleted file mode 100644
index 1b2dc5b..0000000
--- a/javawriter/src/main/java/com/squareup/javawriter/JavaWriter.java
+++ /dev/null
@@ -1,856 +0,0 @@
-// Copyright 2013 Square, Inc.
-package com.squareup.javawriter;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.Writer;
-import java.lang.annotation.Annotation;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Deque;
-import java.util.EnumSet;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import javax.lang.model.element.Modifier;
-
-import static javax.lang.model.element.Modifier.ABSTRACT;
-
-/** A utility class which aids in generating Java source files. */
-public class JavaWriter implements Closeable {
-  public interface JavaGenerator {
-    public void emitJava(JavaWriter writer) throws IOException;
-  }
-
-  private static final Pattern TYPE_PATTERN = Pattern.compile("(?:[\\w$]+\\.)*([\\w\\.*$]+)");
-  private static final int MAX_SINGLE_LINE_ATTRIBUTES = 3;
-  private static final String INDENT = "  ";
-
-  /** Map fully qualified type names to their short names. */
-  private final Map<String, String> importedTypes = new LinkedHashMap<String, String>();
-
-  private String packagePrefix;
-  private final Deque<Scope> scopes = new ArrayDeque<Scope>();
-  private final Deque<String> types = new ArrayDeque<String>();
-  private final Writer out;
-  private boolean isCompressingTypes = true;
-  private String indent = INDENT;
-
-  /**
-   * @param out the stream to which Java source will be written. This should be a buffered stream.
-   */
-  public JavaWriter(Writer out) {
-    this.out = out;
-  }
-
-  public void setCompressingTypes(boolean isCompressingTypes) {
-    this.isCompressingTypes = isCompressingTypes;
-  }
-
-  public boolean isCompressingTypes() {
-    return isCompressingTypes;
-  }
-
-  public void setIndent(String indent) {
-    this.indent = indent;
-  }
-
-  public String getIndent() {
-    return indent;
-  }
-
-  public JavaWriter emitWithGenerator(JavaGenerator generator) throws IOException {
-    generator.emitJava(this);
-    return this;
-  }
-
-  /** Emit a package declaration and empty line. */
-  public JavaWriter emitPackage(String packageName) throws IOException {
-    if (this.packagePrefix != null) {
-      throw new IllegalStateException();
-    }
-    if (packageName.isEmpty()) {
-      this.packagePrefix = "";
-    } else {
-      out.write("package ");
-      out.write(packageName);
-      out.write(";\n\n");
-      this.packagePrefix = packageName + ".";
-    }
-    return this;
-  }
-
-  /**
-   * Emit an import for each {@code type} provided. For the duration of the file, all references to
-   * these classes will be automatically shortened.
-   */
-  public JavaWriter emitImports(String... types) throws IOException {
-    return emitImports(Arrays.asList(types));
-  }
-
-  /**
-   * Emit an import for each {@code type} provided. For the duration of the file, all references to
-   * these classes will be automatically shortened.
-   */
-  public JavaWriter emitImports(Class<?>... types) throws IOException {
-    List<String> classNames = new ArrayList<String>(types.length);
-    for (Class<?> classToImport : types) {
-      classNames.add(classToImport.getName());
-    }
-    return emitImports(classNames);
-  }
-
-  /**
-   * Emit an import for each {@code type} in the provided {@code Collection}. For the duration of
-   * the file, all references to these classes will be automatically shortened.
-   */
-  public JavaWriter emitImports(Collection<String> types) throws IOException {
-    for (String type : new TreeSet<String>(types)) {
-      Matcher matcher = TYPE_PATTERN.matcher(type);
-      if (!matcher.matches()) {
-        throw new IllegalArgumentException(type);
-      }
-      if (importedTypes.put(type, matcher.group(1)) != null) {
-        throw new IllegalArgumentException(type);
-      }
-      out.write("import ");
-      out.write(type);
-      out.write(";\n");
-    }
-    return this;
-  }
-
-  /**
-   * Emit a static import for each {@code type} provided. For the duration of the file,
-   * all references to these classes will be automatically shortened.
-   */
-  public JavaWriter emitStaticImports(String... types) throws IOException {
-    return emitStaticImports(Arrays.asList(types));
-  }
-
-  /**
-   * Emit a static import for each {@code type} in the provided {@code Collection}. For the
-   * duration of the file, all references to these classes will be automatically shortened.
-   */
-  public JavaWriter emitStaticImports(Collection<String> types) throws IOException {
-    for (String type : new TreeSet<String>(types)) {
-      Matcher matcher = TYPE_PATTERN.matcher(type);
-      if (!matcher.matches()) {
-        throw new IllegalArgumentException(type);
-      }
-      if (importedTypes.put(type, matcher.group(1)) != null) {
-        throw new IllegalArgumentException(type);
-      }
-      out.write("import static ");
-      out.write(type);
-      out.write(";\n");
-    }
-    return this;
-  }
-
-  /**
-   * Emits a name like {@code java.lang.String} or {@code java.util.List<java.lang.String>},
-   * compressing it with imports if possible. Type compression will only be enabled if
-   * {@link #isCompressingTypes} is true.
-   */
-  private JavaWriter emitCompressedType(String type) throws IOException {
-    if (isCompressingTypes) {
-      out.write(compressType(type));
-    } else {
-      out.write(type);
-    }
-    return this;
-  }
-
-  /** Try to compress a fully-qualified class name to only the class name. */
-  public String compressType(String type) {
-    StringBuilder sb = new StringBuilder();
-    if (this.packagePrefix == null) {
-      throw new IllegalStateException();
-    }
-
-    Matcher m = TYPE_PATTERN.matcher(type);
-    int pos = 0;
-    while (true) {
-      boolean found = m.find(pos);
-
-      // Copy non-matching characters like "<".
-      int typeStart = found ? m.start() : type.length();
-      sb.append(type, pos, typeStart);
-
-      if (!found) {
-        break;
-      }
-
-      // Copy a single class name, shortening it if possible.
-      String name = m.group(0);
-      String imported = importedTypes.get(name);
-      if (imported != null) {
-        sb.append(imported);
-      } else if (isClassInPackage(name, packagePrefix)) {
-        String compressed = name.substring(packagePrefix.length());
-        if (isAmbiguous(compressed)) {
-          sb.append(name);
-        } else {
-          sb.append(compressed);
-        }
-      } else if (isClassInPackage(name, "java.lang.")) {
-        sb.append(name.substring("java.lang.".length()));
-      } else {
-        sb.append(name);
-      }
-      pos = m.end();
-    }
-    return sb.toString();
-  }
-
-  private static boolean isClassInPackage(String name, String packagePrefix) {
-    if (name.startsWith(packagePrefix)) {
-      if (name.indexOf('.', packagePrefix.length()) == -1) {
-        return true;
-      }
-      // check to see if the part after the package looks like a class
-      if (Character.isUpperCase(name.charAt(packagePrefix.length()))) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * Returns true if the imports contain a class with same simple name as {@code compressed}.
-   *
-   * @param compressed simple name of the type
-   */
-  private boolean isAmbiguous(String compressed) {
-    return importedTypes.values().contains(compressed);
-  }
-
-  /**
-   * Emits an initializer declaration.
-   *
-   * @param isStatic true if it should be an static initializer, false for an instance initializer.
-   */
-  public JavaWriter beginInitializer(boolean isStatic) throws IOException {
-    indent();
-    if (isStatic) {
-      out.write("static");
-      out.write(" {\n");
-    } else {
-      out.write("{\n");
-    }
-    scopes.push(Scope.INITIALIZER);
-    return this;
-  }
-
-  /** Ends the current initializer declaration. */
-  public JavaWriter endInitializer() throws IOException {
-    popScope(Scope.INITIALIZER);
-    indent();
-    out.write("}\n");
-    return this;
-  }
-
- /**
-  * Emits a type declaration.
-  *
-  * @param kind such as "class", "interface" or "enum".
-  */
-  public JavaWriter beginType(String type, String kind) throws IOException {
-    return beginType(type, kind, EnumSet.noneOf(Modifier.class), null);
-  }
-
-  /**
-   * Emits a type declaration.
-   *
-   * @param kind such as "class", "interface" or "enum".
-   */
-  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers)
-      throws IOException {
-    return beginType(type, kind, modifiers, null);
-  }
-
-  /**
-   * Emits a type declaration.
-   *
-   * @param kind such as "class", "interface" or "enum".
-   * @param extendsType the class to extend, or null for no extends clause.
-   */
-  public JavaWriter beginType(String type, String kind, Set<Modifier> modifiers, String extendsType,
-      String... implementsTypes) throws IOException {
-    indent();
-    emitModifiers(modifiers);
-    out.write(kind);
-    out.write(" ");
-    emitCompressedType(type);
-    if (extendsType != null) {
-      out.write(" extends ");
-      emitCompressedType(extendsType);
-    }
-    if (implementsTypes.length > 0) {
-      out.write("\n");
-      indent();
-      out.write("    implements ");
-      for (int i = 0; i < implementsTypes.length; i++) {
-        if (i != 0) {
-          out.write(", ");
-        }
-        emitCompressedType(implementsTypes[i]);
-      }
-    }
-    out.write(" {\n");
-    scopes.push(Scope.TYPE_DECLARATION);
-    types.push(type);
-    return this;
-  }
-
-  /** Completes the current type declaration. */
-  public JavaWriter endType() throws IOException {
-    popScope(Scope.TYPE_DECLARATION);
-    types.pop();
-    indent();
-    out.write("}\n");
-    return this;
-  }
-
-  /** Emits a field declaration. */
-  public JavaWriter emitField(String type, String name) throws IOException {
-    return emitField(type, name, EnumSet.noneOf(Modifier.class), null);
-  }
-
-  /** Emits a field declaration. */
-  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers)
-      throws IOException {
-    return emitField(type, name, modifiers, null);
-  }
-
-  /** Emits a field declaration. */
-  public JavaWriter emitField(String type, String name, Set<Modifier> modifiers,
-      String initialValue) throws IOException {
-    indent();
-    emitModifiers(modifiers);
-    emitCompressedType(type);
-    out.write(" ");
-    out.write(name);
-
-    if (initialValue != null) {
-      out.write(" = ");
-
-      String[] lines = initialValue.split("\n", -1);
-      out.write(lines[0]);
-      for (int i = 1; i < lines.length; i++) {
-        out.write("\n");
-        hangingIndent();
-        out.write(lines[i]);
-      }
-    }
-    out.write(";\n");
-    return this;
-  }
-
-  /**
-   * Emit a method declaration.
-   *
-   * <p>A {@code null} return type may be used to indicate a constructor, but
-   * {@link #beginConstructor(Set, String...)} should be preferred. This behavior may be removed in
-   * a future release.
-   *
-   * @param returnType the method's return type, or null for constructors
-   * @param name the method name, or the fully qualified class name for constructors.
-   * @param modifiers the set of modifiers to be applied to the method
-   * @param parameters alternating parameter types and names.
-   */
-  public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers,
-      String... parameters) throws IOException {
-    return beginMethod(returnType, name, modifiers, Arrays.asList(parameters), null);
-  }
-
-  /**
-   * Emit a method declaration.
-   *
-   * <p>A {@code null} return type may be used to indicate a constructor, but
-   * {@link #beginConstructor(Set, List, List)} should be preferred. This behavior may be removed in
-   * a future release.
-   *
-   * @param returnType the method's return type, or null for constructors.
-   * @param name the method name, or the fully qualified class name for constructors.
-   * @param modifiers the set of modifiers to be applied to the method
-   * @param parameters alternating parameter types and names.
-   * @param throwsTypes the classes to throw, or null for no throws clause.
-   */
-  public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers,
-      List<String> parameters, List<String> throwsTypes) throws IOException {
-    indent();
-    emitModifiers(modifiers);
-    if (returnType != null) {
-      emitCompressedType(returnType);
-      out.write(" ");
-      out.write(name);
-    } else {
-      emitCompressedType(name);
-    }
-    out.write("(");
-    if (parameters != null) {
-      for (int p = 0; p < parameters.size();) {
-        if (p != 0) {
-          out.write(", ");
-        }
-        emitCompressedType(parameters.get(p++));
-        out.write(" ");
-        emitCompressedType(parameters.get(p++));
-      }
-    }
-    out.write(")");
-    if (throwsTypes != null && throwsTypes.size() > 0) {
-      out.write("\n");
-      indent();
-      out.write("    throws ");
-      for (int i = 0; i < throwsTypes.size(); i++) {
-        if (i != 0) {
-          out.write(", ");
-        }
-        emitCompressedType(throwsTypes.get(i));
-      }
-    }
-    if (modifiers.contains(ABSTRACT)) {
-      out.write(";\n");
-      scopes.push(Scope.ABSTRACT_METHOD);
-    } else {
-      out.write(" {\n");
-      scopes.push(returnType == null ? Scope.CONSTRUCTOR : Scope.NON_ABSTRACT_METHOD);
-    }
-    return this;
-  }
-
-  public JavaWriter beginConstructor(Set<Modifier> modifiers, String... parameters)
-      throws IOException {
-    beginMethod(null, types.peekFirst(), modifiers, parameters);
-    return this;
-  }
-
-  public JavaWriter beginConstructor(Set<Modifier> modifiers,
-      List<String> parameters, List<String> throwsTypes)
-      throws IOException {
-    beginMethod(null, types.peekFirst(), modifiers, parameters, throwsTypes);
-    return this;
-  }
-
-  /** Emits some Javadoc comments with line separated by {@code \n}. */
-  public JavaWriter emitJavadoc(String javadoc, Object... params) throws IOException {
-    String formatted = String.format(javadoc, params);
-
-    indent();
-    out.write("/**\n");
-    for (String line : formatted.split("\n")) {
-      indent();
-      out.write(" *");
-      if (!line.isEmpty()) {
-        out.write(" ");
-        out.write(line);
-      }
-      out.write("\n");
-    }
-    indent();
-    out.write(" */\n");
-    return this;
-  }
-
-  /** Emits a single line comment. */
-  public JavaWriter emitSingleLineComment(String comment, Object... args) throws IOException {
-    indent();
-    out.write("// ");
-    out.write(String.format(comment, args));
-    out.write("\n");
-    return this;
-  }
-
-  public JavaWriter emitEmptyLine() throws IOException {
-    out.write("\n");
-    return this;
-  }
-
-  public JavaWriter emitEnumValue(String name) throws IOException {
-    indent();
-    out.write(name);
-    out.write(",\n");
-    return this;
-  }
-
-  /**
-   * A simple switch to emit the proper enum depending if its last causing it to be terminated
-   * by a semi-colon ({@code ;}).
-   */
-  public JavaWriter emitEnumValue(String name, boolean isLast) throws IOException {
-    return isLast ? emitLastEnumValue(name) : emitEnumValue(name);
-  }
-
-  private JavaWriter emitLastEnumValue(String name) throws IOException {
-    indent();
-    out.write(name);
-    out.write(";\n");
-    return this;
-  }
-
-  /** Emit a list of enum values followed by a semi-colon ({@code ;}). */
-  public JavaWriter emitEnumValues(Iterable<String> names) throws IOException {
-    Iterator<String> iterator = names.iterator();
-
-    while (iterator.hasNext()) {
-      String name = iterator.next();
-      if (iterator.hasNext()) {
-        emitEnumValue(name);
-      } else {
-        emitLastEnumValue(name);
-      }
-    }
-
-    return this;
-  }
-
-  /** Equivalent to {@code annotation(annotation, emptyMap())}. */
-  public JavaWriter emitAnnotation(String annotation) throws IOException {
-    return emitAnnotation(annotation, Collections.<String, Object>emptyMap());
-  }
-
-  /** Equivalent to {@code annotation(annotationType.getName(), emptyMap())}. */
-  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType) throws IOException {
-    return emitAnnotation(type(annotationType), Collections.<String, Object>emptyMap());
-  }
-
-  /**
-   * Annotates the next element with {@code annotationType} and a {@code value}.
-   *
-   * @param value an object used as the default (value) parameter of the annotation. The value will
-   *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object
-   *     arrays are written one element per line.
-   */
-  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType, Object value)
-      throws IOException {
-    return emitAnnotation(type(annotationType), value);
-  }
-
-  /**
-   * Annotates the next element with {@code annotation} and a {@code value}.
-   *
-   * @param value an object used as the default (value) parameter of the annotation. The value will
-   *     be encoded using Object.toString(); use {@link #stringLiteral} for String values. Object
-   *     arrays are written one element per line.
-   */
-  public JavaWriter emitAnnotation(String annotation, Object value) throws IOException {
-    indent();
-    out.write("@");
-    emitCompressedType(annotation);
-    out.write("(");
-    emitAnnotationValue(value);
-    out.write(")");
-    out.write("\n");
-    return this;
-  }
-
-  /** Equivalent to {@code annotation(annotationType.getName(), attributes)}. */
-  public JavaWriter emitAnnotation(Class<? extends Annotation> annotationType,
-      Map<String, ?> attributes) throws IOException {
-    return emitAnnotation(type(annotationType), attributes);
-  }
-
-  /**
-   * Annotates the next element with {@code annotation} and {@code attributes}.
-   *
-   * @param attributes a map from annotation attribute names to their values. Values are encoded
-   *     using Object.toString(); use {@link #stringLiteral} for String values. Object arrays are
-   *     written one element per line.
-   */
-  public JavaWriter emitAnnotation(String annotation, Map<String, ?> attributes)
-      throws IOException {
-    indent();
-    out.write("@");
-    emitCompressedType(annotation);
-    switch (attributes.size()) {
-      case 0:
-        break;
-      case 1:
-        Entry<String, ?> onlyEntry = attributes.entrySet().iterator().next();
-        out.write("(");
-        if (!"value".equals(onlyEntry.getKey())) {
-          out.write(onlyEntry.getKey());
-          out.write(" = ");
-        }
-        emitAnnotationValue(onlyEntry.getValue());
-        out.write(")");
-        break;
-      default:
-        boolean split = attributes.size() > MAX_SINGLE_LINE_ATTRIBUTES
-            || containsArray(attributes.values());
-        out.write("(");
-        scopes.push(Scope.ANNOTATION_ATTRIBUTE);
-        String separator = split ? "\n" : "";
-        for (Map.Entry<String, ?> entry : attributes.entrySet()) {
-          out.write(separator);
-          separator = split ? ",\n" : ", ";
-          if (split) {
-            indent();
-          }
-          out.write(entry.getKey());
-          out.write(" = ");
-          Object value = entry.getValue();
-          emitAnnotationValue(value);
-        }
-        popScope(Scope.ANNOTATION_ATTRIBUTE);
-        if (split) {
-          out.write("\n");
-          indent();
-        }
-        out.write(")");
-        break;
-    }
-    out.write("\n");
-    return this;
-  }
-
-  private boolean containsArray(Collection<?> values) {
-    for (Object value : values) {
-      if (value instanceof Object[]) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * Writes a single annotation value. If the value is an array, each element in the array will be
-   * written to its own line.
-   */
-  private JavaWriter emitAnnotationValue(Object value) throws IOException {
-    if (value instanceof Object[]) {
-      out.write("{");
-      boolean firstValue = true;
-      scopes.push(Scope.ANNOTATION_ARRAY_VALUE);
-      for (Object o : ((Object[]) value)) {
-        if (firstValue) {
-          firstValue = false;
-          out.write("\n");
-        } else {
-          out.write(",\n");
-        }
-        indent();
-        out.write(o.toString());
-      }
-      popScope(Scope.ANNOTATION_ARRAY_VALUE);
-      out.write("\n");
-      indent();
-      out.write("}");
-    } else {
-      out.write(value.toString());
-    }
-    return this;
-  }
-
-  /**
-   * @param pattern a code pattern like "int i = %s". Newlines will be further indented. Should not
-   *     contain trailing semicolon.
-   */
-  public JavaWriter emitStatement(String pattern, Object... args) throws IOException {
-    checkInMethod();
-    String[] lines = String.format(pattern, args).split("\n", -1);
-    indent();
-    out.write(lines[0]);
-    for (int i = 1; i < lines.length; i++) {
-      out.write("\n");
-      hangingIndent();
-      out.write(lines[i]);
-    }
-    out.write(";\n");
-    return this;
-  }
-
-  /**
-   * @param controlFlow the control flow construct and its code, such as "if (foo == 5)". Shouldn't
-   *     contain braces or newline characters.
-   */
-  public JavaWriter beginControlFlow(String controlFlow) throws IOException {
-    checkInMethod();
-    indent();
-    out.write(controlFlow);
-    out.write(" {\n");
-    scopes.push(Scope.CONTROL_FLOW);
-    return this;
-  }
-
-  /**
-   * @param controlFlow the control flow construct and its code, such as "else if (foo == 10)".
-   *     Shouldn't contain braces or newline characters.
-   */
-  public JavaWriter nextControlFlow(String controlFlow) throws IOException {
-    popScope(Scope.CONTROL_FLOW);
-    indent();
-    scopes.push(Scope.CONTROL_FLOW);
-    out.write("} ");
-    out.write(controlFlow);
-    out.write(" {\n");
-    return this;
-  }
-
-  public JavaWriter endControlFlow() throws IOException {
-    return endControlFlow(null);
-  }
-
-  /**
-   * @param controlFlow the optional control flow construct and its code, such as
-   *     "while(foo == 20)". Only used for "do/while" control flows.
-   */
-  public JavaWriter endControlFlow(String controlFlow) throws IOException {
-    popScope(Scope.CONTROL_FLOW);
-    indent();
-    if (controlFlow != null) {
-      out.write("} ");
-      out.write(controlFlow);
-      out.write(";\n");
-    } else {
-      out.write("}\n");
-    }
-    return this;
-  }
-
-  /** Completes the current method declaration. */
-  public JavaWriter endMethod() throws IOException {
-    Scope popped = scopes.pop();
-    // support calling a constructor a "method" to support the legacy code
-    if (popped == Scope.NON_ABSTRACT_METHOD || popped == Scope.CONSTRUCTOR) {
-      indent();
-      out.write("}\n");
-    } else if (popped != Scope.ABSTRACT_METHOD) {
-      throw new IllegalStateException();
-    }
-    return this;
-  }
-
-  /** Completes the current constructor declaration. */
-  public JavaWriter endConstructor() throws IOException {
-    popScope(Scope.CONSTRUCTOR);
-    indent();
-    out.write("}\n");
-    return this;
-  }
-
-  /** Returns the string literal representing {@code data}, including wrapping quotes. */
-  public static String stringLiteral(String data) {
-    StringBuilder result = new StringBuilder();
-    result.append('"');
-    for (int i = 0; i < data.length(); i++) {
-      char c = data.charAt(i);
-      switch (c) {
-        case '"':
-          result.append("\\\"");
-          break;
-        case '\\':
-          result.append("\\\\");
-          break;
-        case '\b':
-          result.append("\\b");
-          break;
-        case '\t':
-          result.append("\\t");
-          break;
-        case '\n':
-          result.append("\\n");
-          break;
-        case '\f':
-          result.append("\\f");
-          break;
-        case '\r':
-          result.append("\\r");
-          break;
-        default:
-          if (Character.isISOControl(c)) {
-            result.append(String.format("\\u%04x", (int) c));
-          } else {
-            result.append(c);
-          }
-      }
-    }
-    result.append('"');
-    return result.toString();
-  }
-
-  /** Build a string representation of a type and optionally its generic type arguments. */
-  public static String type(Class<?> raw, String... parameters) {
-    if (parameters.length == 0) {
-      return raw.getCanonicalName();
-    }
-    if (raw.getTypeParameters().length != parameters.length) {
-      throw new IllegalArgumentException();
-    }
-    StringBuilder result = new StringBuilder();
-    result.append(raw.getCanonicalName());
-    result.append("<");
-    result.append(parameters[0]);
-    for (int i = 1; i < parameters.length; i++) {
-      result.append(", ");
-      result.append(parameters[i]);
-    }
-    result.append(">");
-    return result.toString();
-  }
-
-  @Override public void close() throws IOException {
-    out.close();
-  }
-
-  /** Emits the modifiers to the writer. */
-  private void emitModifiers(Set<Modifier> modifiers) throws IOException {
-    // Use an EnumSet to ensure the proper ordering
-    if (!(modifiers instanceof EnumSet)) {
-      modifiers = EnumSet.copyOf(modifiers);
-    }
-    for (Modifier modifier : modifiers) {
-      out.append(modifier.toString()).append(' ');
-    }
-  }
-
-  private void indent() throws IOException {
-    for (int i = 0, count = scopes.size(); i < count; i++) {
-      out.write(indent);
-    }
-  }
-
-  private void hangingIndent() throws IOException {
-    for (int i = 0, count = scopes.size() + 2; i < count; i++) {
-      out.write(indent);
-    }
-  }
-
-  private static final EnumSet<Scope> METHOD_SCOPES = EnumSet.of(
-      Scope.NON_ABSTRACT_METHOD, Scope.CONSTRUCTOR, Scope.CONTROL_FLOW, Scope.INITIALIZER);
-
-  private void checkInMethod() {
-    if (!METHOD_SCOPES.contains(scopes.peekFirst())) {
-      throw new IllegalArgumentException();
-    }
-  }
-
-  private void popScope(Scope expected) {
-    if (scopes.pop() != expected) {
-      throw new IllegalStateException();
-    }
-  }
-
-  private enum Scope {
-    TYPE_DECLARATION,
-    ABSTRACT_METHOD,
-    NON_ABSTRACT_METHOD,
-    CONSTRUCTOR,
-    CONTROL_FLOW,
-    ANNOTATION_ATTRIBUTE,
-    ANNOTATION_ARRAY_VALUE,
-    INITIALIZER
-  }
-}
diff --git a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java
index 15fcdc2..bbc2966 100644
--- a/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java
+++ b/processor/src/main/java/com/instagram/common/json/annotation/processor/JsonParserClassData.java
@@ -28,7 +28,7 @@ import com.instagram.common.json.annotation.util.TypeUtils;
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.core.JsonToken;
-import com.squareup.javawriter.JavaWriter;
+import com.instagram.javawriter.JavaWriter;
 
 import static javax.lang.model.element.Modifier.*;
 
diff --git a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeGathererClassData.java b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeGathererClassData.java
index 5bea3d8..7b996ca 100644
--- a/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeGathererClassData.java
+++ b/util/testprocessor/src/main/java/com/instagram/common/json/annotation/util/TypeGathererClassData.java
@@ -6,11 +6,10 @@ import javax.annotation.processing.Messager;
 
 import java.io.IOException;
 import java.io.StringWriter;
-import java.util.Arrays;
 import java.util.EnumSet;
 import java.util.Map;
 
-import com.squareup.javawriter.JavaWriter;
+import com.instagram.javawriter.JavaWriter;
 
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -51,7 +50,7 @@ public class TypeGathererClassData extends ProcessorClassData<String, FieldData>
     try {
       writer.emitPackage(mClassPackage)
           .beginType(mInjectedClassName, "class", EnumSet.of(PUBLIC, FINAL))
-            .beginMethod("void", "injectTypeData", EnumSet.of(PUBLIC, FINAL, STATIC),
+            .beginMethod("void", "injectTypeData", EnumSet.of(PUBLIC, STATIC),
                 mSimpleClassName, "instance")
               .emitWithGenerator(new JavaWriter.JavaGenerator() {
                 @Override

commit 5aaefb034c6615eaf16ed8d0fdf5c68673d25923
Author: Tony Tung <tonytung@merly.org>
Date:   Fri Sep 26 13:23:51 2014 -0700

    bump to 0.0.4

diff --git a/README.md b/README.md
index 05a5e09..6f8cf35 100644
--- a/README.md
+++ b/README.md
@@ -50,7 +50,7 @@ To use this library, add this to your build.gradle file:
       ]
     }
     dependencies {
-      compile group: 'com.instagram', name: 'ig-json-parser-processor', version: '0.0.3+'
+      compile group: 'com.instagram', name: 'ig-json-parser-processor', version: '0.0.4+'
     }
 
 
